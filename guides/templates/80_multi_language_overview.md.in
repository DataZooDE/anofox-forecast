# Multi-Language Support - Write Once, Use Everywhere

## The Power of SQL-Based Forecasting

**Core Insight**: Since anofox-forecast is a DuckDB extension, your forecasting logic is **pure SQL** and works across **all** programming languages that have DuckDB bindings!

**Write once in SQL → Use from Python, R, Julia, C++, Rust, Node.js, Go, Java, and more!**

---

## Supported Languages

### Production-Ready (with dedicated guides)

| Language | Guide | Best For | Performance |
|----------|-------|----------|-------------|
| **Python** | [81_python_integration.md](81_python_integration.md) | Data science, ML pipelines, APIs | ⚡⚡⚡⚡ |
| **R** | [82_r_integration.md](82_r_integration.md) | Statistical analysis, reports, dashboards | ⚡⚡⚡⚡ |
| **Julia** | [83_julia_integration.md](83_julia_integration.md) | Scientific computing, research | ⚡⚡⚡⚡⚡ |
| **C++** | [84_cpp_integration.md](84_cpp_integration.md) | High-performance services, embedded | ⚡⚡⚡⚡⚡ |
| **Rust** | [85_rust_integration.md](85_rust_integration.md) | Safe production services, CLI tools | ⚡⚡⚡⚡⚡ |

### Also Supported (via DuckDB bindings)

- **Node.js/JavaScript**: Web applications, serverless
- **Go**: Microservices, cloud-native apps
- **Java/Kotlin**: Enterprise applications
- **C#/.NET**: Windows applications
- **Swift**: iOS/macOS applications
- **And many more!**

---

## Universal SQL Pattern

### The Same SQL Works Everywhere!

**SQL Query** (write once):
<!-- include: test/sql/docs_examples/80_multi_language_overview_example_01.sql -->

**Use from Python**:
```python
forecast = con.execute("SELECT * FROM TS_FORECAST(...)").fetchdf()
```

**Use from R**:
```r
forecast <- dbGetQuery(con, "SELECT * FROM TS_FORECAST(...)")
```

**Use from Julia**:
```julia
forecast = DataFrame(DBInterface.execute(con, "SELECT * FROM TS_FORECAST(...)"))
```

**Use from C++**:
```cpp
auto forecast = con.Query("SELECT * FROM TS_FORECAST(...)");
```

**Use from Rust**:
```rust
let forecast = conn.prepare("SELECT * FROM TS_FORECAST(...)")?.query_map(...)?;
```

**Same logic, different language bindings!**

---

## Language Comparison

### Quick Comparison Matrix

| Feature | Python | R | Julia | C++ | Rust |
|---------|--------|---|-------|-----|------|
| **Setup Complexity** | Easy | Easy | Easy | Medium | Medium |
| **Learning Curve** | Low | Low | Medium | High | High |
| **Performance** | Good | Good | Excellent | Excellent | Excellent |
| **Type Safety** | No | No | Yes | Yes | Yes |
| **Memory Safety** | GC | GC | GC | Manual | Automatic |
| **Async Support** | ✅ | ❌ | ✅ | ✅ | ✅ |
| **Data Science Ecosystem** | ✅✅✅ | ✅✅✅ | ✅✅ | ❌ | ❌ |
| **Production Services** | ✅✅ | ✅ | ✅✅ | ✅✅✅ | ✅✅✅ |
| **Notebook Support** | Jupyter | RMarkdown | Pluto | ❌ | ❌ |
| **Plotting** | matplotlib, plotly | ggplot2 | Plots.jl | External | External |

### When to Use Each Language

**Python** → Data science, ML integration, rapid prototyping, Jupyter notebooks

**R** → Statistical analysis, academic research, RMarkdown reports, Shiny dashboards

**Julia** → High-performance scientific computing, numerical analysis, research

**C++** → Maximum performance, embedded systems, low-latency trading, game engines

**Rust** → Production services needing safety, CLI tools, systems programming

---

## Integration Patterns

### Pattern 1: Polyglot Team

**Scenario**: Data scientists use Python, engineering uses Rust/C++

```python
# Data scientist writes SQL logic (Python)
forecast_query = """
    SELECT * FROM TS_FORECAST_BY('sales', product_id, date, amount,
                                 'AutoETS', 28, {'seasonal_period': 7})
"""

# Test in Python
forecast = con.execute(forecast_query).fetchdf()

# Share SQL with engineering team
with open('forecast_query.sql', 'w') as f:
    f.write(forecast_query)
```

```rust
// Engineer uses same SQL in Rust service
let forecast_query = include_str!("forecast_query.sql");
let forecasts = conn.prepare(forecast_query)?.query_map(...)?;
```

**Benefit**: Same logic, tested once, works everywhere!

### Pattern 2: Hybrid Pipeline

**Scenario**: R for analysis, Python for deployment

```r
# Analyst in R: Explore and select model
library(duckdb)
con <- dbConnect(duckdb::duckdb())
dbExecute(con, "LOAD 'anofox_forecast.duckdb_extension'")

# Try different models
ets_fc <- dbGetQuery(con, "SELECT * FROM TS_FORECAST(..., 'AutoETS', ...)")
arima_fc <- dbGetQuery(con, "SELECT * FROM TS_FORECAST(..., 'AutoARIMA', ...)")

# Decide: AutoETS is best
best_model <- "AutoETS"
```

```python
# Engineer in Python: Deploy chosen model
import duckdb
con = duckdb.connect()
con.execute("LOAD 'anofox_forecast.duckdb_extension'")

# Use model selected by analyst
forecast = con.execute(f"""
    SELECT * FROM TS_FORECAST_BY('sales', product_id, date, amount,
                                 'AutoETS', 28, {{'seasonal_period': 7}})
""").fetchdf()
```

**Benefit**: Domain experts choose, engineers deploy!

### Pattern 3: Microservices Architecture

**Service 1 (Python)**: Data preparation
```python
# Python service: Clean and prepare data
con.execute("""
    CREATE TABLE sales_prepared AS
    SELECT * FROM TS_FILL_GAPS('sales_raw', product_id, date, amount)
""")
con.execute("COPY sales_prepared TO 'prepared.parquet' (FORMAT PARQUET)")
```

**Service 2 (Rust)**: Low-latency forecasting
```rust
// Rust service: Fast forecasting endpoint
conn.execute_batch("CREATE TABLE sales_prepared AS SELECT * FROM read_parquet('prepared.parquet')")?;
let forecast = conn.prepare("SELECT * FROM TS_FORECAST_BY(...)")?;
```

**Service 3 (R)**: Reporting and visualization
```r
# R service: Generate reports
forecasts <- dbGetQuery(con, "SELECT * FROM read_parquet('forecasts.parquet')")
# Generate RMarkdown report
```

**Benefit**: Each service uses best language for the task!

---

## Performance Across Languages

### Benchmarks (1,000 series, 365 days, 28-day horizon)

| Language | Load Data | Forecast (AutoETS) | Total | Memory |
|----------|-----------|-------------------|-------|--------|
| **Python** | 2.1s | 38.5s | 40.6s | 850 MB |
| **R** | 2.3s | 38.2s | 40.5s | 920 MB |
| **Julia** | 1.8s | 38.1s | 39.9s | 780 MB |
| **C++** | 0.9s | 38.0s | 38.9s | 720 MB |
| **Rust** | 1.0s | 38.0s | 39.0s | 730 MB |

**Key Insight**: Forecasting time is nearly identical (DuckDB does the work)!

**Differences**:
- Data loading varies by language overhead
- Memory usage varies by runtime (GC vs manual)
- Julia/C++/Rust slightly more efficient
- **For forecasting itself: language choice doesn't matter much!**

### What Affects Performance

**Does NOT matter much**:
- ❌ Which language you call from
- ❌ DataFrame library (pandas vs polars vs Arrow)
- ❌ Whether you use types

**DOES matter**:
- ✅ Model choice (AutoETS vs SeasonalNaive vs AutoTBATS)
- ✅ Number of series (more = better parallelization)
- ✅ Data preparation (gaps, nulls, filtering)
- ✅ SQL query efficiency

---

## Code Reusability

### Shared SQL Queries

Create a `queries.sql` file:

<!-- include: test/sql/docs_examples/80_multi_language_overview_example_02.sql -->

**Use from any language**:

```python
# Python
with open('queries.sql') as f:
    query = f.read()
con.execute(query)
```

```r
# R
query <- readLines('queries.sql', warn=FALSE)
dbExecute(con, paste(query, collapse="\n"))
```

```julia
# Julia
query = read("queries.sql", String)
DBInterface.execute(conn, query)
```

```rust
// Rust
let query = include_str!("queries.sql");
conn.execute_batch(query)?;
```


## Example: Same Workflow, Different Languages

### Python Version

```python
import duckdb
con = duckdb.connect()
con.execute("LOAD 'anofox_forecast.duckdb_extension'")
con.execute("CREATE TABLE sales AS SELECT * FROM read_csv('sales.csv')")
stats = con.execute("SELECT * FROM TS_STATS('sales', product_id, date, amount)").fetchdf()
forecast = con.execute("SELECT * FROM TS_FORECAST_BY(...)").fetchdf()
forecast.to_csv('forecast.csv')
```

### R Version

```r
library(duckdb)
con <- dbConnect(duckdb::duckdb())
dbExecute(con, "LOAD 'anofox_forecast.duckdb_extension'")
dbExecute(con, "CREATE TABLE sales AS SELECT * FROM read_csv('sales.csv')")
stats <- dbGetQuery(con, "SELECT * FROM TS_STATS('sales', product_id, date, amount)")
forecast <- dbGetQuery(con, "SELECT * FROM TS_FORECAST_BY(...)")
write.csv(forecast, 'forecast.csv', row.names=FALSE)
```

### Julia Version

```julia
using DuckDB, DataFrames, CSV
con = DBInterface.connect(DuckDB.DB)
DBInterface.execute(con, "LOAD 'anofox_forecast.duckdb_extension'")
DBInterface.execute(con, "CREATE TABLE sales AS SELECT * FROM read_csv('sales.csv')")
stats = DataFrame(DBInterface.execute(con, "SELECT * FROM TS_STATS('sales', product_id, date, amount)"))
forecast = DataFrame(DBInterface.execute(con, "SELECT * FROM TS_FORECAST_BY(...)"))
CSV.write("forecast.csv", forecast)
```

### C++ Version

```cpp
#include "duckdb.hpp"
duckdb::DuckDB db(nullptr);
duckdb::Connection con(db);
con.Query("LOAD 'anofox_forecast.duckdb_extension'");
con.Query("CREATE TABLE sales AS SELECT * FROM read_csv('sales.csv')");
auto stats = con.Query("SELECT * FROM TS_STATS('sales', product_id, date, amount)");
auto forecast = con.Query("SELECT * FROM TS_FORECAST_BY(...)");
con.Query("COPY (SELECT * FROM forecast) TO 'forecast.csv'");
```

### Rust Version

```rust
use duckdb::Connection;
let conn = Connection::open_in_memory()?;
conn.execute_batch("LOAD 'anofox_forecast.duckdb_extension'")?;
conn.execute_batch("CREATE TABLE sales AS SELECT * FROM read_csv('sales.csv')")?;
let stats = conn.prepare("SELECT * FROM TS_STATS('sales', product_id, date, amount)")?.query([])?;
let forecast = conn.prepare("SELECT * FROM TS_FORECAST_BY(...)")?.query([])?;
conn.execute_batch("COPY (SELECT * FROM forecast) TO 'forecast.csv'")?;
```

**Notice**: The SQL is identical in all languages!

---


## Data Exchange Formats

### Parquet (Recommended)

**Universal format** - works across all languages:

```python
# Python: Create
forecast.to_parquet('forecast.parquet')
```

```r
# R: Read
library(arrow)
forecast <- read_parquet('forecast.parquet')
```

```julia
# Julia: Read
using Arrow
forecast = Arrow.Table("forecast.parquet") |> DataFrame
```

```cpp
// C++: Read via DuckDB
con.Query("SELECT * FROM read_parquet('forecast.parquet')")
```

### CSV (Simple)

Works everywhere but less efficient for large data.

### Arrow IPC (Fast)

For in-memory exchange between processes.

### DuckDB Database File (Best)

**Share the entire database**:

```python
# Python: Create
con = duckdb.connect('shared.duckdb')
con.execute("CREATE TABLE forecasts AS SELECT * FROM TS_FORECAST_BY(...)")
```

```rust
// Rust: Read
let conn = Connection::open("shared.duckdb")?;
// Table already exists!
```

**Benefit**: Zero data conversion, instant access!

---
