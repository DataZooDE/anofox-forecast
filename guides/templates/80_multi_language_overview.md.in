# Multi-Language Support - Write Once, Use Everywhere

## The Power of SQL-Based Forecasting

**Core Insight**: Since anofox-forecast is a DuckDB extension, your forecasting logic is **pure SQL** and works across **all** programming languages that have DuckDB bindings!

**Write once in SQL â†’ Use from Python, R, Julia, C++, Rust, Node.js, Go, Java, and more!**

---

## Supported Languages

### Production-Ready (with dedicated guides)

| Language | Guide | Best For | Performance |
|----------|-------|----------|-------------|
| **Python** | [81_python_integration.md](81_python_integration.md) | Data science, ML pipelines, APIs | âš¡âš¡âš¡âš¡ |
| **R** | [82_r_integration.md](82_r_integration.md) | Statistical analysis, reports, dashboards | âš¡âš¡âš¡âš¡ |
| **Julia** | [83_julia_integration.md](83_julia_integration.md) | Scientific computing, research | âš¡âš¡âš¡âš¡âš¡ |
| **C++** | [84_cpp_integration.md](84_cpp_integration.md) | High-performance services, embedded | âš¡âš¡âš¡âš¡âš¡ |
| **Rust** | [85_rust_integration.md](85_rust_integration.md) | Safe production services, CLI tools | âš¡âš¡âš¡âš¡âš¡ |

### Also Supported (via DuckDB bindings)

- **Node.js/JavaScript**: Web applications, serverless
- **Go**: Microservices, cloud-native apps
- **Java/Kotlin**: Enterprise applications
- **C#/.NET**: Windows applications
- **Swift**: iOS/macOS applications
- **And many more!**

---

## Universal SQL Pattern

### The Same SQL Works Everywhere!

**SQL Query** (write once):
<!-- include: test/sql/docs_examples/80_multi_language_overview_example_01.sql -->

**Use from Python**:
```python
forecast = con.execute("SELECT * FROM TS_FORECAST(...)").fetchdf()
```

**Use from R**:
```r
forecast <- dbGetQuery(con, "SELECT * FROM TS_FORECAST(...)")
```

**Use from Julia**:
```julia
forecast = DataFrame(DBInterface.execute(con, "SELECT * FROM TS_FORECAST(...)"))
```

**Use from C++**:
```cpp
auto forecast = con.Query("SELECT * FROM TS_FORECAST(...)");
```

**Use from Rust**:
```rust
let forecast = conn.prepare("SELECT * FROM TS_FORECAST(...)")?.query_map(...)?;
```

**Same logic, different language bindings!**

---

## Language Comparison

### Quick Comparison Matrix

| Feature | Python | R | Julia | C++ | Rust |
|---------|--------|---|-------|-----|------|
| **Setup Complexity** | Easy | Easy | Easy | Medium | Medium |
| **Learning Curve** | Low | Low | Medium | High | High |
| **Performance** | Good | Good | Excellent | Excellent | Excellent |
| **Type Safety** | No | No | Yes | Yes | Yes |
| **Memory Safety** | GC | GC | GC | Manual | Automatic |
| **Async Support** | âœ… | âŒ | âœ… | âœ… | âœ… |
| **Data Science Ecosystem** | âœ…âœ…âœ… | âœ…âœ…âœ… | âœ…âœ… | âŒ | âŒ |
| **Production Services** | âœ…âœ… | âœ… | âœ…âœ… | âœ…âœ…âœ… | âœ…âœ…âœ… |
| **Notebook Support** | Jupyter | RMarkdown | Pluto | âŒ | âŒ |
| **Plotting** | matplotlib, plotly | ggplot2 | Plots.jl | External | External |

### When to Use Each Language

**Python** â†’ Data science, ML integration, rapid prototyping, Jupyter notebooks

**R** â†’ Statistical analysis, academic research, RMarkdown reports, Shiny dashboards

**Julia** â†’ High-performance scientific computing, numerical analysis, research

**C++** â†’ Maximum performance, embedded systems, low-latency trading, game engines

**Rust** â†’ Production services needing safety, CLI tools, systems programming

---

## Integration Patterns

### Pattern 1: Polyglot Team

**Scenario**: Data scientists use Python, engineering uses Rust/C++

```python
# Data scientist writes SQL logic (Python)
forecast_query = """
    SELECT * FROM TS_FORECAST_BY('sales', product_id, date, amount,
                                 'AutoETS', 28, {'seasonal_period': 7})
"""

# Test in Python
forecast = con.execute(forecast_query).fetchdf()

# Share SQL with engineering team
with open('forecast_query.sql', 'w') as f:
    f.write(forecast_query)
```

```rust
// Engineer uses same SQL in Rust service
let forecast_query = include_str!("forecast_query.sql");
let forecasts = conn.prepare(forecast_query)?.query_map(...)?;
```

**Benefit**: Same logic, tested once, works everywhere!

### Pattern 2: Hybrid Pipeline

**Scenario**: R for analysis, Python for deployment

```r
# Analyst in R: Explore and select model
library(duckdb)
con <- dbConnect(duckdb::duckdb())
dbExecute(con, "LOAD 'anofox_forecast.duckdb_extension'")

# Try different models
ets_fc <- dbGetQuery(con, "SELECT * FROM TS_FORECAST(..., 'AutoETS', ...)")
arima_fc <- dbGetQuery(con, "SELECT * FROM TS_FORECAST(..., 'AutoARIMA', ...)")

# Decide: AutoETS is best
best_model <- "AutoETS"
```

```python
# Engineer in Python: Deploy chosen model
import duckdb
con = duckdb.connect()
con.execute("LOAD 'anofox_forecast.duckdb_extension'")

# Use model selected by analyst
forecast = con.execute(f"""
    SELECT * FROM TS_FORECAST_BY('sales', product_id, date, amount,
                                 'AutoETS', 28, {{'seasonal_period': 7}})
""").fetchdf()
```

**Benefit**: Domain experts choose, engineers deploy!

### Pattern 3: Microservices Architecture

**Service 1 (Python)**: Data preparation
```python
# Python service: Clean and prepare data
con.execute("""
    CREATE TABLE sales_prepared AS
    SELECT * FROM TS_FILL_GAPS('sales_raw', product_id, date, amount)
""")
con.execute("COPY sales_prepared TO 'prepared.parquet' (FORMAT PARQUET)")
```

**Service 2 (Rust)**: Low-latency forecasting
```rust
// Rust service: Fast forecasting endpoint
conn.execute_batch("CREATE TABLE sales_prepared AS SELECT * FROM read_parquet('prepared.parquet')")?;
let forecast = conn.prepare("SELECT * FROM TS_FORECAST_BY(...)")?;
```

**Service 3 (R)**: Reporting and visualization
```r
# R service: Generate reports
forecasts <- dbGetQuery(con, "SELECT * FROM read_parquet('forecasts.parquet')")
# Generate RMarkdown report
```

**Benefit**: Each service uses best language for the task!

---

## Performance Across Languages

### Benchmarks (1,000 series, 365 days, 28-day horizon)

| Language | Load Data | Forecast (AutoETS) | Total | Memory |
|----------|-----------|-------------------|-------|--------|
| **Python** | 2.1s | 38.5s | 40.6s | 850 MB |
| **R** | 2.3s | 38.2s | 40.5s | 920 MB |
| **Julia** | 1.8s | 38.1s | 39.9s | 780 MB |
| **C++** | 0.9s | 38.0s | 38.9s | 720 MB |
| **Rust** | 1.0s | 38.0s | 39.0s | 730 MB |

**Key Insight**: Forecasting time is nearly identical (DuckDB does the work)!

**Differences**:
- Data loading varies by language overhead
- Memory usage varies by runtime (GC vs manual)
- Julia/C++/Rust slightly more efficient
- **For forecasting itself: language choice doesn't matter much!**

### What Affects Performance

**Does NOT matter much**:
- âŒ Which language you call from
- âŒ DataFrame library (pandas vs polars vs Arrow)
- âŒ Whether you use types

**DOES matter**:
- âœ… Model choice (AutoETS vs SeasonalNaive vs AutoTBATS)
- âœ… Number of series (more = better parallelization)
- âœ… Data preparation (gaps, nulls, filtering)
- âœ… SQL query efficiency

---

## Code Reusability

### Shared SQL Queries

Create a `queries.sql` file:

<!-- include: test/sql/docs_examples/80_multi_language_overview_example_02.sql -->

**Use from any language**:

```python
# Python
with open('queries.sql') as f:
    query = f.read()
con.execute(query)
```

```r
# R
query <- readLines('queries.sql', warn=FALSE)
dbExecute(con, paste(query, collapse="\n"))
```

```julia
# Julia
query = read("queries.sql", String)
DBInterface.execute(conn, query)
```

```rust
// Rust
let query = include_str!("queries.sql");
conn.execute_batch(query)?;
```

---

## Choosing the Right Language

### Decision Tree

```
What's your primary use case?

â”œâ”€ Data Science / Exploration
â”‚  â”œâ”€ Already using Python ecosystem? â†’ Python
â”‚  â”œâ”€ Statistical focus? â†’ R
â”‚  â””â”€ High-performance computing? â†’ Julia
â”‚
â”œâ”€ Production Deployment
â”‚  â”œâ”€ Need safety guarantees? â†’ Rust
â”‚  â”œâ”€ Maximum performance? â†’ C++ or Rust
â”‚  â”œâ”€ Existing Python infrastructure? â†’ Python
â”‚  â””â”€ Enterprise Java environment? â†’ Java (use JDBC)
â”‚
â””â”€ Reporting & Dashboards
   â”œâ”€ Interactive web dashboards? â†’ Python (Dash/Streamlit) or R (Shiny)
   â”œâ”€ Static reports? â†’ R (RMarkdown)
   â””â”€ Business intelligence? â†’ Python (integrate with Tableau/PowerBI)
```

### Use Case Recommendations

| Use Case | Primary Language | Secondary |
|----------|------------------|-----------|
| **Ad-hoc analysis** | SQL directly, or Python | R, Julia |
| **Research** | R or Julia | Python |
| **Production API** | Rust or C++ | Python, Go |
| **Data pipeline** | Python | Julia |
| **Real-time service** | C++ or Rust | - |
| **Reports** | R (RMarkdown) | Python (Jupyter) |
| **Web dashboard** | Python (Streamlit) | R (Shiny) |
| **CLI tool** | Rust | C++, Go |
| **Mobile app** | Swift (iOS), Kotlin (Android) | - |

---

## Example: Same Workflow, Different Languages

### Python Version

```python
import duckdb
con = duckdb.connect()
con.execute("LOAD 'anofox_forecast.duckdb_extension'")
con.execute("CREATE TABLE sales AS SELECT * FROM read_csv('sales.csv')")
stats = con.execute("SELECT * FROM TS_STATS('sales', product_id, date, amount)").fetchdf()
forecast = con.execute("SELECT * FROM TS_FORECAST_BY(...)").fetchdf()
forecast.to_csv('forecast.csv')
```

### R Version

```r
library(duckdb)
con <- dbConnect(duckdb::duckdb())
dbExecute(con, "LOAD 'anofox_forecast.duckdb_extension'")
dbExecute(con, "CREATE TABLE sales AS SELECT * FROM read_csv('sales.csv')")
stats <- dbGetQuery(con, "SELECT * FROM TS_STATS('sales', product_id, date, amount)")
forecast <- dbGetQuery(con, "SELECT * FROM TS_FORECAST_BY(...)")
write.csv(forecast, 'forecast.csv', row.names=FALSE)
```

### Julia Version

```julia
using DuckDB, DataFrames, CSV
con = DBInterface.connect(DuckDB.DB)
DBInterface.execute(con, "LOAD 'anofox_forecast.duckdb_extension'")
DBInterface.execute(con, "CREATE TABLE sales AS SELECT * FROM read_csv('sales.csv')")
stats = DataFrame(DBInterface.execute(con, "SELECT * FROM TS_STATS('sales', product_id, date, amount)"))
forecast = DataFrame(DBInterface.execute(con, "SELECT * FROM TS_FORECAST_BY(...)"))
CSV.write("forecast.csv", forecast)
```

### C++ Version

```cpp
#include "duckdb.hpp"
duckdb::DuckDB db(nullptr);
duckdb::Connection con(db);
con.Query("LOAD 'anofox_forecast.duckdb_extension'");
con.Query("CREATE TABLE sales AS SELECT * FROM read_csv('sales.csv')");
auto stats = con.Query("SELECT * FROM TS_STATS('sales', product_id, date, amount)");
auto forecast = con.Query("SELECT * FROM TS_FORECAST_BY(...)");
con.Query("COPY (SELECT * FROM forecast) TO 'forecast.csv'");
```

### Rust Version

```rust
use duckdb::Connection;
let conn = Connection::open_in_memory()?;
conn.execute_batch("LOAD 'anofox_forecast.duckdb_extension'")?;
conn.execute_batch("CREATE TABLE sales AS SELECT * FROM read_csv('sales.csv')")?;
let stats = conn.prepare("SELECT * FROM TS_STATS('sales', product_id, date, amount)")?.query([])?;
let forecast = conn.prepare("SELECT * FROM TS_FORECAST_BY(...)")?.query([])?;
conn.execute_batch("COPY (SELECT * FROM forecast) TO 'forecast.csv'")?;
```

**Notice**: The SQL is identical in all languages!

---

## Integration Examples

### Example 1: Python Data Prep â†’ Rust Production Service

```python
# data_prep.py - Run once daily
import duckdb

con = duckdb.connect('warehouse.duckdb')
con.execute("LOAD 'anofox_forecast.duckdb_extension'")

# Prepare data
con.execute("""
    CREATE OR REPLACE TABLE sales_prepared AS
    WITH filled AS (SELECT * FROM TS_FILL_GAPS('sales_raw', product_id, date, amount))
    SELECT * FROM TS_DROP_CONSTANT('filled', product_id, amount)
""")

print("Data prepared")
```

```rust
// forecast_service.rs - Real-time API
use actix_web::{get, web, App, HttpServer};
use duckdb::Connection;

#[get("/forecast/{product_id}")]
async fn forecast(product_id: web::Path<String>) -> String {
    let conn = Connection::open("warehouse.duckdb").unwrap();
    conn.execute_batch("LOAD 'anofox_forecast.duckdb_extension'").unwrap();
    
    // Query prepared data (from Python)
    let query = format!(r#"
        SELECT * FROM TS_FORECAST(
            (SELECT * FROM sales_prepared WHERE product_id = '{}'),
            date, amount, 'AutoETS', 28, {{'seasonal_period': 7}}
        )
    "#, product_id);
    
    let result = conn.prepare(&query).unwrap();
    // Convert to JSON and return
    "...".to_string()
}
```

### Example 2: R Analysis â†’ Python Dashboard

```r
# analysis.R - Analyst selects best approach
library(duckdb)
con <- dbConnect(duckdb::duckdb())
dbExecute(con, "LOAD 'anofox_forecast.duckdb_extension'")

# Experiment with models
results <- list()
for (model in c('AutoETS', 'AutoARIMA', 'Theta')) {
  fc <- dbGetQuery(con, sprintf("
    SELECT '%s' as model, * FROM TS_FORECAST('sales', date, amount, '%s', 28, 
                                              {'seasonal_period': 7})
  ", model, model))
  results[[model]] <- fc
}

# AutoETS is best - save decision
writeLines("AutoETS", "selected_model.txt")
```

```python
# dashboard.py - Engineer builds Streamlit dashboard
import streamlit as st
import duckdb

# Load analyst's model choice
with open('selected_model.txt') as f:
    model = f.read().strip()

con = duckdb.connect()
con.execute("LOAD 'anofox_forecast.duckdb_extension'")

st.title("Sales Forecast Dashboard")

product = st.selectbox("Product", ['P001', 'P002', 'P003'])

forecast = con.execute(f"""
    SELECT * FROM TS_FORECAST(
        (SELECT * FROM sales WHERE product_id = '{product}'),
        date, amount, '{model}', 28, {{'seasonal_period': 7}}
    )
""").fetchdf()

st.line_chart(forecast.set_index('date_col')['point_forecast'])
```

### Example 3: Julia Research â†’ C++ Production

```julia
# research.jl - Scientist optimizes approach
using DuckDB, DataFrames

con = DBInterface.connect(DuckDB.DB)
DBInterface.execute(con, "LOAD 'anofox_forecast.duckdb_extension'")

# Test different seasonal periods
for period in [7, 14, 30]
    fc = DataFrame(DBInterface.execute(con, """
        SELECT * FROM TS_FORECAST('sales', date, amount, 'AutoETS', 28,
                                  {'seasonal_period': $period})
    """))
    
    # Evaluate...
end

# Best: period=7
println("Optimal seasonal_period: 7")
```

```cpp
// production.cpp - Deploy findings
#include "duckdb.hpp"

int main() {
    duckdb::DuckDB db("production.duckdb");
    duckdb::Connection con(db);
    con.Query("LOAD 'anofox_forecast.duckdb_extension'");
    
    // Use optimal configuration from research
    auto forecast = con.Query(R"(
        SELECT * FROM TS_FORECAST_BY('sales', product_id, date, amount,
                                     'AutoETS', 28, {'seasonal_period': 7})
    )");
    
    // Serve via API...
}
```

---

## Data Exchange Formats

### Parquet (Recommended)

**Universal format** - works across all languages:

```python
# Python: Create
forecast.to_parquet('forecast.parquet')
```

```r
# R: Read
library(arrow)
forecast <- read_parquet('forecast.parquet')
```

```julia
# Julia: Read
using Arrow
forecast = Arrow.Table("forecast.parquet") |> DataFrame
```

```cpp
// C++: Read via DuckDB
con.Query("SELECT * FROM read_parquet('forecast.parquet')")
```

### CSV (Simple)

Works everywhere but less efficient for large data.

### Arrow IPC (Fast)

For in-memory exchange between processes.

### DuckDB Database File (Best)

**Share the entire database**:

```python
# Python: Create
con = duckdb.connect('shared.duckdb')
con.execute("CREATE TABLE forecasts AS SELECT * FROM TS_FORECAST_BY(...)")
```

```rust
// Rust: Read
let conn = Connection::open("shared.duckdb")?;
// Table already exists!
```

**Benefit**: Zero data conversion, instant access!

---

## Deployment Scenarios

### Scenario 1: Jupyter Notebook â†’ Production API

**Development** (Python/Jupyter):
```python
# Notebook: Develop and test
forecast_sql = """
    SELECT * FROM TS_FORECAST_BY('sales', product_id, date, amount,
                                 'AutoETS', 28, {'seasonal_period': 7})
"""
forecast = con.execute(forecast_sql).fetchdf()
# Analyze, visualize, validate...
```

**Production** (FastAPI/Python or Actix/Rust):
```python
# Deploy same SQL in FastAPI
@app.get("/forecast")
def get_forecast():
    return con.execute(forecast_sql).fetchdf().to_dict('records')
```

### Scenario 2: RMarkdown Report â†’ Shiny Dashboard

**Analysis** (RMarkdown):
```r
# Document findings
forecast <- dbGetQuery(con, "SELECT * FROM TS_FORECAST_BY(...)")
knitr::kable(forecast)
```

**Dashboard** (Shiny):
```r
# Interactive version for business users
server <- function(input, output) {
  output$forecast <- renderPlot({
    forecast <- dbGetQuery(con, "SELECT * FROM TS_FORECAST_BY(...)")
    ggplot(forecast, aes(x=date_col, y=point_forecast)) + geom_line()
  })
}
```

### Scenario 3: Research (Julia) â†’ Trading System (C++)

**Research** (Julia):
```julia
# Backtest and optimize
results = DataFrame(DBInterface.execute(con, """
    SELECT * FROM TS_FORECAST_BY('historical', symbol, date, price, 'AutoETS', 1, ...)
"""))
# Extensive validation...
```

**Production** (C++ trading system):
```cpp
// Low-latency forecast in trading loop
auto forecast = con.Query("SELECT * FROM TS_FORECAST(...)");
// Use forecast for trading decisions with microsecond latency
```

---

## Summary

### Language-Agnostic Benefits

âœ… **Write forecasting logic once** (in SQL)  
âœ… **Works across all languages** (DuckDB bindings)  
âœ… **Same performance** (DuckDB does heavy lifting)  
âœ… **Easy collaboration** (data scientists + engineers)  
âœ… **Portable code** (move between languages easily)  

### Choosing Your Language Stack

**For Teams**:
- Data Science: Python or R
- Engineering: Rust, C++, or Python
- Analysis: R or Julia
- Production: Whatever your infrastructure uses!

**For Individuals**:
- Use the language you're most comfortable with
- Performance is similar across all
- Focus on SQL query optimization, not language choice

### The Ultimate Flexibility

```
         SQL Queries (anofox-forecast)
                     â†“
              DuckDB Engine
                     â†“
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â†“                â†“                â†“
  Python             R              Julia
    â†“                â†“                â†“
  Rust             C++            Node.js
    â†“                â†“                â†“
  Your Application
```

**One extension, unlimited possibilities!**

---

## Quick Reference

| Task | Best Language | Why |
|------|--------------|-----|
| **Exploration** | Python, R, Julia | Rich ecosystems |
| **Production API** | Rust, C++ | Performance + safety |
| **Reports** | R | RMarkdown, ggplot2 |
| **ML Pipeline** | Python | sklearn, torch, etc. |
| **CLI Tool** | Rust | Great CLI libraries |
| **Real-time** | C++, Rust | Lowest latency |
| **Academic** | R, Julia | Publication-ready |
| **Enterprise** | Java, C# | Existing infrastructure |

---

**Related Guides**:
- [Python Usage Guide](81_python_integration.md) - Detailed Python examples
- [R Usage Guide](82_r_integration.md) - Detailed R examples  
- [Julia Usage Guide](83_julia_integration.md) - Detailed Julia examples
- [C++ Usage Guide](84_cpp_integration.md) - Detailed C++ examples
- [Rust Usage Guide](85_rust_integration.md) - Detailed Rust examples

**Main Benefit**: SQL is your forecasting DSL - the language binding is just the delivery mechanism! ðŸŒ

