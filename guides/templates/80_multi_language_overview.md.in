# Multi-Language Support - Write Once, Use Everywhere

## Introduction

The anofox-forecast extension is implemented as a DuckDB extension, which means all forecasting operations are executed as SQL queries. This architecture enables the same forecasting logic to work seamlessly across all programming languages that support DuckDB bindings.

**Key Capabilities**:
- Write forecasting logic once in SQL, use from any language
- Native DuckDB performance regardless of calling language
- Portable SQL queries that work identically across languages
- Support for Python, R, Julia, C++, Rust, Node.js, Go, Java, and more
- Zero language-specific forecasting library dependencies

---

## Table of Contents

1. [Supported Languages](#supported-languages)
   - [Production-Ready Languages](#production-ready-with-dedicated-guides)
   - [Additional Supported Languages](#also-supported-via-duckdb-bindings)
2. [Universal SQL Pattern](#universal-sql-pattern)
   - [The Same SQL Works Everywhere](#the-same-sql-works-everywhere)
3. [Language Comparison](#language-comparison)
   - [Quick Comparison Matrix](#quick-comparison-matrix)
   - [When to Use Each Language](#when-to-use-each-language)
4. [Integration Patterns](#integration-patterns)
   - [Polyglot Team Pattern](#pattern-1-polyglot-team)
   - [Hybrid Pipeline Pattern](#pattern-2-hybrid-pipeline)
   - [Microservices Architecture Pattern](#pattern-3-microservices-architecture)
5. [Performance Across Languages](#performance-across-languages)
   - [What Affects Performance](#what-affects-performance)
6. [Code Reusability](#code-reusability)
   - [Shared SQL Queries](#shared-sql-queries)
7. [Example: Same Workflow, Different Languages](#example-same-workflow-different-languages)
8. [Data Exchange Formats](#data-exchange-formats)
   - [Parquet Format](#parquet)
   - [CSV Format](#csv)
   - [Arrow IPC Format](#arrow-ipc)
   - [DuckDB Database File](#duckdb-database-file)

---

## Supported Languages

### Production-Ready (with dedicated guides)

| Language | Guide | Best For | Performance |
|----------|-------|----------|-------------|
| **Python** | [81_python_integration.md](81_python_integration.md) | Data science, ML pipelines, APIs | ⚡⚡⚡⚡ |
| **R** | [82_r_integration.md](82_r_integration.md) | Statistical analysis, reports, dashboards | ⚡⚡⚡⚡ |
| **Julia** | [83_julia_integration.md](83_julia_integration.md) | Scientific computing, research | ⚡⚡⚡⚡⚡ |
| **C++** | [84_cpp_integration.md](84_cpp_integration.md) | High-performance services, embedded | ⚡⚡⚡⚡⚡ |
| **Rust** | [85_rust_integration.md](85_rust_integration.md) | Safe production services, CLI tools | ⚡⚡⚡⚡⚡ |

### Also Supported (via DuckDB bindings)

- **Node.js/JavaScript**: Web applications, serverless
- **Go**: Microservices, cloud-native apps
- **Java/Kotlin**: Enterprise applications
- **C#/.NET**: Windows applications
- **Swift**: iOS/macOS applications
- **And many more!**

[↑ Go to top](#multi-language-support-write-once-use-everywhere)

---

## Universal SQL Pattern

### The Same SQL Works Everywhere!

**SQL Query** (write once):
<!-- include: test/sql/docs_examples/80_multi_language_overview_example_01.sql -->

**Use from Python**:
```python
forecast = con.execute("SELECT * FROM anofox_fcst_ts_forecast(...)").fetchdf()
```

**Use from R**:
```r
forecast <- dbGetQuery(con, "SELECT * FROM anofox_fcst_ts_forecast(...)")
```

**Use from Julia**:
```julia
forecast = DataFrame(DBInterface.execute(con, "SELECT * FROM anofox_fcst_ts_forecast(...)"))
```

**Use from C++**:
```cpp
auto forecast = con.Query("SELECT * FROM anofox_fcst_ts_forecast(...)");
```

**Use from Rust**:
```rust
let forecast = conn.prepare("SELECT * FROM anofox_fcst_ts_forecast(...)")?.query_map(...)?;
```

**Same logic, different language bindings!**

[↑ Go to top](#multi-language-support-write-once-use-everywhere)

---

## Language Comparison

### Quick Comparison Matrix

| Feature | Python | R | Julia | C++ | Rust |
|---------|--------|---|-------|-----|------|
| **Setup Complexity** | Easy | Easy | Easy | Medium | Medium |
| **Learning Curve** | Low | Low | Medium | High | High |
| **Performance** | Good | Good | Excellent | Excellent | Excellent |
| **Type Safety** | No | No | Yes | Yes | Yes |
| **Memory Safety** | GC | GC | GC | Manual | Automatic |
| **Async Support** | ✅ | ❌ | ✅ | ✅ | ✅ |
| **Data Science Ecosystem** | ✅✅✅ | ✅✅✅ | ✅✅ | ❌ | ❌ |
| **Production Services** | ✅✅ | ✅ | ✅✅ | ✅✅✅ | ✅✅✅ |
| **Notebook Support** | Jupyter | RMarkdown | Pluto | ❌ | ❌ |
| **Plotting** | matplotlib, plotly | ggplot2 | Plots.jl | External | External |

### When to Use Each Language

**Python** → Data science, ML integration, rapid prototyping, Jupyter notebooks

**R** → Statistical analysis, academic research, RMarkdown reports, Shiny dashboards

**Julia** → High-performance scientific computing, numerical analysis, research

**C++** → Maximum performance, embedded systems, low-latency trading, game engines

**Rust** → Production services needing safety, CLI tools, systems programming

[↑ Go to top](#multi-language-support-write-once-use-everywhere)

---

## Integration Patterns

### Pattern 1: Polyglot Team

**Scenario**: Data scientists use Python, engineering uses Rust/C++

```python
# Data scientist writes SQL logic (Python)
forecast_query = """
    SELECT * FROM anofox_fcst_ts_forecast_by('sales', product_id, date, amount,
                                 'AutoETS', 28, {'seasonal_period': 7})
"""

# Test in Python
forecast = con.execute(forecast_query).fetchdf()

# Share SQL with engineering team
with open('forecast_query.sql', 'w') as f:
    f.write(forecast_query)
```

```rust
// Engineer uses same SQL in Rust service
let forecast_query = include_str!("forecast_query.sql");
let forecasts = conn.prepare(forecast_query)?.query_map(...)?;
```

**Benefit**: Same logic, tested once, works everywhere!

### Pattern 2: Hybrid Pipeline

**Scenario**: R for analysis, Python for deployment

```r
# Analyst in R: Explore and select model
library(duckdb)
con <- dbConnect(duckdb::duckdb())
dbExecute(con, "LOAD 'anofox_forecast.duckdb_extension'")

# Try different models
ets_fc <- dbGetQuery(con, "SELECT * FROM anofox_fcst_ts_forecast(..., 'AutoETS', ...)")
arima_fc <- dbGetQuery(con, "SELECT * FROM anofox_fcst_ts_forecast(..., 'AutoARIMA', ...)")

# Decide: AutoETS is best
best_model <- "AutoETS"
```

```python
# Engineer in Python: Deploy chosen model
import duckdb
con = duckdb.connect()
con.execute("LOAD 'anofox_forecast.duckdb_extension'")

# Use model selected by analyst
forecast = con.execute(f"""
    SELECT * FROM anofox_fcst_ts_forecast_by('sales', product_id, date, amount,
                                 'AutoETS', 28, {{'seasonal_period': 7}})
""").fetchdf()
```

**Benefit**: Domain experts choose, engineers deploy!

### Pattern 3: Microservices Architecture

**Service 1 (Python)**: Data preparation
```python
# Python service: Clean and prepare data
con.execute("""
    CREATE TABLE sales_prepared AS
    SELECT * FROM anofox_fcst_ts_fill_gaps('sales_raw', product_id, date, amount)
""")
con.execute("COPY sales_prepared TO 'prepared.parquet' (FORMAT PARQUET)")
```

**Service 2 (Rust)**: Low-latency forecasting
```rust
// Rust service: Fast forecasting endpoint
conn.execute_batch("CREATE TABLE sales_prepared AS SELECT * FROM read_parquet('prepared.parquet')")?;
let forecast = conn.prepare("SELECT * FROM anofox_fcst_ts_forecast_by(...)")?;
```

**Service 3 (R)**: Reporting and visualization
```r
# R service: Generate reports
forecasts <- dbGetQuery(con, "SELECT * FROM read_parquet('forecasts.parquet')")
# Generate RMarkdown report
```

**Benefit**: Each service uses best language for the task!

[↑ Go to top](#multi-language-support-write-once-use-everywhere)

---

## Performance Across Languages

### What Affects Performance

**Does NOT matter much**:
- ❌ Which language you call from
- ❌ DataFrame library (pandas vs polars vs Arrow)
- ❌ Whether you use types

**DOES matter**:
- ✅ Model choice (AutoETS vs SeasonalNaive vs AutoTBATS)
- ✅ Number of series (more = better parallelization)
- ✅ Data preparation (gaps, nulls, filtering)
- ✅ SQL query efficiency

[↑ Go to top](#multi-language-support-write-once-use-everywhere)

---

## Code Reusability

### Shared SQL Queries

Create a `queries.sql` file:

<!-- include: test/sql/docs_examples/80_multi_language_overview_example_02.sql -->

**Use from any language**:

```python
# Python
with open('queries.sql') as f:
    query = f.read()
con.execute(query)
```

```r
# R
query <- readLines('queries.sql', warn=FALSE)
dbExecute(con, paste(query, collapse="\n"))
```

```julia
# Julia
query = read("queries.sql", String)
DBInterface.execute(conn, query)
```

```rust
// Rust
let query = include_str!("queries.sql");
conn.execute_batch(query)?;
```

[↑ Go to top](#multi-language-support-write-once-use-everywhere)

---

## Example: Same Workflow, Different Languages

### Python Version

```python
import duckdb
con = duckdb.connect()
con.execute("LOAD 'anofox_forecast.duckdb_extension'")
con.execute("CREATE TABLE sales AS SELECT * FROM read_csv('sales.csv')")
stats = con.execute("SELECT * FROM anofox_fcst_ts_stats('sales', product_id, date, amount)").fetchdf()
forecast = con.execute("SELECT * FROM anofox_fcst_ts_forecast_by(...)").fetchdf()
forecast.to_csv('forecast.csv')
```

### R Version

```r
library(duckdb)
con <- dbConnect(duckdb::duckdb())
dbExecute(con, "LOAD 'anofox_forecast.duckdb_extension'")
dbExecute(con, "CREATE TABLE sales AS SELECT * FROM read_csv('sales.csv')")
stats <- dbGetQuery(con, "SELECT * FROM anofox_fcst_ts_stats('sales', product_id, date, amount)")
forecast <- dbGetQuery(con, "SELECT * FROM anofox_fcst_ts_forecast_by(...)")
write.csv(forecast, 'forecast.csv', row.names=FALSE)
```

### Julia Version

```julia
using DuckDB, DataFrames, CSV
con = DBInterface.connect(DuckDB.DB)
DBInterface.execute(con, "LOAD 'anofox_forecast.duckdb_extension'")
DBInterface.execute(con, "CREATE TABLE sales AS SELECT * FROM read_csv('sales.csv')")
stats = DataFrame(DBInterface.execute(con, "SELECT * FROM anofox_fcst_ts_stats('sales', product_id, date, amount)"))
forecast = DataFrame(DBInterface.execute(con, "SELECT * FROM anofox_fcst_ts_forecast_by(...)"))
CSV.write("forecast.csv", forecast)
```

### C++ Version

```cpp
#include "duckdb.hpp"
duckdb::DuckDB db(nullptr);
duckdb::Connection con(db);
con.Query("LOAD 'anofox_forecast.duckdb_extension'");
con.Query("CREATE TABLE sales AS SELECT * FROM read_csv('sales.csv')");
auto stats = con.Query("SELECT * FROM anofox_fcst_ts_stats('sales', product_id, date, amount)");
auto forecast = con.Query("SELECT * FROM anofox_fcst_ts_forecast_by(...)");
con.Query("COPY (SELECT * FROM forecast) TO 'forecast.csv'");
```

### Rust Version

```rust
use duckdb::Connection;
let conn = Connection::open_in_memory()?;
conn.execute_batch("LOAD 'anofox_forecast.duckdb_extension'")?;
conn.execute_batch("CREATE TABLE sales AS SELECT * FROM read_csv('sales.csv')")?;
let stats = conn.prepare("SELECT * FROM anofox_fcst_ts_stats('sales', product_id, date, amount)")?.query([])?;
let forecast = conn.prepare("SELECT * FROM anofox_fcst_ts_forecast_by(...)")?.query([])?;
conn.execute_batch("COPY (SELECT * FROM forecast) TO 'forecast.csv'")?;
```

**Notice**: The SQL is identical in all languages!

[↑ Go to top](#multi-language-support-write-once-use-everywhere)

---

## Data Exchange Formats

### Parquet

**Universal format** - works across all languages:

```python
# Python: Create
forecast.to_parquet('forecast.parquet')
```

```r
# R: Read
library(arrow)
forecast <- read_parquet('forecast.parquet')
```

```julia
# Julia: Read
using Arrow
forecast = Arrow.Table("forecast.parquet") |> DataFrame
```

```cpp
// C++: Read via DuckDB
con.Query("SELECT * FROM read_parquet('forecast.parquet')")
```

### CSV

Works everywhere but less efficient for large data.

### Arrow IPC

For in-memory exchange between processes.

### DuckDB Database File

**Share the entire database**:

```python
# Python: Create
con = duckdb.connect('shared.duckdb')
con.execute("CREATE TABLE forecasts AS SELECT * FROM anofox_fcst_ts_forecast_by(...)")
```

```rust
// Rust: Read
let conn = Connection::open("shared.duckdb")?;
// Table already exists!
```

**Benefit**: Zero data conversion, instant access!

[↑ Go to top](#multi-language-support-write-once-use-everywhere)

---
