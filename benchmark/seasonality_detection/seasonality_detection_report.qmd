---
title: "Seasonality Detection Methods: A Comparative Study"
subtitle: "Comprehensive Benchmark for the anofox-forecast DuckDB Extension"
author: "anofox-forecast benchmark suite"
date: today
format:
  html:
    code-fold: true
    toc: true
    toc-depth: 3
    theme: cosmo
    fig-width: 10
    fig-height: 6
  pdf:
    toc: true
    toc-depth: 3
    colorlinks: true
    fig-width: 7
    fig-height: 5
execute:
  echo: false
  warning: false
  message: false
---

## Executive Summary

This benchmark evaluates all seasonality detection methods available in the `anofox-forecast` DuckDB extension. Using simulated time series with known characteristics, we compare detection accuracy across seven scenarios using twelve detection methods spanning spectral analysis, autocorrelation, decomposition, and model-based approaches.

```{r}
#| label: setup
#| cache: false

library(DBI)
library(duckdb)
library(ggplot2)
library(dplyr)
library(tidyr)
library(purrr)
library(knitr)
library(scales)

# Set ggplot theme
theme_set(theme_minimal(base_size = 12))

# Define consistent colors for all methods (12 total)
METHOD_COLORS <- c(
  "Basic" = "#E41A1C",
  "Analysis" = "#377EB8",
  "FFT" = "#4DAF4A",
  "ACF" = "#984EA3",
  "Autoperiod" = "#FF7F00",
  "CFD" = "#FFFF33",
  "Lomb" = "#A65628",
  "AIC" = "#F781BF",
  "SSA" = "#999999",
  "STL" = "#66C2A5",
  "MatrixProfile" = "#FC8D62",
  "SAZED" = "#8DA0CB"
)
```

## Introduction

The `anofox-forecast` DuckDB extension provides SQL functions for detecting and analyzing seasonality in time series data. This report serves as both a benchmark and a tutorial, demonstrating how to use these functions effectively.

### Detection Methods Available

| Method | SQL Function | Description |
|--------|-------------|-------------|
| Basic Detection | `ts_detect_seasonality(values)` | Returns array of detected periods |
| Full Analysis | `ts_analyze_seasonality(values)` | Comprehensive struct with periods and strength metrics |
| FFT Period | `ts_estimate_period_fft(values)` | Period estimation via Fast Fourier Transform |
| ACF Period | `ts_estimate_period_acf(values)` | Period estimation via Autocorrelation |
| Autoperiod | `ts_autoperiod(values)` | Hybrid FFT+ACF validation method |
| CFD-Autoperiod | `ts_cfd_autoperiod(values)` | Circular Frequency Domain variant |
| Lomb-Scargle | `ts_lomb_scargle(values)` | Spectral analysis for irregular sampling |
| AIC Comparison | `ts_aic_period(values)` | Model selection via AIC/BIC criteria |
| SSA Period | `ts_ssa_period(values)` | Singular Spectrum Analysis decomposition |
| STL Period | `ts_stl_period(values)` | STL decomposition with seasonal strength optimization |
| Matrix Profile | `ts_matrix_profile_period(values)` | Motif-based period detection via matrix profile |
| SAZED | `ts_sazed_period(values)` | Spectral Analysis with Zero-padding for Enhanced Detection |

### Simulation Scenarios

We test across seven scenarios representing common real-world patterns:

1. **Strong Seasonal** - Clear sinusoidal pattern (high SNR)
2. **Weak Seasonal** - Low amplitude with high noise
3. **No Seasonal** - Pure noise (null case)
4. **Trending Seasonal** - Seasonality with strong linear trend
5. **Variable Amplitude** - Time-varying amplitude modulation
6. **Emerging Seasonal** - Seasonality appears mid-series
7. **Fading Seasonal** - Seasonality disappears mid-series

## Setup

### Connect to DuckDB and Load Extension

```{r}
#| label: connect-duckdb
#| cache: false

# Create DuckDB connection with allow_unsigned_extensions enabled
con <- dbConnect(duckdb(config = list("allow_unsigned_extensions" = "true")))

# Load the anofox-forecast extension
extension_path <- "../../build/release/extension/anofox_forecast/anofox_forecast.duckdb_extension"

if (file.exists(extension_path)) {
  dbExecute(con, sprintf("LOAD '%s'", extension_path))
  message("Extension loaded successfully!")
} else {
  warning("Extension not found at: ", extension_path,
          "\nPlease build the extension first with 'make' in the project root.")
}
```

## Data Simulation

We generate synthetic time series in R with known seasonality characteristics, then load them into DuckDB for analysis.

### Simulation Parameters

```{r}
#| label: simulation-params

# Simulation configuration
N_SERIES <- 100      # Series per scenario
N_POINTS <- 120      # Length of each series
PERIOD <- 12.0       # True seasonal period
NOISE_SD <- 1.0      # Base noise standard deviation
SEED <- 42           # Random seed for reproducibility

set.seed(SEED)
```

### Simulation Functions

```{r}
#| label: simulation-functions

# Generate sinusoidal seasonal component
generate_seasonal <- function(n, period, amplitude, phase = 0) {
  t <- 0:(n - 1)
  amplitude * sin(2 * pi * t / period + phase)
}

# Generate linear trend
generate_trend <- function(n, slope, intercept = 0) {
  t <- 0:(n - 1)
  intercept + slope * t
}

# Generate white noise
generate_noise <- function(n, sd) {
  rnorm(n, mean = 0, sd = sd)
}

# Calculate true seasonal strength (signal-to-noise ratio based)
calc_strength <- function(amplitude, noise_sd) {
  amplitude^2 / (amplitude^2 + noise_sd^2)
}

# Scenario 1: Strong, stable seasonality
generate_strong_seasonal <- function(n_series, n_points, period, noise_sd) {
  map_dfr(1:n_series, function(i) {
    amplitude <- runif(1, 3.0, 5.0)
    phase <- runif(1, 0, 2 * pi)

    seasonal <- generate_seasonal(n_points, period, amplitude, phase)
    trend <- generate_trend(n_points, slope = 0, intercept = 10)
    noise <- generate_noise(n_points, noise_sd)

    tibble(
      series_id = i,
      scenario = "strong_seasonal",
      true_period = period,
      true_strength = calc_strength(amplitude, noise_sd),
      is_seasonal = TRUE,
      values = list(trend + seasonal + noise)
    )
  })
}

# Scenario 2: Weak seasonality
generate_weak_seasonal <- function(n_series, n_points, period, noise_sd) {
  map_dfr(1:n_series, function(i) {
    amplitude <- runif(1, 0.3, 0.7)
    phase <- runif(1, 0, 2 * pi)
    high_noise <- noise_sd * 2.0

    seasonal <- generate_seasonal(n_points, period, amplitude, phase)
    trend <- generate_trend(n_points, slope = 0, intercept = 10)
    noise <- generate_noise(n_points, high_noise)

    tibble(
      series_id = i,
      scenario = "weak_seasonal",
      true_period = period,
      true_strength = calc_strength(amplitude, high_noise),
      is_seasonal = TRUE,
      values = list(trend + seasonal + noise)
    )
  })
}

# Scenario 3: No seasonality (null case)
generate_no_seasonal <- function(n_series, n_points, period, noise_sd) {
  map_dfr(1:n_series, function(i) {
    trend <- generate_trend(n_points, slope = 0, intercept = 10)
    noise <- generate_noise(n_points, noise_sd)

    tibble(
      series_id = i,
      scenario = "no_seasonal",
      true_period = 0,
      true_strength = 0,
      is_seasonal = FALSE,
      values = list(trend + noise)
    )
  })
}

# Scenario 4: Trending seasonal
generate_trending_seasonal <- function(n_series, n_points, period, noise_sd) {
  map_dfr(1:n_series, function(i) {
    amplitude <- runif(1, 2.0, 4.0)
    phase <- runif(1, 0, 2 * pi)
    strong_slope <- runif(1, 0.3, 0.5)

    seasonal <- generate_seasonal(n_points, period, amplitude, phase)
    trend <- generate_trend(n_points, slope = strong_slope, intercept = 10)
    noise <- generate_noise(n_points, noise_sd)

    tibble(
      series_id = i,
      scenario = "trending_seasonal",
      true_period = period,
      true_strength = calc_strength(amplitude, noise_sd),
      is_seasonal = TRUE,
      values = list(trend + seasonal + noise)
    )
  })
}

# Scenario 5: Variable amplitude (amplitude modulation)
generate_variable_amplitude <- function(n_series, n_points, period, noise_sd) {
  map_dfr(1:n_series, function(i) {
    base_amplitude <- runif(1, 2.0, 4.0)
    phase <- runif(1, 0, 2 * pi)

    t <- 0:(n_points - 1)
    amplitude_mod <- base_amplitude * (1 + 0.5 * sin(2 * pi * t / (n_points / 2)))
    seasonal <- amplitude_mod * sin(2 * pi * t / period + phase)

    trend <- generate_trend(n_points, slope = 0, intercept = 10)
    noise <- generate_noise(n_points, noise_sd)

    tibble(
      series_id = i,
      scenario = "variable_amplitude",
      true_period = period,
      true_strength = calc_strength(base_amplitude, noise_sd),
      is_seasonal = TRUE,
      values = list(trend + seasonal + noise)
    )
  })
}

# Scenario 6: Emerging seasonality
generate_emerging_seasonal <- function(n_series, n_points, period, noise_sd) {
  map_dfr(1:n_series, function(i) {
    amplitude <- runif(1, 3.0, 5.0)
    phase <- runif(1, 0, 2 * pi)

    t <- 0:(n_points - 1)
    midpoint <- n_points / 2
    transition_width <- n_points / 10

    transition <- 1 / (1 + exp(-(t - midpoint) / transition_width))
    seasonal <- amplitude * transition * sin(2 * pi * t / period + phase)

    trend <- generate_trend(n_points, slope = 0, intercept = 10)
    noise <- generate_noise(n_points, noise_sd)

    tibble(
      series_id = i,
      scenario = "emerging_seasonal",
      true_period = period,
      true_strength = calc_strength(amplitude, noise_sd),
      is_seasonal = TRUE,
      values = list(trend + seasonal + noise)
    )
  })
}

# Scenario 7: Fading seasonality
generate_fading_seasonal <- function(n_series, n_points, period, noise_sd) {
  map_dfr(1:n_series, function(i) {
    amplitude <- runif(1, 3.0, 5.0)
    phase <- runif(1, 0, 2 * pi)

    t <- 0:(n_points - 1)
    midpoint <- n_points / 2
    transition_width <- n_points / 10

    transition <- 1 - 1 / (1 + exp(-(t - midpoint) / transition_width))
    seasonal <- amplitude * transition * sin(2 * pi * t / period + phase)

    trend <- generate_trend(n_points, slope = 0, intercept = 10)
    noise <- generate_noise(n_points, noise_sd)

    tibble(
      series_id = i,
      scenario = "fading_seasonal",
      true_period = period,
      true_strength = calc_strength(amplitude, noise_sd),
      is_seasonal = TRUE,
      values = list(trend + seasonal + noise)
    )
  })
}
```

### Generate All Scenarios

```{r}
#| label: generate-data
#| cache: true

message("Generating simulated time series...")

all_series <- bind_rows(
  generate_strong_seasonal(N_SERIES, N_POINTS, PERIOD, NOISE_SD),
  generate_weak_seasonal(N_SERIES, N_POINTS, PERIOD, NOISE_SD),
  generate_no_seasonal(N_SERIES, N_POINTS, PERIOD, NOISE_SD),
  generate_trending_seasonal(N_SERIES, N_POINTS, PERIOD, NOISE_SD),
  generate_variable_amplitude(N_SERIES, N_POINTS, PERIOD, NOISE_SD),
  generate_emerging_seasonal(N_SERIES, N_POINTS, PERIOD, NOISE_SD),
  generate_fading_seasonal(N_SERIES, N_POINTS, PERIOD, NOISE_SD)
) %>%
  mutate(
    global_id = row_number(),
    scenario = factor(scenario, levels = c(
      "strong_seasonal", "weak_seasonal", "no_seasonal",
      "trending_seasonal", "variable_amplitude",
      "emerging_seasonal", "fading_seasonal"
    ))
  )

cat(sprintf("Total series generated: %d\n", nrow(all_series)))
cat("\nSeries per scenario:\n")
print(table(all_series$scenario))
```

### Example Series Visualization

```{r}
#| label: fig-example-series
#| fig-cap: "Example time series from each scenario"
#| fig-height: 10

examples <- all_series %>%
  group_by(scenario) %>%
  slice(1) %>%
  ungroup() %>%
  mutate(
    time = map(values, ~ 1:length(.x)),
    scenario_label = gsub("_", " ", scenario) %>% tools::toTitleCase()
  ) %>%
  unnest(c(time, values))

ggplot(examples, aes(x = time, y = values)) +
  geom_line(color = "steelblue", linewidth = 0.5) +
  facet_wrap(~scenario_label, ncol = 2, scales = "free_y") +
  labs(title = "Example Time Series from Each Scenario", x = "Time", y = "Value") +
  theme(strip.text = element_text(face = "bold"))
```

### Load Data into DuckDB

```{r}
#| label: load-to-duckdb

dbExecute(con, "DROP TABLE IF EXISTS simulated_series")
dbExecute(con, "
  CREATE TABLE simulated_series (
    global_id INTEGER,
    series_id INTEGER,
    scenario VARCHAR,
    true_period DOUBLE,
    true_strength DOUBLE,
    is_seasonal BOOLEAN,
    values DOUBLE[]
  )
")

for (i in 1:nrow(all_series)) {
  row <- all_series[i, ]
  values_str <- paste0("[", paste(row$values[[1]], collapse = ","), "]")

  dbExecute(con, sprintf("
    INSERT INTO simulated_series VALUES (%d, %d, '%s', %f, %f, %s, %s::DOUBLE[])
  ", row$global_id, row$series_id, row$scenario,
     row$true_period, row$true_strength,
     ifelse(row$is_seasonal, "true", "false"),
     values_str))
}

cat("Data loaded into DuckDB table 'simulated_series'\n")
row_count <- dbGetQuery(con, "SELECT COUNT(*) as n_rows FROM simulated_series")
cat("Row count:", row_count$n_rows, "\n")
```

## Detection Methods Tutorial

This section demonstrates each detection method with explicit SQL queries.

### Method 1: Basic Seasonality Detection (`ts_detect_seasonality`)

Returns an array of detected seasonal periods.

```{r}
#| label: sql-detect-seasonality

# Debug: Check if connection is valid and table exists
cat("Connection class:", class(con), "\n")
tables <- dbListTables(con)
cat("Tables in database:", paste(tables, collapse=", "), "\n")

basic_detection <- dbGetQuery(con, "
SELECT
    global_id,
    scenario,
    true_period,
    ts_detect_seasonality(values) as detected_periods
FROM simulated_series
WHERE series_id = 1
ORDER BY scenario
LIMIT 7
")
```

```{r}
#| label: show-basic-detection

kable(basic_detection, caption = "Basic Seasonality Detection Results")
```

### Method 2: Full Seasonality Analysis (`ts_analyze_seasonality`)

Comprehensive analysis including strength metrics.

```{r}
#| label: sql-analyze-seasonality

full_analysis <- dbGetQuery(con, "
SELECT
    global_id,
    scenario,
    true_period,
    (ts_analyze_seasonality(values)).primary_period as detected_period,
    (ts_analyze_seasonality(values)).seasonal_strength as seasonal_strength,
    (ts_analyze_seasonality(values)).trend_strength as trend_strength
FROM simulated_series
WHERE series_id = 1
ORDER BY scenario
LIMIT 7
")
```

```{r}
#| label: show-full-analysis

kable(full_analysis, digits = 3, caption = "Full Seasonality Analysis Results")
```

### Method 3: FFT Period Estimation (`ts_estimate_period_fft`)

Uses Fast Fourier Transform for precise frequency detection.

```{r}
#| label: sql-fft-period

fft_results <- dbGetQuery(con, "
SELECT
    global_id,
    scenario,
    true_period,
    (ts_estimate_period_fft(values)).period as fft_period,
    (ts_estimate_period_fft(values)).confidence as fft_confidence,
    (ts_estimate_period_fft(values)).power as fft_power
FROM simulated_series
WHERE series_id = 1
ORDER BY scenario
LIMIT 7
")
```

```{r}
#| label: show-fft-results

kable(fft_results, digits = 3, caption = "FFT Period Estimation Results")
```

### Method 4: ACF Period Estimation (`ts_estimate_period_acf`)

Detects periods using autocorrelation peaks.

```{r}
#| label: sql-acf-period

acf_results <- dbGetQuery(con, "
SELECT
    global_id,
    scenario,
    true_period,
    (ts_estimate_period_acf(values)).period as acf_period,
    (ts_estimate_period_acf(values)).confidence as acf_confidence
FROM simulated_series
WHERE series_id = 1
ORDER BY scenario
LIMIT 7
")
```

```{r}
#| label: show-acf-results

kable(acf_results, digits = 3, caption = "ACF Period Estimation Results")
```

### Method 5: Autoperiod (`ts_autoperiod`)

Hybrid approach combining FFT with ACF validation for robust period detection.

```{r}
#| label: sql-autoperiod

autoperiod_results <- dbGetQuery(con, "
SELECT
    global_id,
    scenario,
    true_period,
    (ts_autoperiod(values)).period as autoperiod_period,
    (ts_autoperiod(values)).fft_confidence as autoperiod_confidence,
    (ts_autoperiod(values)).acf_validation as autoperiod_acf_val
FROM simulated_series
WHERE series_id = 1
ORDER BY scenario
LIMIT 7
")
```

```{r}
#| label: show-autoperiod-results

kable(autoperiod_results, digits = 3, caption = "Autoperiod Detection Results")
```

### Method 6: CFD-Autoperiod (`ts_cfd_autoperiod`)

Circular Frequency Domain variant of Autoperiod for improved harmonic handling.

```{r}
#| label: sql-cfd-autoperiod

cfd_results <- dbGetQuery(con, "
SELECT
    global_id,
    scenario,
    true_period,
    (ts_cfd_autoperiod(values)).period as cfd_period,
    (ts_cfd_autoperiod(values)).fft_confidence as cfd_confidence,
    (ts_cfd_autoperiod(values)).acf_validation as cfd_acf_val
FROM simulated_series
WHERE series_id = 1
ORDER BY scenario
LIMIT 7
")
```

```{r}
#| label: show-cfd-results

kable(cfd_results, digits = 3, caption = "CFD-Autoperiod Detection Results")
```

### Method 7: Lomb-Scargle Periodogram (`ts_lomb_scargle`)

Spectral analysis optimized for irregularly sampled data with false alarm probability.

```{r}
#| label: sql-lomb-scargle

lomb_results <- dbGetQuery(con, "
SELECT
    global_id,
    scenario,
    true_period,
    (ts_lomb_scargle(values)).period as lomb_period,
    (ts_lomb_scargle(values)).power as lomb_power,
    (ts_lomb_scargle(values)).false_alarm_prob as lomb_fap
FROM simulated_series
WHERE series_id = 1
ORDER BY scenario
LIMIT 7
")
```

```{r}
#| label: show-lomb-results

kable(lomb_results, digits = 3, caption = "Lomb-Scargle Periodogram Results")
```

### Method 8: AIC-Based Model Comparison (`ts_aic_period`)

Fits sinusoidal models at candidate periods and selects best via AIC/BIC criteria.

```{r}
#| label: sql-aic-period

aic_results <- dbGetQuery(con, "
SELECT
    global_id,
    scenario,
    true_period,
    (ts_aic_period(values)).period as aic_period,
    (ts_aic_period(values)).r_squared as aic_r_squared,
    (ts_aic_period(values)).aic as aic_value
FROM simulated_series
WHERE series_id = 1
ORDER BY scenario
LIMIT 7
")
```

```{r}
#| label: show-aic-results

kable(aic_results, digits = 3, caption = "AIC Period Selection Results")
```

### Method 9: Singular Spectrum Analysis (`ts_ssa_period`)

Decomposes the time series via SSA to extract periodic components.

```{r}
#| label: sql-ssa-period

ssa_results <- dbGetQuery(con, "
SELECT
    global_id,
    scenario,
    true_period,
    (ts_ssa_period(values)).period as ssa_period,
    (ts_ssa_period(values)).variance_explained as ssa_variance
FROM simulated_series
WHERE series_id = 1
ORDER BY scenario
LIMIT 7
")
```

```{r}
#| label: show-ssa-results

kable(ssa_results, digits = 3, caption = "SSA Period Detection Results")
```

### Method 10: STL Decomposition (`ts_stl_period`)

Uses STL (Seasonal and Trend decomposition using LOESS) to find the period that maximizes seasonal strength.

```{r}
#| label: sql-stl-period

stl_results <- dbGetQuery(con, "
SELECT
    global_id,
    scenario,
    true_period,
    (ts_stl_period(values)).period as stl_period,
    (ts_stl_period(values)).seasonal_strength as stl_strength
FROM simulated_series
WHERE series_id = 1
ORDER BY scenario
LIMIT 7
")
```

```{r}
#| label: show-stl-results

kable(stl_results, digits = 3, caption = "STL Period Detection Results")
```

### Method 11: Matrix Profile (`ts_matrix_profile_period`)

Uses Matrix Profile algorithm to find motifs (recurring patterns) and estimate periodicity from the distribution of motif distances.

```{r}
#| label: sql-mp-period

mp_results <- dbGetQuery(con, "
SELECT
    global_id,
    scenario,
    true_period,
    (ts_matrix_profile_period(values)).period as mp_period,
    (ts_matrix_profile_period(values)).confidence as mp_confidence,
    (ts_matrix_profile_period(values)).n_motifs as mp_n_motifs
FROM simulated_series
WHERE series_id = 1
ORDER BY scenario
LIMIT 7
")
```

```{r}
#| label: show-mp-results

kable(mp_results, digits = 3, caption = "Matrix Profile Period Detection Results")
```

### Method 12: SAZED (`ts_sazed_period`)

Spectral Analysis with Zero-padding for Enhanced Detection - uses zero-padding and Hann windowing to improve frequency resolution in spectral analysis.

```{r}
#| label: sql-sazed-period

sazed_results <- dbGetQuery(con, "
SELECT
    global_id,
    scenario,
    true_period,
    (ts_sazed_period(values)).period as sazed_period,
    (ts_sazed_period(values)).snr as sazed_snr
FROM simulated_series
WHERE series_id = 1
ORDER BY scenario
LIMIT 7
")
```

```{r}
#| label: show-sazed-results

kable(sazed_results, digits = 3, caption = "SAZED Period Detection Results")
```


## Running Full Detection with All Methods

Now we run all twelve detection methods on all simulated series.

```{r}
#| label: sql-full-detection

all_detections <- dbGetQuery(con, "
WITH detection_results AS (
    SELECT
        global_id,
        scenario,
        true_period,
        true_strength,
        is_seasonal,
        -- Method 1: Basic detection
        ts_detect_seasonality(values) as basic,
        -- Method 2: Full analysis
        ts_analyze_seasonality(values) as analysis,
        -- Method 3: FFT detection
        ts_estimate_period_fft(values) as fft,
        -- Method 4: ACF detection
        ts_estimate_period_acf(values) as acf,
        -- Method 5: Autoperiod
        ts_autoperiod(values) as autoperiod,
        -- Method 6: CFD-Autoperiod
        ts_cfd_autoperiod(values) as cfd,
        -- Method 7: Lomb-Scargle
        ts_lomb_scargle(values) as lomb,
        -- Method 8: AIC comparison
        ts_aic_period(values) as aic,
        -- Method 9: SSA period
        ts_ssa_period(values) as ssa,
        -- Method 10: STL period
        ts_stl_period(values) as stl,
        -- Method 11: Matrix Profile period
        ts_matrix_profile_period(values) as mp,
        -- Method 12: SAZED period
        ts_sazed_period(values) as sazed
    FROM simulated_series
)
SELECT
    global_id,
    scenario,
    true_period,
    true_strength,
    is_seasonal,
    -- Basic: extract first period from array (if exists)
    CASE WHEN len(basic) > 0 THEN basic[1] ELSE NULL END as basic_period,
    -- Analysis results
    (analysis).primary_period as analysis_period,
    (analysis).seasonal_strength as analysis_strength,
    -- FFT results
    (fft).period as fft_period,
    (fft).confidence as fft_confidence,
    -- ACF results
    (acf).period as acf_period,
    (acf).confidence as acf_confidence,
    -- Autoperiod results
    (autoperiod).period as autoperiod_period,
    (autoperiod).fft_confidence as autoperiod_confidence,
    -- CFD-Autoperiod results
    (cfd).period as cfd_period,
    (cfd).fft_confidence as cfd_confidence,
    -- Lomb-Scargle results
    (lomb).period as lomb_period,
    (lomb).power as lomb_power,
    -- AIC results
    (aic).period as aic_period,
    (aic).r_squared as aic_r_squared,
    -- SSA results
    (ssa).period as ssa_period,
    (ssa).variance_explained as ssa_variance,
    -- STL results
    (stl).period as stl_period,
    (stl).seasonal_strength as stl_strength,
    -- Matrix Profile results
    (mp).period as mp_period,
    (mp).confidence as mp_confidence,
    -- SAZED results
    (sazed).period as sazed_period,
    (sazed).snr as sazed_snr
FROM detection_results
")
```

```{r}
#| label: process-detections

# Convert to tibble and add derived columns
detections <- as_tibble(all_detections) %>%
  mutate(
    # Period detection accuracy (within 10% of true period, handle division by zero)
    basic_accurate = ifelse(true_period > 0,
                            abs(basic_period - true_period) / true_period < 0.1, FALSE),
    analysis_accurate = ifelse(true_period > 0,
                               abs(analysis_period - true_period) / true_period < 0.1, FALSE),
    fft_accurate = ifelse(true_period > 0,
                          abs(fft_period - true_period) / true_period < 0.1, FALSE),
    acf_accurate = ifelse(true_period > 0,
                          abs(acf_period - true_period) / true_period < 0.1, FALSE),
    autoperiod_accurate = ifelse(true_period > 0,
                                  abs(autoperiod_period - true_period) / true_period < 0.1, FALSE),
    cfd_accurate = ifelse(true_period > 0,
                          abs(cfd_period - true_period) / true_period < 0.1, FALSE),
    lomb_accurate = ifelse(true_period > 0,
                           abs(lomb_period - true_period) / true_period < 0.1, FALSE),
    aic_accurate = ifelse(true_period > 0,
                          abs(aic_period - true_period) / true_period < 0.1, FALSE),
    ssa_accurate = ifelse(true_period > 0,
                          abs(ssa_period - true_period) / true_period < 0.1, FALSE),
    stl_accurate = ifelse(true_period > 0,
                          abs(stl_period - true_period) / true_period < 0.1, FALSE),
    mp_accurate = ifelse(true_period > 0,
                         abs(mp_period - true_period) / true_period < 0.1, FALSE),
    sazed_accurate = ifelse(true_period > 0,
                            abs(sazed_period - true_period) / true_period < 0.1, FALSE),
    # Detection based on various thresholds
    basic_detected = !is.na(basic_period) & basic_period > 0,
    analysis_detected = analysis_strength > 0.3,
    fft_detected = fft_confidence > 0.5,
    acf_detected = acf_confidence > 0.5,
    autoperiod_detected = !is.na(autoperiod_period) & autoperiod_period > 0 & autoperiod_confidence > 0.1,
    cfd_detected = !is.na(cfd_period) & cfd_period > 0 & cfd_confidence > 0.1,
    lomb_detected = !is.na(lomb_period) & lomb_period > 0 & lomb_power > 0.1,
    aic_detected = !is.na(aic_period) & aic_period > 0 & aic_r_squared > 0.3,
    ssa_detected = !is.na(ssa_period) & ssa_period > 0 & ssa_variance > 0.3,
    stl_detected = !is.na(stl_period) & stl_period > 0 & stl_strength > 0.3,
    mp_detected = !is.na(mp_period) & mp_period > 0 & mp_confidence > 0.1,
    sazed_detected = !is.na(sazed_period) & sazed_period > 0 & sazed_snr > 1.0
  )

cat(sprintf("Processed %d detection results\n", nrow(detections)))
```

## Evaluation Results

### Detection Rates by Scenario (All Methods)

```{r}
#| label: fig-detection-rates
#| fig-cap: "Detection rates across scenarios for all twelve methods"
#| fig-height: 10

detection_rates <- detections %>%
  group_by(scenario) %>%
  summarise(
    Basic = mean(basic_detected, na.rm = TRUE),
    Analysis = mean(analysis_detected, na.rm = TRUE),
    FFT = mean(fft_detected, na.rm = TRUE),
    ACF = mean(acf_detected, na.rm = TRUE),
    Autoperiod = mean(autoperiod_detected, na.rm = TRUE),
    CFD = mean(cfd_detected, na.rm = TRUE),
    Lomb = mean(lomb_detected, na.rm = TRUE),
    AIC = mean(aic_detected, na.rm = TRUE),
    SSA = mean(ssa_detected, na.rm = TRUE),
    STL = mean(stl_detected, na.rm = TRUE),
    MatrixProfile = mean(mp_detected, na.rm = TRUE),
    SAZED = mean(sazed_detected, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  pivot_longer(cols = c(Basic, Analysis, FFT, ACF, Autoperiod, CFD, Lomb, AIC, SSA, STL, MatrixProfile, SAZED),
               names_to = "method", values_to = "detection_rate") %>%
  mutate(method = factor(method, levels = names(METHOD_COLORS)))

ggplot(detection_rates, aes(x = method, y = scenario, fill = detection_rate)) +
  geom_tile(color = "white", linewidth = 0.5) +
  geom_text(aes(label = sprintf("%.2f", detection_rate)),
            color = ifelse(detection_rates$detection_rate > 0.5, "white", "black"),
            size = 3.5) +
  scale_fill_gradient2(low = "#d73027", mid = "#ffffbf", high = "#1a9850",
                       midpoint = 0.5, limits = c(0, 1)) +
  labs(
    title = "Seasonality Detection Rate by Scenario and Method",
    subtitle = "All twelve detection methods compared",
    x = "Detection Method",
    y = "Scenario",
    fill = "Detection\nRate"
  ) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

### Detection Rates Table

```{r}
#| label: detection-rates-table

detection_rates_wide <- detections %>%
  group_by(scenario) %>%
  summarise(
    Basic = sprintf("%.1f%%", mean(basic_detected, na.rm = TRUE) * 100),
    Analysis = sprintf("%.1f%%", mean(analysis_detected, na.rm = TRUE) * 100),
    FFT = sprintf("%.1f%%", mean(fft_detected, na.rm = TRUE) * 100),
    ACF = sprintf("%.1f%%", mean(acf_detected, na.rm = TRUE) * 100),
    Autoperiod = sprintf("%.1f%%", mean(autoperiod_detected, na.rm = TRUE) * 100),
    CFD = sprintf("%.1f%%", mean(cfd_detected, na.rm = TRUE) * 100),
    Lomb = sprintf("%.1f%%", mean(lomb_detected, na.rm = TRUE) * 100),
    AIC = sprintf("%.1f%%", mean(aic_detected, na.rm = TRUE) * 100),
    SSA = sprintf("%.1f%%", mean(ssa_detected, na.rm = TRUE) * 100),
    STL = sprintf("%.1f%%", mean(stl_detected, na.rm = TRUE) * 100),
    MatrixProfile = sprintf("%.1f%%", mean(mp_detected, na.rm = TRUE) * 100),
    SAZED = sprintf("%.1f%%", mean(sazed_detected, na.rm = TRUE) * 100),
    .groups = "drop"
  )

kable(detection_rates_wide, caption = "Detection Rates by Scenario and Method")
```

### Period Estimation Accuracy (All Methods)

```{r}
#| label: fig-period-accuracy
#| fig-cap: "Period estimation accuracy for all methods"
#| fig-height: 12

period_data <- detections %>%
  filter(is_seasonal, true_period > 0) %>%
  select(scenario, true_period, basic_period, analysis_period,
         fft_period, acf_period, autoperiod_period, cfd_period,
         lomb_period, aic_period, ssa_period, stl_period, mp_period, sazed_period) %>%
  pivot_longer(cols = c(basic_period, analysis_period, fft_period, acf_period,
                        autoperiod_period, cfd_period, lomb_period, aic_period, ssa_period,
                        stl_period, mp_period, sazed_period),
               names_to = "method", values_to = "detected_period") %>%
  mutate(
    method = gsub("_period", "", method),
    method = case_when(
      method == "basic" ~ "Basic",
      method == "analysis" ~ "Analysis",
      method == "fft" ~ "FFT",
      method == "acf" ~ "ACF",
      method == "autoperiod" ~ "Autoperiod",
      method == "cfd" ~ "CFD",
      method == "lomb" ~ "Lomb",
      method == "aic" ~ "AIC",
      method == "ssa" ~ "SSA",
      method == "stl" ~ "STL",
      method == "mp" ~ "MatrixProfile",
      method == "sazed" ~ "SAZED"
    ),
    method = factor(method, levels = names(METHOD_COLORS))
  ) %>%
  filter(!is.na(detected_period))

ggplot(period_data, aes(x = true_period, y = detected_period, color = method)) +
  geom_point(alpha = 0.3, size = 1.5) +
  geom_abline(slope = 1, intercept = 0, color = "black", linetype = "dashed", linewidth = 0.8) +
  facet_wrap(~method, ncol = 3) +
  scale_color_manual(values = METHOD_COLORS) +
  coord_fixed(xlim = c(0, 30), ylim = c(0, 30)) +
  labs(
    title = "Period Estimation: Detected vs True Period",
    subtitle = "Points on diagonal line indicate accurate detection",
    x = "True Period",
    y = "Detected Period"
  ) +
  theme(legend.position = "none")
```

### Confidence Distribution by Ground Truth (All Methods)

```{r}
#| label: fig-confidence-dist
#| fig-cap: "Distribution of confidence/strength scores by ground truth for all methods"
#| fig-height: 10

confidence_data <- detections %>%
  select(is_seasonal, analysis_strength, fft_confidence, acf_confidence,
         autoperiod_confidence, cfd_confidence, lomb_power, aic_r_squared, ssa_variance) %>%
  pivot_longer(cols = c(analysis_strength, fft_confidence, acf_confidence,
                        autoperiod_confidence, cfd_confidence, lomb_power, aic_r_squared, ssa_variance),
               names_to = "method", values_to = "confidence") %>%
  mutate(
    method = case_when(
      method == "analysis_strength" ~ "Analysis",
      method == "fft_confidence" ~ "FFT",
      method == "acf_confidence" ~ "ACF",
      method == "autoperiod_confidence" ~ "Autoperiod",
      method == "cfd_confidence" ~ "CFD",
      method == "lomb_power" ~ "Lomb",
      method == "aic_r_squared" ~ "AIC",
      method == "ssa_variance" ~ "SSA"
    ),
    method = factor(method, levels = c("Analysis", "FFT", "ACF", "Autoperiod", "CFD", "Lomb", "AIC", "SSA")),
    ground_truth = ifelse(is_seasonal, "Seasonal", "Non-seasonal")
  ) %>%
  filter(!is.na(confidence))

ggplot(confidence_data, aes(x = confidence, fill = ground_truth)) +
  geom_histogram(bins = 30, alpha = 0.7, position = "identity") +
  facet_wrap(~method, scales = "free_y", ncol = 3) +
  scale_fill_manual(values = c("Seasonal" = "#377EB8", "Non-seasonal" = "#E41A1C")) +
  labs(
    title = "Confidence Score Distribution by Ground Truth",
    x = "Confidence / Strength Score",
    y = "Count",
    fill = "Ground Truth"
  ) +
  theme(legend.position = "bottom")
```

### Performance Metrics (All Methods)

```{r}
#| label: performance-metrics

calc_metrics <- function(detected, actual) {
  detected <- replace(detected, is.na(detected), FALSE)
  actual <- replace(actual, is.na(actual), FALSE)

  tp <- sum(detected & actual)
  tn <- sum(!detected & !actual)
  fp <- sum(detected & !actual)
  fn <- sum(!detected & actual)

  precision <- ifelse(tp + fp > 0, tp / (tp + fp), 0)
  recall <- ifelse(tp + fn > 0, tp / (tp + fn), 0)
  specificity <- ifelse(tn + fp > 0, tn / (tn + fp), 0)
  f1 <- ifelse(precision + recall > 0, 2 * (precision * recall) / (precision + recall), 0)
  accuracy <- (tp + tn) / (tp + tn + fp + fn)

  tibble(
    TP = tp, TN = tn, FP = fp, FN = fn,
    Precision = precision,
    Recall = recall,
    Specificity = specificity,
    F1 = f1,
    Accuracy = accuracy
  )
}

metrics <- bind_rows(
  calc_metrics(detections$basic_detected, detections$is_seasonal) %>% mutate(Method = "Basic"),
  calc_metrics(detections$analysis_detected, detections$is_seasonal) %>% mutate(Method = "Analysis"),
  calc_metrics(detections$fft_detected, detections$is_seasonal) %>% mutate(Method = "FFT"),
  calc_metrics(detections$acf_detected, detections$is_seasonal) %>% mutate(Method = "ACF"),
  calc_metrics(detections$autoperiod_detected, detections$is_seasonal) %>% mutate(Method = "Autoperiod"),
  calc_metrics(detections$cfd_detected, detections$is_seasonal) %>% mutate(Method = "CFD"),
  calc_metrics(detections$lomb_detected, detections$is_seasonal) %>% mutate(Method = "Lomb"),
  calc_metrics(detections$aic_detected, detections$is_seasonal) %>% mutate(Method = "AIC"),
  calc_metrics(detections$ssa_detected, detections$is_seasonal) %>% mutate(Method = "SSA"),
  calc_metrics(detections$stl_detected, detections$is_seasonal) %>% mutate(Method = "STL"),
  calc_metrics(detections$mp_detected, detections$is_seasonal) %>% mutate(Method = "MatrixProfile"),
  calc_metrics(detections$sazed_detected, detections$is_seasonal) %>% mutate(Method = "SAZED")
) %>%
  select(Method, Precision, Recall, Specificity, F1, Accuracy)

kable(metrics, digits = 3, caption = "Detection Performance Metrics (All Methods)")
```

### Scenario-Specific Performance (All Methods)

```{r}
#| label: fig-scenario-performance
#| fig-cap: "Detection rates by scenario for all methods"
#| fig-height: 10

scenario_metrics <- detections %>%
  group_by(scenario) %>%
  summarise(
    Basic = mean(basic_detected, na.rm = TRUE),
    Analysis = mean(analysis_detected, na.rm = TRUE),
    FFT = mean(fft_detected, na.rm = TRUE),
    ACF = mean(acf_detected, na.rm = TRUE),
    Autoperiod = mean(autoperiod_detected, na.rm = TRUE),
    CFD = mean(cfd_detected, na.rm = TRUE),
    Lomb = mean(lomb_detected, na.rm = TRUE),
    AIC = mean(aic_detected, na.rm = TRUE),
    SSA = mean(ssa_detected, na.rm = TRUE),
    STL = mean(stl_detected, na.rm = TRUE),
    MatrixProfile = mean(mp_detected, na.rm = TRUE),
    SAZED = mean(sazed_detected, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  pivot_longer(-scenario, names_to = "method", values_to = "value") %>%
  mutate(method = factor(method, levels = names(METHOD_COLORS)))

ggplot(scenario_metrics, aes(x = scenario, y = value, fill = method)) +
  geom_col(position = "dodge") +
  scale_y_continuous(limits = c(0, 1), labels = percent) +
  scale_fill_manual(values = METHOD_COLORS) +
  labs(
    title = "Detection Rate by Scenario and Method",
    x = "Scenario",
    y = "Detection Rate",
    fill = "Method"
  ) +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    legend.position = "bottom"
  )
```

## Statistical Comparison: McNemar Tests

McNemar's test compares paired binary outcomes between methods. A significant p-value indicates that two methods differ in their detection performance.

```{r}
#| label: mcnemar-function

# McNemar test function
run_mcnemar <- function(method1, method2, data) {
  d1 <- data[[paste0(method1, "_detected")]]
  d2 <- data[[paste0(method2, "_detected")]]

  # Replace NA with FALSE
  d1 <- replace(d1, is.na(d1), FALSE)
  d2 <- replace(d2, is.na(d2), FALSE)

  # Create contingency table
  b <- sum(d1 & !d2)  # Method1 detected, Method2 missed
  c <- sum(!d1 & d2)  # Method1 missed, Method2 detected

  # McNemar test (with continuity correction)
  if (b + c > 0) {
    chi_sq <- (abs(b - c) - 1)^2 / (b + c)
    p_value <- pchisq(chi_sq, df = 1, lower.tail = FALSE)
  } else {
    chi_sq <- 0
    p_value <- 1
  }

  tibble(
    Method1 = method1,
    Method2 = method2,
    `Only M1` = b,
    `Only M2` = c,
    `Chi-sq` = chi_sq,
    `p-value` = p_value,
    Significant = ifelse(p_value < 0.05, "*", "")
  )
}
```

### Overall McNemar Comparison

```{r}
#| label: mcnemar-overall

methods <- c("basic", "analysis", "fft", "acf", "autoperiod", "cfd", "lomb", "aic", "ssa", "stl", "mp", "sazed")
method_pairs <- combn(methods, 2, simplify = FALSE)

mcnemar_results <- map_dfr(method_pairs, function(pair) {
  run_mcnemar(pair[1], pair[2], detections)
})

# Capitalize method names for display
mcnemar_results <- mcnemar_results %>%
  mutate(
    Method1 = case_when(
      Method1 == "mp" ~ "MatrixProfile",
      Method1 == "sazed" ~ "SAZED",
      Method1 == "stl" ~ "STL",
      TRUE ~ tools::toTitleCase(Method1)
    ),
    Method2 = case_when(
      Method2 == "mp" ~ "MatrixProfile",
      Method2 == "sazed" ~ "SAZED",
      Method2 == "stl" ~ "STL",
      TRUE ~ tools::toTitleCase(Method2)
    )
  )

kable(mcnemar_results, digits = 4,
      caption = "McNemar Test: Pairwise Method Comparisons (* = p < 0.05)")
```

### McNemar Tests by Scenario

```{r}
#| label: mcnemar-by-scenario

mcnemar_by_scenario <- detections %>%
  group_by(scenario) %>%
  group_split() %>%
  map_dfr(function(scenario_data) {
    scenario_name <- unique(scenario_data$scenario)

    map_dfr(method_pairs, function(pair) {
      run_mcnemar(pair[1], pair[2], scenario_data) %>%
        mutate(Scenario = as.character(scenario_name))
    })
  }) %>%
  mutate(
    Method1 = case_when(
      Method1 == "mp" ~ "MatrixProfile",
      Method1 == "sazed" ~ "SAZED",
      Method1 == "stl" ~ "STL",
      TRUE ~ tools::toTitleCase(Method1)
    ),
    Method2 = case_when(
      Method2 == "mp" ~ "MatrixProfile",
      Method2 == "sazed" ~ "SAZED",
      Method2 == "stl" ~ "STL",
      TRUE ~ tools::toTitleCase(Method2)
    )
  ) %>%
  select(Scenario, everything())

# Show significant differences only
significant_mcnemar <- mcnemar_by_scenario %>%
  filter(`p-value` < 0.05)

if (nrow(significant_mcnemar) > 0) {
  kable(significant_mcnemar, digits = 4,
        caption = "Significant McNemar Results by Scenario (p < 0.05)")
} else {
  cat("No significant differences found between methods within scenarios.\n")
}
```

### McNemar Summary Heatmap

```{r}
#| label: fig-mcnemar-heatmap
#| fig-cap: "McNemar test p-values between method pairs (lower = more different)"
#| fig-height: 8
#| fig-width: 10

# Create symmetric matrix for heatmap
method_names <- c("Basic", "Analysis", "FFT", "ACF", "Autoperiod", "Cfd", "Lomb", "Aic", "Ssa")
mcnemar_matrix <- mcnemar_results %>%
  select(Method1, Method2, `p-value`) %>%
  bind_rows(
    mcnemar_results %>%
      select(Method1 = Method2, Method2 = Method1, `p-value`)
  ) %>%
  complete(Method1 = method_names, Method2 = method_names, fill = list(`p-value` = 1)) %>%
  mutate(`p-value` = ifelse(Method1 == Method2, NA, `p-value`))

ggplot(mcnemar_matrix, aes(x = Method1, y = Method2, fill = `p-value`)) +
  geom_tile(color = "white", linewidth = 0.5) +
  geom_text(aes(label = ifelse(is.na(`p-value`), "-",
                               ifelse(`p-value` < 0.001, "<.001",
                                      sprintf("%.3f", `p-value`)))),
            size = 3) +
  scale_fill_gradient2(low = "#d73027", mid = "#ffffbf", high = "#1a9850",
                       midpoint = 0.5, limits = c(0, 1), na.value = "grey90") +
  labs(
    title = "McNemar Test P-Values Between Methods",
    subtitle = "Red indicates significant difference (p < 0.05)",
    x = "", y = "",
    fill = "p-value"
  ) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

## Summary Statistics

```{r}
#| label: summary-table

overall_summary <- metrics %>%
  arrange(desc(F1)) %>%
  mutate(Rank = row_number()) %>%
  select(Rank, Method, F1, Accuracy, Precision, Recall, Specificity)

kable(overall_summary, digits = 3,
      caption = "Overall Method Ranking by F1 Score")
```

```{r}
#| label: executive-summary-final

# Best method per scenario
best_by_scenario <- detections %>%
  group_by(scenario) %>%
  summarise(
    Basic = mean(basic_detected, na.rm = TRUE),
    Analysis = mean(analysis_detected, na.rm = TRUE),
    FFT = mean(fft_detected, na.rm = TRUE),
    ACF = mean(acf_detected, na.rm = TRUE),
    Autoperiod = mean(autoperiod_detected, na.rm = TRUE),
    CFD = mean(cfd_detected, na.rm = TRUE),
    Lomb = mean(lomb_detected, na.rm = TRUE),
    AIC = mean(aic_detected, na.rm = TRUE),
    SSA = mean(ssa_detected, na.rm = TRUE),
    STL = mean(stl_detected, na.rm = TRUE),
    MatrixProfile = mean(mp_detected, na.rm = TRUE),
    SAZED = mean(sazed_detected, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  rowwise() %>%
  mutate(
    best_rate = max(c_across(Basic:SAZED)),
    best_method = names(METHOD_COLORS)[which.max(c_across(Basic:SAZED))]
  ) %>%
  ungroup() %>%
  select(Scenario = scenario, `Best Method` = best_method, `Detection Rate` = best_rate)

kable(best_by_scenario, digits = 3,
      caption = "Best Performing Method per Scenario")
```

## Recommendations

Based on the benchmark results:

### Method Selection Guide

```{r}
#| label: recommendations-table
#| echo: false

recommendations <- tibble(
  `Scenario Type` = c(
    "Clean, stable seasonality",
    "Noisy data",
    "Unknown characteristics",
    "Trending data",
    "Irregular sampling",
    "Model selection needed",
    "Non-stationary signals"
  ),
  `Recommended Method` = c(
    "FFT (`ts_estimate_period_fft`) or AIC (`ts_aic_period`)",
    "ACF (`ts_estimate_period_acf`) or Autoperiod (`ts_autoperiod`)",
    "Analysis (`ts_analyze_seasonality`)",
    "Analysis (`ts_analyze_seasonality`)",
    "Lomb-Scargle (`ts_lomb_scargle`)",
    "AIC (`ts_aic_period`)",
    "SSA (`ts_ssa_period`)"
  ),
  Rationale = c(
    "Precise frequency detection with high RÂ²",
    "Robust to noise with ACF validation",
    "Comprehensive metrics including trend",
    "Built-in detrending",
    "Handles gaps and uneven spacing",
    "Information-theoretic model comparison",
    "Adaptive decomposition for changing patterns"
  )
)

kable(recommendations, caption = "Method Selection Recommendations")
```

### Best Practices

1. **Start with `ts_analyze_seasonality`** for initial exploration
2. **Use confidence thresholds** appropriate to your use case
3. **Cross-validate** using multiple methods when accuracy is critical
4. **Consider the scenario** - different methods excel in different conditions

## Conclusion

The `anofox-forecast` DuckDB extension provides robust seasonality detection through twelve complementary methods. Key findings:

- **FFT-based detection** excels at precise frequency detection in clean signals
- **ACF-based detection** shows robustness to noise
- **Autoperiod/CFD-Autoperiod** combine FFT power with ACF validation for hybrid robustness
- **Lomb-Scargle** handles irregular sampling and provides false alarm probabilities
- **AIC comparison** offers rigorous model selection with information-theoretic criteria
- **SSA** provides adaptive decomposition for non-stationary signals
- **STL decomposition** optimizes seasonal strength to find the best period
- **Matrix Profile** discovers recurring motifs for period estimation
- **SAZED** uses zero-padding to enhance spectral frequency resolution
- **Full analysis** provides comprehensive view with multiple metrics
- **Basic detection** offers simple period extraction for quick analysis

## Cleanup

```{r}
#| label: cleanup
#| cache: false

dbDisconnect(con, shutdown = TRUE)
```

## Appendix: SQL Function Reference

```sql
-- Method 1: Basic detection (returns array of periods)
SELECT ts_detect_seasonality(values) FROM my_table;

-- Method 2: Full analysis (returns struct with multiple metrics)
SELECT
    (ts_analyze_seasonality(values)).primary_period,
    (ts_analyze_seasonality(values)).seasonal_strength,
    (ts_analyze_seasonality(values)).trend_strength
FROM my_table;

-- Method 3: FFT period estimation
SELECT
    (ts_estimate_period_fft(values)).period,
    (ts_estimate_period_fft(values)).confidence
FROM my_table;

-- Method 4: ACF period estimation
SELECT
    (ts_estimate_period_acf(values)).period,
    (ts_estimate_period_acf(values)).confidence
FROM my_table;

-- Method 5: Autoperiod (hybrid FFT+ACF validation)
SELECT
    (ts_autoperiod(values)).period,
    (ts_autoperiod(values)).fft_confidence,
    (ts_autoperiod(values)).acf_validation
FROM my_table;

-- Method 6: CFD-Autoperiod (Circular Frequency Domain variant)
SELECT
    (ts_cfd_autoperiod(values)).period,
    (ts_cfd_autoperiod(values)).fft_confidence,
    (ts_cfd_autoperiod(values)).acf_validation
FROM my_table;

-- Method 7: Lomb-Scargle periodogram
SELECT
    (ts_lomb_scargle(values)).period,
    (ts_lomb_scargle(values)).power,
    (ts_lomb_scargle(values)).false_alarm_prob
FROM my_table;

-- Method 8: AIC-based model comparison
SELECT
    (ts_aic_period(values)).period,
    (ts_aic_period(values)).aic,
    (ts_aic_period(values)).r_squared
FROM my_table;

-- Method 9: Singular Spectrum Analysis
SELECT
    (ts_ssa_period(values)).period,
    (ts_ssa_period(values)).variance_explained
FROM my_table;

-- Method 10: STL Decomposition
SELECT
    (ts_stl_period(values)).period,
    (ts_stl_period(values)).seasonal_strength,
    (ts_stl_period(values)).trend_strength
FROM my_table;

-- Method 11: Matrix Profile
SELECT
    (ts_matrix_profile_period(values)).period,
    (ts_matrix_profile_period(values)).confidence,
    (ts_matrix_profile_period(values)).n_motifs
FROM my_table;

-- Method 12: SAZED (Spectral Analysis with Zero-padding)
SELECT
    (ts_sazed_period(values)).period,
    (ts_sazed_period(values)).power,
    (ts_sazed_period(values)).snr
FROM my_table;
```

### Session Info

```{r}
#| label: session-info

sessionInfo()
```
