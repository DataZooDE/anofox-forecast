#ifndef ANOFOX_FCST_FFI_H
#define ANOFOX_FCST_FFI_H

#pragma once

/* Warning: this file is autogenerated by cbindgen. Don't modify this manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

/**
 * Date type enumeration for handling different DuckDB date types.
 */
typedef enum DateType {
    /**
     * Days since epoch (1970-01-01)
     */
    DATE = 0,
    /**
     * Microseconds since epoch
     */
    TIMESTAMP = 1,
    /**
     * Generic integer periods
     */
    INTEGER = 2,
} DateType;

/**
 * Error codes for FFI boundary.
 */
typedef enum ErrorCode {
    SUCCESS = 0,
    NULL_POINTER = 1,
    INVALID_INPUT = 2,
    COMPUTATION_ERROR = 3,
    ALLOCATION_ERROR = 4,
    INVALID_MODEL = 5,
    INSUFFICIENT_DATA = 6,
    INVALID_DATE_FORMAT = 7,
    INVALID_FREQUENCY = 8,
    PANIC_CAUGHT = 9,
    INTERNAL_ERROR = 10,
} ErrorCode;

/**
 * Time series statistics result (24 metrics).
 */
typedef struct TsStatsResult {
    /**
     * Total number of observations
     */
    size_t length;
    /**
     * Number of NULL values
     */
    size_t n_nulls;
    /**
     * Number of zero values
     */
    size_t n_zeros;
    /**
     * Number of positive values
     */
    size_t n_positive;
    /**
     * Number of negative values
     */
    size_t n_negative;
    /**
     * Arithmetic mean
     */
    double mean;
    /**
     * Median (50th percentile)
     */
    double median;
    /**
     * Standard deviation
     */
    double std_dev;
    /**
     * Variance
     */
    double variance;
    /**
     * Minimum value
     */
    double min;
    /**
     * Maximum value
     */
    double max;
    /**
     * Range (max - min)
     */
    double range;
    /**
     * Sum of all values
     */
    double sum;
    /**
     * Skewness
     */
    double skewness;
    /**
     * Kurtosis
     */
    double kurtosis;
    /**
     * Coefficient of variation
     */
    double coef_variation;
    /**
     * First quartile
     */
    double q1;
    /**
     * Third quartile
     */
    double q3;
    /**
     * Interquartile range
     */
    double iqr;
    /**
     * Autocorrelation at lag 1
     */
    double autocorr_lag1;
    /**
     * Trend strength (0-1)
     */
    double trend_strength;
    /**
     * Seasonality strength (0-1)
     */
    double seasonality_strength;
    /**
     * Approximate entropy
     */
    double entropy;
    /**
     * Stability measure
     */
    double stability;
} TsStatsResult;

/**
 * Error structure with message buffer for FFI.
 */
typedef struct AnofoxError {
    enum ErrorCode code;
    char message[256];
} AnofoxError;

/**
 * Seasonality analysis result.
 * C++ API compatible field names.
 */
typedef struct SeasonalityResult {
    /**
     * Array of detected periods (C++ name: detected_periods)
     */
    int *detected_periods;
    /**
     * Number of detected periods
     */
    size_t n_periods;
    /**
     * Primary (dominant) period (C++ name: primary_period)
     */
    int primary_period;
    /**
     * Seasonal strength (0-1)
     */
    double seasonal_strength;
    /**
     * Trend strength (0-1)
     */
    double trend_strength;
} SeasonalityResult;

/**
 * MSTL decomposition result.
 */
typedef struct MstlResult {
    /**
     * Trend component
     */
    double *trend;
    /**
     * Array of seasonal component arrays (one per period)
     */
    double **seasonal_components;
    /**
     * Remainder (residual) component
     */
    double *remainder;
    /**
     * Number of observations
     */
    size_t n_observations;
    /**
     * Number of seasonal components
     */
    size_t n_seasonal;
    /**
     * Array of seasonal periods
     */
    int *seasonal_periods;
} MstlResult;

/**
 * Changepoint detection result (PELT algorithm).
 */
typedef struct ChangepointResult {
    /**
     * Array of changepoint indices
     */
    size_t *changepoints;
    /**
     * Number of changepoints detected
     */
    size_t n_changepoints;
    /**
     * Total cost of segmentation
     */
    double cost;
} ChangepointResult;

/**
 * BOCPD changepoint detection result.
 * C++ API compatible: per-point is_changepoint and changepoint_probability.
 */
typedef struct BocpdResult {
    /**
     * Array of is_changepoint flags (one per input point)
     */
    bool *is_changepoint;
    /**
     * Array of changepoint probabilities (one per input point)
     */
    double *changepoint_probability;
    /**
     * Number of input points
     */
    size_t n_points;
    /**
     * Array of changepoint indices (convenience)
     */
    size_t *changepoint_indices;
    /**
     * Number of detected changepoints
     */
    size_t n_changepoints;
} BocpdResult;

/**
 * Feature extraction result.
 */
typedef struct FeaturesResult {
    /**
     * Array of feature values
     */
    double *features;
    /**
     * Array of feature name pointers
     */
    char **feature_names;
    /**
     * Number of features
     */
    size_t n_features;
} FeaturesResult;

/**
 * Forecast options.
 */
typedef struct ForecastOptions {
    /**
     * Model name (null-terminated string)
     */
    char model[32];
    /**
     * Forecast horizon
     */
    int horizon;
    /**
     * Confidence level (0-1)
     */
    double confidence_level;
    /**
     * Seasonal period (0 = auto-detect)
     */
    int seasonal_period;
    /**
     * Whether to auto-detect seasonality
     */
    bool auto_detect_seasonality;
    /**
     * Include in-sample fitted values
     */
    bool include_fitted;
    /**
     * Include residuals
     */
    bool include_residuals;
} ForecastOptions;

/**
 * Forecast result structure.
 */
typedef struct ForecastResult {
    /**
     * Point forecasts array
     */
    double *point_forecasts;
    /**
     * Lower confidence bounds
     */
    double *lower_bounds;
    /**
     * Upper confidence bounds
     */
    double *upper_bounds;
    /**
     * In-sample fitted values
     */
    double *fitted_values;
    /**
     * Residuals
     */
    double *residuals;
    /**
     * Number of forecast points
     */
    size_t n_forecasts;
    /**
     * Number of fitted values
     */
    size_t n_fitted;
    /**
     * Model name
     */
    char model_name[64];
    /**
     * AIC (Akaike Information Criterion)
     */
    double aic;
    /**
     * BIC (Bayesian Information Criterion)
     */
    double bic;
    /**
     * Mean Squared Error
     */
    double mse;
} ForecastResult;

/**
 * Data quality result (per-series).
 */
typedef struct DataQualityResult {
    /**
     * Structural dimension score
     */
    double structural_score;
    /**
     * Temporal dimension score
     */
    double temporal_score;
    /**
     * Magnitude dimension score
     */
    double magnitude_score;
    /**
     * Behavioral dimension score
     */
    double behavioral_score;
    /**
     * Overall quality score
     */
    double overall_score;
    /**
     * Number of gaps
     */
    size_t n_gaps;
    /**
     * Number of missing values
     */
    size_t n_missing;
    /**
     * Is constant series
     */
    bool is_constant;
} DataQualityResult;

/**
 * Gap fill result containing dates and values with filled gaps.
 */
typedef struct GapFillResult {
    /**
     * Array of filled date values
     */
    int64_t *dates;
    /**
     * Array of filled values
     */
    double *values;
    /**
     * Validity bitmask for filled values (bit i indicates if values[i] is valid)
     */
    uint64_t *validity;
    /**
     * Number of observations after gap filling
     */
    size_t length;
} GapFillResult;

/**
 * Filled values result (for imputation functions that return values with validity).
 */
typedef struct FilledValuesResult {
    /**
     * Array of filled values
     */
    double *values;
    /**
     * Validity bitmask (bit i indicates if values[i] is valid)
     */
    uint64_t *validity;
    /**
     * Number of values
     */
    size_t length;
} FilledValuesResult;

/**
 * Nullable data array for DuckDB integration.
 *
 * The validity bitmask follows DuckDB's convention where bit i of validity[i/64]
 * indicates if element i is valid (1) or NULL (0).
 */
typedef struct DataArray {
    /**
     * Pointer to the data values
     */
    const double *data;
    /**
     * Pointer to validity bitmask (NULL means all valid)
     */
    const uint64_t *validity;
    /**
     * Number of elements
     */
    size_t length;
} DataArray;

/**
 * Date array supporting multiple date types.
 */
typedef struct DateArray {
    /**
     * Pointer to date values (interpretation depends on date_type)
     */
    const int64_t *data;
    /**
     * Pointer to validity bitmask
     */
    const uint64_t *validity;
    /**
     * Number of elements
     */
    size_t length;
    /**
     * Type of date values
     */
    enum DateType date_type;
} DateArray;

/**
 * Quality report result.
 */
typedef struct QualityReportResult {
    /**
     * Number of series passing all checks
     */
    size_t n_passed;
    /**
     * Number of series with gap issues
     */
    size_t n_gap_issues;
    /**
     * Number of series with missing value issues
     */
    size_t n_missing_issues;
    /**
     * Number of constant series
     */
    size_t n_constant;
    /**
     * Total series analyzed
     */
    size_t n_total;
} QualityReportResult;

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/**
 * Compute time series statistics.
 *
 * # Safety
 * All pointer arguments must be valid and non-null. Arrays must have the specified lengths.
 */
bool anofox_ts_stats(const double *values,
                     const uint64_t *validity,
                     size_t length,
                     struct TsStatsResult *out_result,
                     struct AnofoxError *out_error);

/**
 * Mean Absolute Error
 *
 * # Safety
 * All pointer arguments must be valid and non-null. Arrays must have the specified lengths.
 */
bool anofox_ts_mae(const double *actual,
                   size_t actual_len,
                   const double *forecast,
                   size_t forecast_len,
                   double *out_result,
                   struct AnofoxError *out_error);

/**
 * Mean Squared Error
 *
 * # Safety
 * All pointer arguments must be valid and non-null. Arrays must have the specified lengths.
 */
bool anofox_ts_mse(const double *actual,
                   size_t actual_len,
                   const double *forecast,
                   size_t forecast_len,
                   double *out_result,
                   struct AnofoxError *out_error);

/**
 * Root Mean Squared Error
 *
 * # Safety
 * All pointer arguments must be valid and non-null. Arrays must have the specified lengths.
 */
bool anofox_ts_rmse(const double *actual,
                    size_t actual_len,
                    const double *forecast,
                    size_t forecast_len,
                    double *out_result,
                    struct AnofoxError *out_error);

/**
 * Mean Absolute Percentage Error
 *
 * # Safety
 * All pointer arguments must be valid and non-null. Arrays must have the specified lengths.
 */
bool anofox_ts_mape(const double *actual,
                    size_t actual_len,
                    const double *forecast,
                    size_t forecast_len,
                    double *out_result,
                    struct AnofoxError *out_error);

/**
 * Symmetric Mean Absolute Percentage Error
 *
 * # Safety
 * All pointer arguments must be valid and non-null. Arrays must have the specified lengths.
 */
bool anofox_ts_smape(const double *actual,
                     size_t actual_len,
                     const double *forecast,
                     size_t forecast_len,
                     double *out_result,
                     struct AnofoxError *out_error);

/**
 * R-squared (Coefficient of Determination)
 *
 * # Safety
 * All pointer arguments must be valid and non-null. Arrays must have the specified lengths.
 */
bool anofox_ts_r2(const double *actual,
                  size_t actual_len,
                  const double *forecast,
                  size_t forecast_len,
                  double *out_result,
                  struct AnofoxError *out_error);

/**
 * Bias (Mean Error)
 *
 * # Safety
 * All pointer arguments must be valid and non-null. Arrays must have the specified lengths.
 */
bool anofox_ts_bias(const double *actual,
                    size_t actual_len,
                    const double *forecast,
                    size_t forecast_len,
                    double *out_result,
                    struct AnofoxError *out_error);

/**
 * Relative MAE comparing two models.
 *
 * # Safety
 * All pointer arguments must be valid and non-null. Arrays must have the specified lengths.
 */
bool anofox_ts_rmae(const double *actual,
                    size_t actual_len,
                    const double *pred1,
                    size_t pred1_len,
                    const double *pred2,
                    size_t pred2_len,
                    double *out_result,
                    struct AnofoxError *out_error);

/**
 * Mean Absolute Scaled Error.
 *
 * # Safety
 * All pointer arguments must be valid and non-null. Arrays must have the specified lengths.
 */
bool anofox_ts_mase(const double *actual,
                    size_t actual_len,
                    const double *forecast,
                    size_t forecast_len,
                    const double *baseline,
                    size_t baseline_len,
                    double *out_result,
                    struct AnofoxError *out_error);

/**
 * Quantile loss function.
 *
 * # Safety
 * All pointer arguments must be valid and non-null. Arrays must have the specified lengths.
 */
bool anofox_ts_quantile_loss(const double *actual,
                             size_t actual_len,
                             const double *forecast,
                             size_t forecast_len,
                             double quantile,
                             double *out_result,
                             struct AnofoxError *out_error);

/**
 * Multi-quantile loss function.
 *
 * # Safety
 * All pointer arguments must be valid and non-null. Arrays must have the specified lengths.
 * quantiles is a 2D array: n_levels arrays, each of length actual_len.
 */
bool anofox_ts_mqloss(const double *actual,
                      size_t actual_len,
                      const double *const *quantiles,
                      size_t n_levels,
                      const double *levels,
                      double *out_result,
                      struct AnofoxError *out_error);

/**
 * Coverage of prediction intervals.
 *
 * # Safety
 * All pointer arguments must be valid and non-null. Arrays must have the specified lengths.
 */
bool anofox_ts_coverage(const double *actual,
                        size_t actual_len,
                        const double *lower,
                        const double *upper,
                        double *out_result,
                        struct AnofoxError *out_error);

/**
 * Detect seasonal periods in a time series.
 *
 * # Safety
 * All pointer arguments must be valid and non-null. Arrays must have the specified lengths.
 */
bool anofox_ts_detect_seasonality(const double *values,
                                  size_t length,
                                  int max_period,
                                  int **out_periods,
                                  size_t *out_n_periods,
                                  struct AnofoxError *out_error);

/**
 * Analyze seasonality in a time series.
 *
 * # Safety
 * All pointer arguments must be valid and non-null. Arrays must have the specified lengths.
 * Note: timestamps parameter is for API compatibility but is ignored internally.
 */
bool anofox_ts_analyze_seasonality(const int64_t *_timestamps,
                                   size_t _timestamps_len,
                                   const double *values,
                                   size_t length,
                                   int max_period,
                                   struct SeasonalityResult *out_result,
                                   struct AnofoxError *out_error);

/**
 * MSTL decomposition.
 *
 * # Safety
 * All pointer arguments must be valid and non-null. Arrays must have the specified lengths.
 */
bool anofox_ts_mstl_decomposition(const double *values,
                                  size_t length,
                                  const int *periods,
                                  size_t n_periods,
                                  struct MstlResult *out_result,
                                  struct AnofoxError *out_error);

/**
 * Detect changepoints using PELT algorithm.
 *
 * # Safety
 * All pointer arguments must be valid and non-null. Arrays must have the specified lengths.
 */
bool anofox_ts_detect_changepoints(const double *values,
                                   size_t length,
                                   int min_size,
                                   double penalty,
                                   struct ChangepointResult *out_result,
                                   struct AnofoxError *out_error);

/**
 * BOCPD changepoint detection.
 *
 * # Safety
 * All pointer arguments must be valid and non-null. Arrays must have the specified lengths.
 */
bool anofox_ts_detect_changepoints_bocpd(const double *values,
                                         size_t length,
                                         double hazard_lambda,
                                         bool include_probabilities,
                                         struct BocpdResult *out_result,
                                         struct AnofoxError *out_error);

/**
 * Extract time series features.
 *
 * # Safety
 * All pointer arguments must be valid and non-null. Arrays must have the specified lengths.
 */
bool anofox_ts_features(const double *values,
                        size_t length,
                        struct FeaturesResult *out_result,
                        struct AnofoxError *out_error);

/**
 * List available feature names.
 *
 * # Safety
 * All pointer arguments must be valid and non-null.
 */
bool anofox_ts_features_list(char **out_names, size_t *out_count);

/**
 * Generate forecasts for a time series.
 *
 * # Safety
 * All pointer arguments must be valid and non-null. Arrays must have the specified lengths.
 */
bool anofox_ts_forecast(const double *values,
                        const uint64_t *validity,
                        size_t length,
                        const struct ForecastOptions *options,
                        struct ForecastResult *out_result,
                        struct AnofoxError *out_error);

/**
 * Compute data quality metrics.
 *
 * # Safety
 * All pointer arguments must be valid and non-null. Arrays must have the specified lengths.
 */
bool anofox_ts_data_quality(const double *values,
                            const uint64_t *validity,
                            size_t length,
                            struct DataQualityResult *out_result,
                            struct AnofoxError *out_error);

/**
 * Fill NULL values with a constant.
 *
 * # Safety
 * All pointer arguments must be valid and non-null. Arrays must have the specified lengths.
 */
bool anofox_ts_fill_nulls_const(const double *values,
                                const uint64_t *validity,
                                size_t length,
                                double fill_value,
                                double **out_values,
                                struct AnofoxError *out_error);

/**
 * Fill NULL values with the series mean.
 *
 * # Safety
 * All pointer arguments must be valid and non-null. Arrays must have the specified lengths.
 */
bool anofox_ts_fill_nulls_mean(const double *values,
                               const uint64_t *validity,
                               size_t length,
                               double **out_values,
                               struct AnofoxError *out_error);

/**
 * Compute differences of a time series.
 *
 * # Safety
 * All pointer arguments must be valid and non-null. Arrays must have the specified lengths.
 */
bool anofox_ts_diff(const double *values,
                    size_t length,
                    int order,
                    double **out_values,
                    size_t *out_length,
                    struct AnofoxError *out_error);

/**
 * Fill gaps in a time series with new timestamps.
 *
 * # Safety
 * All pointer arguments must be valid and non-null. Arrays must have the specified lengths.
 */
bool anofox_ts_fill_gaps(const int64_t *dates,
                         const double *values,
                         const uint64_t *validity,
                         size_t length,
                         int64_t frequency_seconds,
                         struct GapFillResult *out_result,
                         struct AnofoxError *out_error);

/**
 * Fill forward to a target date.
 *
 * # Safety
 * All pointer arguments must be valid and non-null. Arrays must have the specified lengths.
 */
bool anofox_ts_fill_forward_dates(const int64_t *dates,
                                  const double *values,
                                  const uint64_t *validity,
                                  size_t length,
                                  int64_t target_date,
                                  int64_t frequency_seconds,
                                  struct GapFillResult *out_result,
                                  struct AnofoxError *out_error);

/**
 * Detect the frequency of a time series.
 *
 * # Safety
 * All pointer arguments must be valid and non-null. Arrays must have the specified lengths.
 */
bool anofox_ts_detect_frequency(const int64_t *dates,
                                size_t length,
                                int64_t *out_frequency,
                                struct AnofoxError *out_error);

/**
 * Fill NULL values with forward fill.
 *
 * # Safety
 * All pointer arguments must be valid and non-null. Arrays must have the specified lengths.
 */
bool anofox_ts_fill_nulls_forward(const double *values,
                                  const uint64_t *validity,
                                  size_t length,
                                  struct FilledValuesResult *out_result,
                                  struct AnofoxError *out_error);

/**
 * Fill NULL values with backward fill.
 *
 * # Safety
 * All pointer arguments must be valid and non-null. Arrays must have the specified lengths.
 */
bool anofox_ts_fill_nulls_backward(const double *values,
                                   const uint64_t *validity,
                                   size_t length,
                                   struct FilledValuesResult *out_result,
                                   struct AnofoxError *out_error);

/**
 * Fill NULL values with linear interpolation.
 *
 * # Safety
 * All pointer arguments must be valid and non-null. Arrays must have the specified lengths.
 */
bool anofox_ts_fill_nulls_interpolate(const double *values,
                                      const uint64_t *validity,
                                      size_t length,
                                      double **out_values,
                                      struct AnofoxError *out_error);

/**
 * Free a TsStatsResult.
 *
 * # Safety
 * The result pointer must be valid or null.
 */
void anofox_free_ts_stats_result(struct TsStatsResult *_result);

/**
 * Free a GapFillResult.
 *
 * # Safety
 * The result pointer must be valid or null.
 */
void anofox_free_gap_fill_result(struct GapFillResult *result);

/**
 * Free a FilledValuesResult.
 *
 * # Safety
 * The result pointer must be valid or null.
 */
void anofox_free_filled_values_result(struct FilledValuesResult *result);

/**
 * Free a ForecastResult.
 *
 * # Safety
 * The result pointer must be valid or null.
 */
void anofox_free_forecast_result(struct ForecastResult *result);

/**
 * Free a ChangepointResult.
 *
 * # Safety
 * The result pointer must be valid or null.
 */
void anofox_free_changepoint_result(struct ChangepointResult *result);

/**
 * Free a BocpdResult.
 *
 * # Safety
 * The result pointer must be valid or null.
 */
void anofox_free_bocpd_result(struct BocpdResult *result);

/**
 * Free a FeaturesResult.
 *
 * # Safety
 * The result pointer must be valid or null.
 */
void anofox_free_features_result(struct FeaturesResult *result);

/**
 * Free a SeasonalityResult.
 *
 * # Safety
 * The result pointer must be valid or null.
 */
void anofox_free_seasonality_result(struct SeasonalityResult *result);

/**
 * Free a MstlResult.
 *
 * # Safety
 * The result pointer must be valid or null.
 */
void anofox_free_mstl_result(struct MstlResult *result);

/**
 * Free a double array.
 *
 * # Safety
 * The pointer must be valid or null.
 */
void anofox_free_double_array(double *ptr);

/**
 * Free an int array.
 *
 * # Safety
 * The pointer must be valid or null.
 */
void anofox_free_int_array(int *ptr);

const char *anofox_fcst_version(void);

#ifdef __cplusplus
}  // extern "C"
#endif  // __cplusplus

#endif  /* ANOFOX_FCST_FFI_H */
