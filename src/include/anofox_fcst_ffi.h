#ifndef ANOFOX_FCST_FFI_H
#define ANOFOX_FCST_FFI_H

#pragma once

/* Warning: this file is autogenerated by cbindgen. Don't modify this manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

/**
 * Conformal method enumeration for FFI.
 */
typedef enum ConformalMethodFFI {
    /**
     * Symmetric intervals using absolute residuals
     */
    SYMMETRIC = 0,
    /**
     * Asymmetric intervals using separate quantiles for positive/negative residuals
     */
    ASYMMETRIC = 1,
    /**
     * Adaptive intervals scaled by difficulty scores
     */
    ADAPTIVE = 2,
} ConformalMethodFFI;

/**
 * Conformal strategy enumeration for FFI.
 *
 * The strategy determines how residuals are used for calibration.
 */
typedef enum ConformalStrategyFFI {
    /**
     * Split conformal - uses calibration residuals directly
     */
    SPLIT = 0,
    /**
     * Cross-validation conformal - uses CV residuals
     */
    CROSS_VAL = 1,
    /**
     * Jackknife+ conformal - stores full residual distribution
     */
    JACKKNIFE_PLUS = 2,
} ConformalStrategyFFI;

/**
 * Date type enumeration for handling different DuckDB date types.
 */
typedef enum DateType {
    /**
     * Days since epoch (1970-01-01)
     */
    DATE = 0,
    /**
     * Microseconds since epoch
     */
    TIMESTAMP = 1,
    /**
     * Generic integer periods
     */
    INTEGER = 2,
} DateType;

/**
 * Method for computing difficulty scores (FFI version).
 */
typedef enum DifficultyMethodFFI {
    /**
     * Rolling standard deviation of percent changes (returns)
     */
    VOLATILITY = 0,
    /**
     * Changepoint probability from Bayesian Online Changepoint Detection
     */
    CHANGEPOINT_PROB = 1,
    /**
     * Rolling standard deviation of raw values
     */
    ROLLING_STD = 2,
} DifficultyMethodFFI;

/**
 * Error codes for FFI boundary.
 */
typedef enum ErrorCode {
    SUCCESS = 0,
    NULL_POINTER = 1,
    INVALID_INPUT = 2,
    COMPUTATION_ERROR = 3,
    ALLOCATION_ERROR = 4,
    INVALID_MODEL = 5,
    INSUFFICIENT_DATA = 6,
    INVALID_DATE_FORMAT = 7,
    INVALID_FREQUENCY = 8,
    PANIC_CAUGHT = 9,
    INTERNAL_ERROR = 10,
} ErrorCode;

/**
 * Time series statistics result (34 metrics).
 */
typedef struct TsStatsResult {
    /**
     * Total number of observations
     */
    size_t length;
    /**
     * Number of NULL values
     */
    size_t n_nulls;
    /**
     * Number of NaN values (distinct from NULL)
     */
    size_t n_nan;
    /**
     * Number of zero values
     */
    size_t n_zeros;
    /**
     * Number of positive values
     */
    size_t n_positive;
    /**
     * Number of negative values
     */
    size_t n_negative;
    /**
     * Count of distinct values
     */
    size_t n_unique_values;
    /**
     * Whether series has only one unique value
     */
    bool is_constant;
    /**
     * Count of leading zeros
     */
    size_t n_zeros_start;
    /**
     * Count of trailing zeros
     */
    size_t n_zeros_end;
    /**
     * Longest run of constant values
     */
    size_t plateau_size;
    /**
     * Longest run of constant non-zero values
     */
    size_t plateau_size_nonzero;
    /**
     * Arithmetic mean
     */
    double mean;
    /**
     * Median (50th percentile)
     */
    double median;
    /**
     * Standard deviation
     */
    double std_dev;
    /**
     * Variance
     */
    double variance;
    /**
     * Minimum value
     */
    double min;
    /**
     * Maximum value
     */
    double max;
    /**
     * Range (max - min)
     */
    double range;
    /**
     * Sum of all values
     */
    double sum;
    /**
     * Skewness
     */
    double skewness;
    /**
     * Kurtosis
     */
    double kurtosis;
    /**
     * Tail index (Hill estimator)
     */
    double tail_index;
    /**
     * Bimodality coefficient
     */
    double bimodality_coef;
    /**
     * Trimmed mean (10% trimmed)
     */
    double trimmed_mean;
    /**
     * Coefficient of variation
     */
    double coef_variation;
    /**
     * First quartile
     */
    double q1;
    /**
     * Third quartile
     */
    double q3;
    /**
     * Interquartile range
     */
    double iqr;
    /**
     * Autocorrelation at lag 1
     */
    double autocorr_lag1;
    /**
     * Trend strength (0-1)
     */
    double trend_strength;
    /**
     * Seasonality strength (0-1)
     */
    double seasonality_strength;
    /**
     * Approximate entropy
     */
    double entropy;
    /**
     * Stability measure
     */
    double stability;
    /**
     * Expected number of observations based on date range and frequency
     */
    size_t expected_length;
    /**
     * Number of gaps (missing time periods) in the series
     */
    size_t n_gaps;
    /**
     * Whether date-based metrics (expected_length, n_gaps) are valid
     */
    bool has_date_metrics;
} TsStatsResult;

/**
 * Error structure with message buffer for FFI.
 */
typedef struct AnofoxError {
    enum ErrorCode code;
    char message[256];
} AnofoxError;

/**
 * Seasonality analysis result.
 * C++ API compatible field names.
 */
typedef struct SeasonalityResult {
    /**
     * Array of detected periods (C++ name: detected_periods)
     */
    int *detected_periods;
    /**
     * Number of detected periods
     */
    size_t n_periods;
    /**
     * Primary (dominant) period (C++ name: primary_period)
     */
    int primary_period;
    /**
     * Seasonal strength (0-1)
     */
    double seasonal_strength;
    /**
     * Trend strength (0-1)
     */
    double trend_strength;
} SeasonalityResult;

/**
 * A detected period from multiple period detection.
 */
typedef struct DetectedPeriodFFI {
    /**
     * Estimated period (in samples)
     */
    double period;
    /**
     * Confidence measure
     */
    double confidence;
    /**
     * Seasonal strength at this period
     */
    double strength;
    /**
     * Amplitude of the sinusoidal component
     */
    double amplitude;
    /**
     * Phase of the sinusoidal component (radians)
     */
    double phase;
    /**
     * Iteration number (1-indexed)
     */
    size_t iteration;
} DetectedPeriodFFI;

/**
 * Result from multiple period detection.
 */
typedef struct MultiPeriodResult {
    /**
     * Array of detected periods
     */
    struct DetectedPeriodFFI *periods;
    /**
     * Number of detected periods
     */
    size_t n_periods;
    /**
     * Primary (strongest) period
     */
    double primary_period;
    /**
     * Method used for estimation
     */
    char method[32];
} MultiPeriodResult;

/**
 * Flattened result from multiple period detection.
 *
 * Uses parallel arrays instead of nested struct array for safer FFI.
 * This avoids memory management issues when crossing the Rust/C++ boundary,
 * particularly with R's DuckDB bindings.
 */
typedef struct FlatMultiPeriodResult {
    /**
     * Array of period values (in samples)
     */
    double *period_values;
    /**
     * Array of confidence values
     */
    double *confidence_values;
    /**
     * Array of strength values
     */
    double *strength_values;
    /**
     * Array of amplitude values
     */
    double *amplitude_values;
    /**
     * Array of phase values (radians)
     */
    double *phase_values;
    /**
     * Array of iteration values (1-indexed)
     */
    size_t *iteration_values;
    /**
     * Number of detected periods
     */
    size_t n_periods;
    /**
     * Primary (strongest) period
     */
    double primary_period;
    /**
     * Method used for estimation
     */
    char method[32];
} FlatMultiPeriodResult;

/**
 * Result from single period estimation.
 */
typedef struct SinglePeriodResult {
    /**
     * Estimated period (in samples)
     */
    double period;
    /**
     * Dominant frequency (1/period)
     */
    double frequency;
    /**
     * Power at the dominant frequency
     */
    double power;
    /**
     * Confidence measure
     */
    double confidence;
    /**
     * Method used for estimation
     */
    char method[32];
} SinglePeriodResult;

/**
 * Result from autoperiod detection.
 *
 * Combines FFT period estimation with ACF validation.
 */
typedef struct AutoperiodResultFFI {
    /**
     * Detected period (in samples)
     */
    double period;
    /**
     * FFT confidence (ratio of peak power to mean power)
     */
    double fft_confidence;
    /**
     * ACF validation score (correlation at the detected period)
     */
    double acf_validation;
    /**
     * Whether the period was detected (acf_validation > threshold)
     */
    bool detected;
    /**
     * Method used ("autoperiod" or "cfd_autoperiod")
     */
    char method[32];
} AutoperiodResultFFI;

/**
 * Result from Lomb-Scargle periodogram.
 *
 * Lomb-Scargle is optimal for detecting periodic signals in unevenly
 * sampled data and provides statistical significance via false alarm probability.
 */
typedef struct LombScargleResultFFI {
    /**
     * Detected period (in samples)
     */
    double period;
    /**
     * Frequency corresponding to the peak
     */
    double frequency;
    /**
     * Power at the peak frequency (normalized)
     */
    double power;
    /**
     * False alarm probability (lower = more significant)
     */
    double false_alarm_prob;
    /**
     * Method identifier
     */
    char method[32];
} LombScargleResultFFI;

/**
 * Result from AIC-based period comparison.
 */
typedef struct AicPeriodResultFFI {
    /**
     * Best period according to AIC
     */
    double period;
    /**
     * AIC value for the best model
     */
    double aic;
    /**
     * BIC value for the best model
     */
    double bic;
    /**
     * Residual sum of squares for the best model
     */
    double rss;
    /**
     * R-squared for the best model
     */
    double r_squared;
    /**
     * Method identifier
     */
    char method[32];
} AicPeriodResultFFI;

/**
 * Result from SSA period detection.
 */
typedef struct SsaPeriodResultFFI {
    /**
     * Primary detected period
     */
    double period;
    /**
     * Variance explained by the primary periodic component
     */
    double variance_explained;
    /**
     * Number of eigenvalues returned
     */
    size_t n_eigenvalues;
    /**
     * Method identifier
     */
    char method[32];
} SsaPeriodResultFFI;

/**
 * Result from STL-based period detection.
 */
typedef struct StlPeriodResultFFI {
    /**
     * Best detected period
     */
    double period;
    /**
     * Seasonal strength at the best period (0-1)
     */
    double seasonal_strength;
    /**
     * Trend strength (0-1)
     */
    double trend_strength;
    /**
     * Method identifier
     */
    char method[32];
} StlPeriodResultFFI;

/**
 * Result from Matrix Profile period detection.
 */
typedef struct MatrixProfilePeriodResultFFI {
    /**
     * Detected period (most common motif distance)
     */
    double period;
    /**
     * Confidence based on peak prominence in lag histogram
     */
    double confidence;
    /**
     * Number of motif pairs found
     */
    size_t n_motifs;
    /**
     * Subsequence length used
     */
    size_t subsequence_length;
    /**
     * Method identifier
     */
    char method[32];
} MatrixProfilePeriodResultFFI;

/**
 * Result from SAZED period detection.
 */
typedef struct SazedPeriodResultFFI {
    /**
     * Primary detected period
     */
    double period;
    /**
     * Spectral power at the detected period
     */
    double power;
    /**
     * Signal-to-noise ratio
     */
    double snr;
    /**
     * Method identifier
     */
    char method[32];
} SazedPeriodResultFFI;

/**
 * A detected peak in the time series.
 */
typedef struct PeakFFI {
    /**
     * Index at which the peak occurs
     */
    size_t index;
    /**
     * Time at which the peak occurs
     */
    double time;
    /**
     * Value at the peak
     */
    double value;
    /**
     * Prominence of the peak
     */
    double prominence;
} PeakFFI;

/**
 * Result of peak detection.
 */
typedef struct PeakDetectionResultFFI {
    /**
     * Array of detected peaks
     */
    struct PeakFFI *peaks;
    /**
     * Number of peaks detected
     */
    size_t n_peaks;
    /**
     * Inter-peak distances
     */
    double *inter_peak_distances;
    /**
     * Number of inter-peak distances
     */
    size_t n_distances;
    /**
     * Mean period estimated from inter-peak distances
     */
    double mean_period;
} PeakDetectionResultFFI;

/**
 * Result of peak timing variability analysis.
 */
typedef struct PeakTimingResultFFI {
    /**
     * Peak times for each cycle
     */
    double *peak_times;
    /**
     * Peak values
     */
    double *peak_values;
    /**
     * Normalized timing (0-1 scale)
     */
    double *normalized_timing;
    /**
     * Number of peaks
     */
    size_t n_peaks;
    /**
     * Mean normalized timing
     */
    double mean_timing;
    /**
     * Standard deviation of normalized timing
     */
    double std_timing;
    /**
     * Range of normalized timing
     */
    double range_timing;
    /**
     * Variability score (0 = stable, 1 = highly variable)
     */
    double variability_score;
    /**
     * Trend in timing
     */
    double timing_trend;
    /**
     * Whether timing is considered stable
     */
    bool is_stable;
} PeakTimingResultFFI;

/**
 * Result of detrending operation.
 */
typedef struct DetrendResultFFI {
    /**
     * Estimated trend values
     */
    double *trend;
    /**
     * Detrended data
     */
    double *detrended;
    /**
     * Number of values
     */
    size_t length;
    /**
     * Method used for detrending
     */
    char method[32];
    /**
     * Polynomial coefficients (may be NULL)
     */
    double *coefficients;
    /**
     * Number of coefficients
     */
    size_t n_coefficients;
    /**
     * Residual sum of squares
     */
    double rss;
    /**
     * Number of parameters
     */
    size_t n_params;
} DetrendResultFFI;

/**
 * Result of seasonal decomposition.
 */
typedef struct DecomposeResultFFI {
    /**
     * Trend component
     */
    double *trend;
    /**
     * Seasonal component
     */
    double *seasonal;
    /**
     * Remainder/residual component
     */
    double *remainder;
    /**
     * Number of observations
     */
    size_t length;
    /**
     * Period used for decomposition
     */
    double period;
    /**
     * Decomposition method ("additive" or "multiplicative")
     */
    char method[32];
} DecomposeResultFFI;

/**
 * Result of seasonality classification.
 */
typedef struct SeasonalityClassificationFFI {
    /**
     * Whether series is classified as seasonal
     */
    bool is_seasonal;
    /**
     * Whether timing is stable across cycles
     */
    bool has_stable_timing;
    /**
     * Timing variability measure
     */
    double timing_variability;
    /**
     * Overall seasonal strength
     */
    double seasonal_strength;
    /**
     * Per-cycle seasonal strength
     */
    double *cycle_strengths;
    /**
     * Number of cycle strengths
     */
    size_t n_cycle_strengths;
    /**
     * Indices of weak/missing seasons
     */
    size_t *weak_seasons;
    /**
     * Number of weak seasons
     */
    size_t n_weak_seasons;
    /**
     * Classification type (stable, variable, intermittent, absent)
     */
    char classification[32];
} SeasonalityClassificationFFI;

/**
 * Seasonality change point.
 */
typedef struct SeasonalityChangePointFFI {
    /**
     * Index at which change occurs
     */
    size_t index;
    /**
     * Time at which change occurs
     */
    double time;
    /**
     * Type of change (onset, cessation)
     */
    char change_type[32];
    /**
     * Strength before change
     */
    double strength_before;
    /**
     * Strength after change
     */
    double strength_after;
} SeasonalityChangePointFFI;

/**
 * Result of seasonality change detection.
 */
typedef struct ChangeDetectionResultFFI {
    /**
     * Array of detected change points
     */
    struct SeasonalityChangePointFFI *change_points;
    /**
     * Number of change points
     */
    size_t n_changes;
    /**
     * Time-varying seasonal strength curve
     */
    double *strength_curve;
    /**
     * Number of strength curve values
     */
    size_t n_strength_curve;
} ChangeDetectionResultFFI;

/**
 * Result of instantaneous period estimation.
 */
typedef struct InstantaneousPeriodResultFFI {
    /**
     * Instantaneous period at each time point
     */
    double *periods;
    /**
     * Instantaneous frequency at each time point
     */
    double *frequencies;
    /**
     * Instantaneous amplitude (envelope) at each time point
     */
    double *amplitudes;
    /**
     * Number of values
     */
    size_t length;
} InstantaneousPeriodResultFFI;

/**
 * Result of amplitude modulation detection.
 */
typedef struct AmplitudeModulationResultFFI {
    /**
     * Whether seasonality is present
     */
    bool is_seasonal;
    /**
     * Overall seasonal strength
     */
    double seasonal_strength;
    /**
     * Whether amplitude modulation is detected
     */
    bool has_modulation;
    /**
     * Modulation type (stable, emerging, fading, oscillating, non_seasonal)
     */
    char modulation_type[32];
    /**
     * Coefficient of variation of wavelet amplitude
     */
    double modulation_score;
    /**
     * Trend in amplitude (-1 to 1)
     */
    double amplitude_trend;
    /**
     * Wavelet amplitude at the seasonal frequency over time
     */
    double *wavelet_amplitude;
    /**
     * Time points corresponding to wavelet_amplitude
     */
    double *time_points;
    /**
     * Number of amplitude/time values
     */
    size_t n_points;
    /**
     * Scale (period) used for wavelet analysis
     */
    double scale;
} AmplitudeModulationResultFFI;

/**
 * MSTL decomposition result.
 */
typedef struct MstlResult {
    /**
     * Trend component (may be NULL if decomposition was skipped)
     */
    double *trend;
    /**
     * Array of seasonal component arrays (one per period)
     */
    double **seasonal_components;
    /**
     * Remainder (residual) component (may be NULL if decomposition was skipped)
     */
    double *remainder;
    /**
     * Number of observations
     */
    size_t n_observations;
    /**
     * Number of seasonal components
     */
    size_t n_seasonal;
    /**
     * Array of seasonal periods
     */
    int *seasonal_periods;
    /**
     * Whether decomposition was actually applied
     */
    bool decomposition_applied;
} MstlResult;

/**
 * Changepoint detection result (PELT algorithm).
 */
typedef struct ChangepointResult {
    /**
     * Array of changepoint indices
     */
    size_t *changepoints;
    /**
     * Number of changepoints detected
     */
    size_t n_changepoints;
    /**
     * Total cost of segmentation
     */
    double cost;
} ChangepointResult;

/**
 * BOCPD changepoint detection result.
 * C++ API compatible: per-point is_changepoint and changepoint_probability.
 */
typedef struct BocpdResult {
    /**
     * Array of is_changepoint flags (one per input point)
     */
    bool *is_changepoint;
    /**
     * Array of changepoint probabilities (one per input point)
     */
    double *changepoint_probability;
    /**
     * Number of input points
     */
    size_t n_points;
    /**
     * Array of changepoint indices (convenience)
     */
    size_t *changepoint_indices;
    /**
     * Number of detected changepoints
     */
    size_t n_changepoints;
} BocpdResult;

/**
 * Feature extraction result.
 */
typedef struct FeaturesResult {
    /**
     * Array of feature values
     */
    double *features;
    /**
     * Array of feature name pointers
     */
    char **feature_names;
    /**
     * Number of features
     */
    size_t n_features;
} FeaturesResult;

/**
 * Forecast options.
 */
typedef struct ForecastOptions {
    /**
     * Model name (null-terminated string)
     */
    char model[32];
    /**
     * ETS model specification (e.g., "AAA", "MNM", "AAdA")
     * Only used when model is "ETS". Empty string means use default (AAA).
     */
    char ets_model[8];
    /**
     * Forecast horizon
     */
    int horizon;
    /**
     * Confidence level (0-1)
     */
    double confidence_level;
    /**
     * Seasonal period (0 = auto-detect)
     */
    int seasonal_period;
    /**
     * Whether to auto-detect seasonality
     */
    bool auto_detect_seasonality;
    /**
     * Include in-sample fitted values
     */
    bool include_fitted;
    /**
     * Include residuals
     */
    bool include_residuals;
} ForecastOptions;

/**
 * Forecast result structure.
 */
typedef struct ForecastResult {
    /**
     * Point forecasts array
     */
    double *point_forecasts;
    /**
     * Lower confidence bounds
     */
    double *lower_bounds;
    /**
     * Upper confidence bounds
     */
    double *upper_bounds;
    /**
     * In-sample fitted values
     */
    double *fitted_values;
    /**
     * Residuals
     */
    double *residuals;
    /**
     * Number of forecast points
     */
    size_t n_forecasts;
    /**
     * Number of fitted values
     */
    size_t n_fitted;
    /**
     * Model name
     */
    char model_name[64];
    /**
     * AIC (Akaike Information Criterion)
     */
    double aic;
    /**
     * BIC (Bayesian Information Criterion)
     */
    double bic;
    /**
     * Mean Squared Error
     */
    double mse;
} ForecastResult;

/**
 * Exogenous regressor data for a single regressor.
 *
 * Each regressor is a column of values aligned with the time series observations.
 */
typedef struct ExogenousRegressor {
    /**
     * Pointer to the regressor values (historical, aligned with y values)
     */
    const double *values;
    /**
     * Number of historical values (must match y length)
     */
    size_t n_values;
    /**
     * Pointer to future regressor values (for forecast horizon)
     */
    const double *future_values;
    /**
     * Number of future values (must match horizon)
     */
    size_t n_future;
} ExogenousRegressor;

/**
 * Exogenous data containing multiple regressors.
 *
 * Used to pass historical X and future X values across the FFI boundary.
 * Layout: regressors[i] contains the i-th regressor's historical and future values.
 */
typedef struct ExogenousData {
    /**
     * Array of regressors
     */
    const struct ExogenousRegressor *regressors;
    /**
     * Number of regressors
     */
    size_t n_regressors;
} ExogenousData;

/**
 * Forecast options with exogenous variables support.
 */
typedef struct ForecastOptionsExog {
    /**
     * Model name (null-terminated string)
     */
    char model[32];
    /**
     * ETS model specification (e.g., "AAA", "MNM", "AAdA")
     * Only used when model is "ETS". Empty string means use default (AAA).
     */
    char ets_model[8];
    /**
     * Forecast horizon
     */
    int horizon;
    /**
     * Confidence level (0-1)
     */
    double confidence_level;
    /**
     * Seasonal period (0 = auto-detect)
     */
    int seasonal_period;
    /**
     * Whether to auto-detect seasonality
     */
    bool auto_detect_seasonality;
    /**
     * Include in-sample fitted values
     */
    bool include_fitted;
    /**
     * Include residuals
     */
    bool include_residuals;
    /**
     * Exogenous data (may be null if no exogenous variables)
     */
    const struct ExogenousData *exog;
} ForecastOptionsExog;

/**
 * Data quality result (per-series).
 */
typedef struct DataQualityResult {
    /**
     * Structural dimension score
     */
    double structural_score;
    /**
     * Temporal dimension score
     */
    double temporal_score;
    /**
     * Magnitude dimension score
     */
    double magnitude_score;
    /**
     * Behavioral dimension score
     */
    double behavioral_score;
    /**
     * Overall quality score
     */
    double overall_score;
    /**
     * Number of gaps
     */
    size_t n_gaps;
    /**
     * Number of missing values
     */
    size_t n_missing;
    /**
     * Is constant series
     */
    bool is_constant;
} DataQualityResult;

/**
 * Gap fill result containing dates and values with filled gaps.
 */
typedef struct GapFillResult {
    /**
     * Array of filled date values
     */
    int64_t *dates;
    /**
     * Array of filled values
     */
    double *values;
    /**
     * Validity bitmask for filled values (bit `i` indicates if `values[i]` is valid)
     */
    uint64_t *validity;
    /**
     * Number of observations after gap filling
     */
    size_t length;
} GapFillResult;

/**
 * Filled values result (for imputation functions that return values with validity).
 */
typedef struct FilledValuesResult {
    /**
     * Array of filled values
     */
    double *values;
    /**
     * Validity bitmask (bit `i` indicates if `values[i]` is valid)
     */
    uint64_t *validity;
    /**
     * Number of values
     */
    size_t length;
} FilledValuesResult;

/**
 * Result of conformal prediction with prediction intervals.
 */
typedef struct ConformalResultFFI {
    /**
     * Point forecasts
     */
    double *point;
    /**
     * Lower bounds of prediction intervals
     */
    double *lower;
    /**
     * Upper bounds of prediction intervals
     */
    double *upper;
    /**
     * Number of forecasts
     */
    size_t n_forecasts;
    /**
     * Nominal coverage level (1 - alpha)
     */
    double coverage;
    /**
     * The computed conformity score (quantile threshold)
     */
    double conformity_score;
    /**
     * Method used for conformal prediction
     */
    char method[32];
} ConformalResultFFI;

/**
 * Result of conformal prediction with multiple coverage levels.
 *
 * Uses a flattened structure for safer FFI. All arrays have length
 * `n_forecasts * n_levels`, with intervals stored level-by-level.
 */
typedef struct ConformalMultiResultFFI {
    /**
     * Point forecasts
     */
    double *point;
    /**
     * Number of point forecasts
     */
    size_t n_forecasts;
    /**
     * Coverage levels (one per level)
     */
    double *coverage_levels;
    /**
     * Conformity scores (one per level)
     */
    double *conformity_scores;
    /**
     * Number of coverage levels
     */
    size_t n_levels;
    /**
     * Flattened lower bounds (n_forecasts * n_levels, level-major order)
     */
    double *lower;
    /**
     * Flattened upper bounds (n_forecasts * n_levels, level-major order)
     */
    double *upper;
} ConformalMultiResultFFI;

/**
 * Calibration profile for conformal prediction (FFI version).
 *
 * Contains pre-computed conformity scores that can be reused.
 */
typedef struct CalibrationProfileFFI {
    /**
     * Method used (symmetric, asymmetric, adaptive)
     */
    enum ConformalMethodFFI method;
    /**
     * Strategy used (split, crossval, jackknife+)
     */
    enum ConformalStrategyFFI strategy;
    /**
     * Alpha values (miscoverage rates)
     */
    double *alphas;
    /**
     * State vector (strategy-specific):
     * - Split/CrossVal: [lower_q1, ..., upper_q1, ...]
     * - JackknifePlus: sorted absolute residuals
     */
    double *state_vector;
    /**
     * Length of state_vector
     */
    size_t state_vector_len;
    /**
     * Lower scores (one per alpha)
     */
    double *scores_lower;
    /**
     * Upper scores (one per alpha); same as lower for symmetric
     */
    double *scores_upper;
    /**
     * Number of alpha levels
     */
    size_t n_levels;
    /**
     * Number of residuals used for calibration
     */
    size_t n_residuals;
} CalibrationProfileFFI;

/**
 * Prediction intervals from applying a calibration profile (FFI version).
 *
 * Layout: lower/upper are flattened as [level0_forecasts..., level1_forecasts..., ...]
 */
typedef struct PredictionIntervalsFFI {
    /**
     * Point forecasts
     */
    double *point;
    /**
     * Number of forecasts
     */
    size_t n_forecasts;
    /**
     * Coverage levels (1 - alpha)
     */
    double *coverage;
    /**
     * Number of coverage levels
     */
    size_t n_levels;
    /**
     * Flattened lower bounds (n_levels * n_forecasts, level-major order)
     */
    double *lower;
    /**
     * Flattened upper bounds (n_levels * n_forecasts, level-major order)
     */
    double *upper;
    /**
     * Method used
     */
    enum ConformalMethodFFI method;
} PredictionIntervalsFFI;

/**
 * Conformal evaluation metrics (FFI version).
 */
typedef struct ConformalEvaluationFFI {
    /**
     * Empirical coverage (fraction within intervals)
     */
    double coverage;
    /**
     * Violation rate (fraction outside intervals, i.e., 1 - coverage)
     */
    double violation_rate;
    /**
     * Mean interval width
     */
    double mean_width;
    /**
     * Winkler score
     */
    double winkler_score;
    /**
     * Number of observations evaluated
     */
    size_t n_observations;
} ConformalEvaluationFFI;

/**
 * Result from difficulty score computation (FFI version).
 */
typedef struct DifficultyScoreResultFFI {
    /**
     * Array of difficulty scores (same length as input)
     */
    double *scores;
    /**
     * Number of scores
     */
    size_t length;
} DifficultyScoreResultFFI;

/**
 * Nullable data array for DuckDB integration.
 *
 * The validity bitmask follows DuckDB's convention where bit i of validity[i/64]
 * indicates if element i is valid (1) or NULL (0).
 */
typedef struct DataArray {
    /**
     * Pointer to the data values
     */
    const double *data;
    /**
     * Pointer to validity bitmask (NULL means all valid)
     */
    const uint64_t *validity;
    /**
     * Number of elements
     */
    size_t length;
} DataArray;

/**
 * Date array supporting multiple date types.
 */
typedef struct DateArray {
    /**
     * Pointer to date values (interpretation depends on date_type)
     */
    const int64_t *data;
    /**
     * Pointer to validity bitmask
     */
    const uint64_t *validity;
    /**
     * Number of elements
     */
    size_t length;
    /**
     * Type of date values
     */
    enum DateType date_type;
} DateArray;

/**
 * Quality report result.
 */
typedef struct QualityReportResult {
    /**
     * Number of series passing all checks
     */
    size_t n_passed;
    /**
     * Number of series with gap issues
     */
    size_t n_gap_issues;
    /**
     * Number of series with missing value issues
     */
    size_t n_missing_issues;
    /**
     * Number of constant series
     */
    size_t n_constant;
    /**
     * Total series analyzed
     */
    size_t n_total;
} QualityReportResult;

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/**
 * Compute time series statistics.
 *
 * # Safety
 * All pointer arguments must be valid and non-null. Arrays must have the specified lengths.
 */
bool anofox_ts_stats(const double *values,
                     const uint64_t *validity,
                     size_t length,
                     struct TsStatsResult *out_result,
                     struct AnofoxError *out_error);

/**
 * Compute time series statistics with date information for gap detection.
 *
 * # Safety
 * All pointer arguments must be valid and non-null. Arrays must have the specified lengths.
 * The dates array must have the same length as the values array.
 */
bool anofox_ts_stats_with_dates(const double *values,
                                const uint64_t *validity,
                                const int64_t *dates,
                                size_t length,
                                int64_t frequency_micros,
                                struct TsStatsResult *out_result,
                                struct AnofoxError *out_error);

/**
 * Mean Absolute Error
 *
 * # Safety
 * All pointer arguments must be valid and non-null. Arrays must have the specified lengths.
 */
bool anofox_ts_mae(const double *actual,
                   size_t actual_len,
                   const double *forecast,
                   size_t forecast_len,
                   double *out_result,
                   struct AnofoxError *out_error);

/**
 * Mean Squared Error
 *
 * # Safety
 * All pointer arguments must be valid and non-null. Arrays must have the specified lengths.
 */
bool anofox_ts_mse(const double *actual,
                   size_t actual_len,
                   const double *forecast,
                   size_t forecast_len,
                   double *out_result,
                   struct AnofoxError *out_error);

/**
 * Root Mean Squared Error
 *
 * # Safety
 * All pointer arguments must be valid and non-null. Arrays must have the specified lengths.
 */
bool anofox_ts_rmse(const double *actual,
                    size_t actual_len,
                    const double *forecast,
                    size_t forecast_len,
                    double *out_result,
                    struct AnofoxError *out_error);

/**
 * Mean Absolute Percentage Error
 *
 * # Safety
 * All pointer arguments must be valid and non-null. Arrays must have the specified lengths.
 */
bool anofox_ts_mape(const double *actual,
                    size_t actual_len,
                    const double *forecast,
                    size_t forecast_len,
                    double *out_result,
                    struct AnofoxError *out_error);

/**
 * Symmetric Mean Absolute Percentage Error
 *
 * # Safety
 * All pointer arguments must be valid and non-null. Arrays must have the specified lengths.
 */
bool anofox_ts_smape(const double *actual,
                     size_t actual_len,
                     const double *forecast,
                     size_t forecast_len,
                     double *out_result,
                     struct AnofoxError *out_error);

/**
 * R-squared (Coefficient of Determination)
 *
 * # Safety
 * All pointer arguments must be valid and non-null. Arrays must have the specified lengths.
 */
bool anofox_ts_r2(const double *actual,
                  size_t actual_len,
                  const double *forecast,
                  size_t forecast_len,
                  double *out_result,
                  struct AnofoxError *out_error);

/**
 * Bias (Mean Error)
 *
 * # Safety
 * All pointer arguments must be valid and non-null. Arrays must have the specified lengths.
 */
bool anofox_ts_bias(const double *actual,
                    size_t actual_len,
                    const double *forecast,
                    size_t forecast_len,
                    double *out_result,
                    struct AnofoxError *out_error);

/**
 * Relative MAE comparing two models.
 *
 * # Safety
 * All pointer arguments must be valid and non-null. Arrays must have the specified lengths.
 */
bool anofox_ts_rmae(const double *actual,
                    size_t actual_len,
                    const double *pred1,
                    size_t pred1_len,
                    const double *pred2,
                    size_t pred2_len,
                    double *out_result,
                    struct AnofoxError *out_error);

/**
 * Mean Absolute Scaled Error.
 *
 * # Safety
 * All pointer arguments must be valid and non-null. Arrays must have the specified lengths.
 */
bool anofox_ts_mase(const double *actual,
                    size_t actual_len,
                    const double *forecast,
                    size_t forecast_len,
                    const double *baseline,
                    size_t baseline_len,
                    double *out_result,
                    struct AnofoxError *out_error);

/**
 * Quantile loss function.
 *
 * # Safety
 * All pointer arguments must be valid and non-null. Arrays must have the specified lengths.
 */
bool anofox_ts_quantile_loss(const double *actual,
                             size_t actual_len,
                             const double *forecast,
                             size_t forecast_len,
                             double quantile,
                             double *out_result,
                             struct AnofoxError *out_error);

/**
 * Multi-quantile loss function.
 *
 * # Safety
 * All pointer arguments must be valid and non-null. Arrays must have the specified lengths.
 * quantiles is a 2D array: n_levels arrays, each of length actual_len.
 */
bool anofox_ts_mqloss(const double *actual,
                      size_t actual_len,
                      const double *const *quantiles,
                      size_t n_levels,
                      const double *levels,
                      double *out_result,
                      struct AnofoxError *out_error);

/**
 * Coverage of prediction intervals.
 *
 * # Safety
 * All pointer arguments must be valid and non-null. Arrays must have the specified lengths.
 */
bool anofox_ts_coverage(const double *actual,
                        size_t actual_len,
                        const double *lower,
                        const double *upper,
                        double *out_result,
                        struct AnofoxError *out_error);

/**
 * Detect seasonal periods in a time series.
 *
 * # Safety
 * All pointer arguments must be valid and non-null. Arrays must have the specified lengths.
 */
bool anofox_ts_detect_seasonality(const double *values,
                                  size_t length,
                                  int max_period,
                                  int **out_periods,
                                  size_t *out_n_periods,
                                  struct AnofoxError *out_error);

/**
 * Analyze seasonality in a time series.
 *
 * # Safety
 * All pointer arguments must be valid and non-null. Arrays must have the specified lengths.
 * Note: timestamps parameter is for API compatibility but is ignored internally.
 */
bool anofox_ts_analyze_seasonality(const int64_t *_timestamps,
                                   size_t _timestamps_len,
                                   const double *values,
                                   size_t length,
                                   int max_period,
                                   struct SeasonalityResult *out_result,
                                   struct AnofoxError *out_error);

/**
 * Detect periods using specified method.
 *
 * # Safety
 * All pointer arguments must be valid and non-null. Arrays must have the specified lengths.
 */
bool anofox_ts_detect_periods(const double *values,
                              size_t length,
                              const char *method,
                              struct MultiPeriodResult *out_result,
                              struct AnofoxError *out_error);

/**
 * Detect multiple periods in a time series using the specified method.
 *
 * Returns a flattened result with parallel arrays for safer FFI.
 * This version avoids memory issues when used through R's DuckDB bindings.
 *
 * # Arguments
 * * `max_period` - Maximum period to search (0 = use default of 365)
 * * `min_confidence` - Minimum confidence threshold; periods below this are filtered out.
 *   Use negative value (e.g., -1.0) to use method-specific default.
 *   Use 0.0 to disable filtering. Use positive value for custom threshold.
 *
 * # Safety
 * All pointer arguments must be valid and non-null.
 */
bool anofox_ts_detect_periods_flat(const double *values,
                                   size_t length,
                                   const char *method,
                                   size_t max_period,
                                   double min_confidence,
                                   struct FlatMultiPeriodResult *out_result,
                                   struct AnofoxError *out_error);

/**
 * Estimate period using FFT.
 *
 * # Safety
 * All pointer arguments must be valid and non-null.
 */
bool anofox_ts_estimate_period_fft(const double *values,
                                   size_t length,
                                   struct SinglePeriodResult *out_result,
                                   struct AnofoxError *out_error);

/**
 * Estimate period using ACF.
 *
 * # Safety
 * All pointer arguments must be valid and non-null.
 */
bool anofox_ts_estimate_period_acf(const double *values,
                                   size_t length,
                                   int max_lag,
                                   struct SinglePeriodResult *out_result,
                                   struct AnofoxError *out_error);

/**
 * Detect multiple periods in time series.
 *
 * # Safety
 * All pointer arguments must be valid and non-null.
 */
bool anofox_ts_detect_multiple_periods(const double *values,
                                       size_t length,
                                       int max_periods,
                                       double min_confidence,
                                       double min_strength,
                                       struct MultiPeriodResult *out_result,
                                       struct AnofoxError *out_error);

/**
 * Detect multiple periods in time series.
 *
 * Returns a flattened result with parallel arrays for safer FFI.
 * This version avoids memory issues when used through R's DuckDB bindings.
 *
 * # Safety
 * All pointer arguments must be valid and non-null.
 */
bool anofox_ts_detect_multiple_periods_flat(const double *values,
                                            size_t length,
                                            int max_periods,
                                            double min_confidence,
                                            double min_strength,
                                            struct FlatMultiPeriodResult *out_result,
                                            struct AnofoxError *out_error);

/**
 * Autoperiod: FFT period detection with ACF validation.
 *
 * # Safety
 * All pointer arguments must be valid and non-null.
 */
bool anofox_ts_autoperiod(const double *values,
                          size_t length,
                          double acf_threshold,
                          struct AutoperiodResultFFI *out_result,
                          struct AnofoxError *out_error);

/**
 * CFD Autoperiod: First-differenced FFT with ACF validation.
 *
 * # Safety
 * All pointer arguments must be valid and non-null.
 */
bool anofox_ts_cfd_autoperiod(const double *values,
                              size_t length,
                              double acf_threshold,
                              struct AutoperiodResultFFI *out_result,
                              struct AnofoxError *out_error);

/**
 * Lomb-Scargle periodogram for period detection.
 *
 * Optimal for detecting periodic signals in unevenly sampled data.
 * More robust than FFT for noisy data and provides statistical significance.
 *
 * # Safety
 * All pointer arguments must be valid and non-null.
 */
bool anofox_ts_lomb_scargle(const double *values,
                            size_t length,
                            double min_period,
                            double max_period,
                            size_t n_frequencies,
                            struct LombScargleResultFFI *out_result,
                            struct AnofoxError *out_error);

/**
 * AIC-based period comparison.
 *
 * Fits sinusoidal models with different candidate periods and selects
 * the one with the lowest AIC.
 *
 * # Safety
 * All pointer arguments must be valid and non-null.
 */
bool anofox_ts_aic_period(const double *values,
                          size_t length,
                          double min_period,
                          double max_period,
                          size_t n_candidates,
                          struct AicPeriodResultFFI *out_result,
                          struct AnofoxError *out_error);

/**
 * SSA (Singular Spectrum Analysis) for period detection.
 *
 * # Safety
 * All pointer arguments must be valid and non-null.
 */
bool anofox_ts_ssa_period(const double *values,
                          size_t length,
                          size_t window_size,
                          size_t n_components,
                          struct SsaPeriodResultFFI *out_result,
                          struct AnofoxError *out_error);

/**
 * STL-based period detection via seasonal strength optimization.
 *
 * # Safety
 * All pointer arguments must be valid and non-null.
 */
bool anofox_ts_stl_period(const double *values,
                          size_t length,
                          size_t min_period,
                          size_t max_period,
                          size_t n_candidates,
                          struct StlPeriodResultFFI *out_result,
                          struct AnofoxError *out_error);

/**
 * Matrix Profile period detection.
 *
 * Uses Matrix Profile to find motifs and estimate periodicity from
 * the distribution of motif distances.
 *
 * # Safety
 * All pointer arguments must be valid and non-null.
 */
bool anofox_ts_matrix_profile_period(const double *values,
                                     size_t length,
                                     size_t subsequence_length,
                                     size_t n_best,
                                     struct MatrixProfilePeriodResultFFI *out_result,
                                     struct AnofoxError *out_error);

/**
 * SAZED period detection using spectral analysis with zero-padding.
 *
 * # Safety
 * All pointer arguments must be valid and non-null.
 */
bool anofox_ts_sazed_period(const double *values,
                            size_t length,
                            size_t min_period,
                            size_t max_period,
                            size_t zero_pad_factor,
                            struct SazedPeriodResultFFI *out_result,
                            struct AnofoxError *out_error);

/**
 * Detect peaks in time series.
 *
 * # Safety
 * All pointer arguments must be valid and non-null.
 */
bool anofox_ts_detect_peaks(const double *values,
                            size_t length,
                            double min_distance,
                            double min_prominence,
                            bool smooth_first,
                            struct PeakDetectionResultFFI *out_result,
                            struct AnofoxError *out_error);

/**
 * Analyze peak timing variability.
 *
 * # Safety
 * All pointer arguments must be valid and non-null.
 */
bool anofox_ts_analyze_peak_timing(const double *values,
                                   size_t length,
                                   double period,
                                   struct PeakTimingResultFFI *out_result,
                                   struct AnofoxError *out_error);

/**
 * Detrend time series using specified method.
 *
 * # Safety
 * All pointer arguments must be valid and non-null.
 */
bool anofox_ts_detrend(const double *values,
                       size_t length,
                       const char *method,
                       struct DetrendResultFFI *out_result,
                       struct AnofoxError *out_error);

/**
 * Decompose time series into trend, seasonal, and remainder.
 *
 * # Safety
 * All pointer arguments must be valid and non-null.
 */
bool anofox_ts_decompose(const double *values,
                         size_t length,
                         double period,
                         const char *method,
                         struct DecomposeResultFFI *out_result,
                         struct AnofoxError *out_error);

/**
 * Compute seasonal strength using specified method.
 *
 * # Safety
 * All pointer arguments must be valid and non-null.
 */
bool anofox_ts_seasonal_strength(const double *values,
                                 size_t length,
                                 double period,
                                 const char *method,
                                 double *out_strength,
                                 struct AnofoxError *out_error);

/**
 * Compute windowed seasonal strength.
 *
 * # Safety
 * All pointer arguments must be valid and non-null.
 */
bool anofox_ts_seasonal_strength_windowed(const double *values,
                                          size_t length,
                                          double period,
                                          double window_size,
                                          const char *method,
                                          double **out_strengths,
                                          size_t *out_n_windows,
                                          struct AnofoxError *out_error);

/**
 * Classify seasonality type and pattern.
 *
 * # Safety
 * All pointer arguments must be valid and non-null.
 */
bool anofox_ts_classify_seasonality(const double *values,
                                    size_t length,
                                    double period,
                                    double strength_threshold,
                                    double timing_threshold,
                                    struct SeasonalityClassificationFFI *out_result,
                                    struct AnofoxError *out_error);

/**
 * Detect seasonality changes over time.
 *
 * # Safety
 * All pointer arguments must be valid and non-null.
 */
bool anofox_ts_detect_seasonality_changes(const double *values,
                                          size_t length,
                                          double period,
                                          double threshold,
                                          double window_size,
                                          double min_duration,
                                          struct ChangeDetectionResultFFI *out_result,
                                          struct AnofoxError *out_error);

/**
 * Compute instantaneous period using Hilbert transform.
 *
 * # Safety
 * All pointer arguments must be valid and non-null.
 */
bool anofox_ts_instantaneous_period(const double *values,
                                    size_t length,
                                    struct InstantaneousPeriodResultFFI *out_result,
                                    struct AnofoxError *out_error);

/**
 * Detect amplitude modulation in seasonal time series.
 *
 * # Safety
 * All pointer arguments must be valid and non-null.
 */
bool anofox_ts_detect_amplitude_modulation(const double *values,
                                           size_t length,
                                           double period,
                                           double modulation_threshold,
                                           double seasonality_threshold,
                                           struct AmplitudeModulationResultFFI *out_result,
                                           struct AnofoxError *out_error);

/**
 * MSTL decomposition.
 *
 * # Arguments
 * * `insufficient_data_mode` - How to handle insufficient data:
 *   - 0 (Fail): Error on insufficient data (default)
 *   - 1 (Trend): Apply trend-only decomposition, seasonal components are empty
 *   - 2 (None): Skip decomposition entirely, return empty result
 *
 * # Safety
 * All pointer arguments must be valid and non-null. Arrays must have the specified lengths.
 */
bool anofox_ts_mstl_decomposition(const double *values,
                                  size_t length,
                                  const int *periods,
                                  size_t n_periods,
                                  int insufficient_data_mode,
                                  struct MstlResult *out_result,
                                  struct AnofoxError *out_error);

/**
 * Detect changepoints using PELT algorithm.
 *
 * # Safety
 * All pointer arguments must be valid and non-null. Arrays must have the specified lengths.
 */
bool anofox_ts_detect_changepoints(const double *values,
                                   size_t length,
                                   int min_size,
                                   double penalty,
                                   struct ChangepointResult *out_result,
                                   struct AnofoxError *out_error);

/**
 * BOCPD changepoint detection.
 *
 * # Safety
 * All pointer arguments must be valid and non-null. Arrays must have the specified lengths.
 */
bool anofox_ts_detect_changepoints_bocpd(const double *values,
                                         size_t length,
                                         double hazard_lambda,
                                         bool include_probabilities,
                                         struct BocpdResult *out_result,
                                         struct AnofoxError *out_error);

/**
 * Extract time series features.
 *
 * # Safety
 * All pointer arguments must be valid and non-null. Arrays must have the specified lengths.
 */
bool anofox_ts_features(const double *values,
                        size_t length,
                        struct FeaturesResult *out_result,
                        struct AnofoxError *out_error);

/**
 * Validate feature parameter keys and return warnings for unknown keys.
 *
 * # Safety
 * All pointer arguments must be valid and non-null. Arrays must have the specified lengths.
 */
bool anofox_ts_validate_feature_params(const char *const *param_names,
                                       size_t n_params,
                                       char ***out_warnings,
                                       size_t *out_n_warnings);

/**
 * Free warnings array returned by validate_feature_params.
 *
 * # Safety
 * The pointer must be valid or null.
 */
void anofox_free_warnings(char **warnings, size_t n_warnings);

/**
 * List available feature names.
 *
 * # Safety
 * All pointer arguments must be valid and non-null.
 */
bool anofox_ts_features_list(char **out_names, size_t *out_count);

/**
 * Generate forecasts for a time series.
 *
 * # Safety
 * All pointer arguments must be valid and non-null. Arrays must have the specified lengths.
 */
bool anofox_ts_forecast(const double *values,
                        const uint64_t *validity,
                        size_t length,
                        const struct ForecastOptions *options,
                        struct ForecastResult *out_result,
                        struct AnofoxError *out_error);

/**
 * Generate time series forecasts with exogenous variables.
 *
 * This function extends `anofox_ts_forecast` to support external regressors (xreg).
 * Exogenous variables can improve forecast accuracy when external factors (e.g.,
 * promotions, holidays, weather) influence the target variable.
 *
 * # Arguments
 * * `values` - Pointer to time series values (target variable y)
 * * `validity` - Pointer to validity bitmask (NULL means all valid)
 * * `length` - Number of observations
 * * `options` - Forecast options including exogenous data
 * * `out_result` - Output forecast result
 * * `out_error` - Output error (optional)
 *
 * # Supported Models
 * The following models support exogenous variables:
 * - AutoARIMA, ARIMA (ARIMAX)
 * - OptimizedTheta, DynamicTheta
 * - MFLES
 *
 * Other models will ignore the exogenous data and produce a standard forecast.
 *
 * # Safety
 * All pointer arguments must be valid. Arrays must have the specified lengths.
 * For exogenous data:
 * - Each regressor's `n_values` must equal `length`
 * - Each regressor's `n_future` must equal `options.horizon`
 */
bool anofox_ts_forecast_exog(const double *values,
                             const uint64_t *validity,
                             size_t length,
                             const struct ForecastOptionsExog *options,
                             struct ForecastResult *out_result,
                             struct AnofoxError *out_error);

/**
 * Compute data quality metrics.
 *
 * # Safety
 * All pointer arguments must be valid and non-null. Arrays must have the specified lengths.
 */
bool anofox_ts_data_quality(const double *values,
                            const uint64_t *validity,
                            size_t length,
                            struct DataQualityResult *out_result,
                            struct AnofoxError *out_error);

/**
 * Fill NULL values with a constant.
 *
 * # Safety
 * All pointer arguments must be valid and non-null. Arrays must have the specified lengths.
 */
bool anofox_ts_fill_nulls_const(const double *values,
                                const uint64_t *validity,
                                size_t length,
                                double fill_value,
                                double **out_values,
                                struct AnofoxError *out_error);

/**
 * Fill NULL values with the series mean.
 *
 * # Safety
 * All pointer arguments must be valid and non-null. Arrays must have the specified lengths.
 */
bool anofox_ts_fill_nulls_mean(const double *values,
                               const uint64_t *validity,
                               size_t length,
                               double **out_values,
                               struct AnofoxError *out_error);

/**
 * Compute differences of a time series.
 *
 * # Safety
 * All pointer arguments must be valid and non-null. Arrays must have the specified lengths.
 */
bool anofox_ts_diff(const double *values,
                    size_t length,
                    int order,
                    double **out_values,
                    size_t *out_length,
                    struct AnofoxError *out_error);

/**
 * Fill gaps in a time series with new timestamps.
 *
 * # Safety
 * All pointer arguments must be valid and non-null. Arrays must have the specified lengths.
 */
bool anofox_ts_fill_gaps(const int64_t *dates,
                         const double *values,
                         const uint64_t *validity,
                         size_t length,
                         int64_t frequency_seconds,
                         struct GapFillResult *out_result,
                         struct AnofoxError *out_error);

/**
 * Fill forward to a target date.
 *
 * # Safety
 * All pointer arguments must be valid and non-null. Arrays must have the specified lengths.
 */
bool anofox_ts_fill_forward_dates(const int64_t *dates,
                                  const double *values,
                                  const uint64_t *validity,
                                  size_t length,
                                  int64_t target_date,
                                  int64_t frequency_seconds,
                                  struct GapFillResult *out_result,
                                  struct AnofoxError *out_error);

/**
 * Detect the frequency of a time series.
 *
 * # Safety
 * All pointer arguments must be valid and non-null. Arrays must have the specified lengths.
 */
bool anofox_ts_detect_frequency(const int64_t *dates,
                                size_t length,
                                int64_t *out_frequency,
                                struct AnofoxError *out_error);

/**
 * Fill NULL values with forward fill.
 *
 * # Safety
 * All pointer arguments must be valid and non-null. Arrays must have the specified lengths.
 */
bool anofox_ts_fill_nulls_forward(const double *values,
                                  const uint64_t *validity,
                                  size_t length,
                                  struct FilledValuesResult *out_result,
                                  struct AnofoxError *out_error);

/**
 * Fill NULL values with backward fill.
 *
 * # Safety
 * All pointer arguments must be valid and non-null. Arrays must have the specified lengths.
 */
bool anofox_ts_fill_nulls_backward(const double *values,
                                   const uint64_t *validity,
                                   size_t length,
                                   struct FilledValuesResult *out_result,
                                   struct AnofoxError *out_error);

/**
 * Fill NULL values with linear interpolation.
 *
 * # Safety
 * All pointer arguments must be valid and non-null. Arrays must have the specified lengths.
 */
bool anofox_ts_fill_nulls_interpolate(const double *values,
                                      const uint64_t *validity,
                                      size_t length,
                                      double **out_values,
                                      struct AnofoxError *out_error);

/**
 * Compute the conformity score (quantile) from calibration residuals.
 *
 * Returns the (1 - alpha) quantile of absolute residuals for conformal prediction.
 *
 * # Safety
 * All pointer arguments must be valid and non-null.
 */
bool anofox_ts_conformal_quantile(const double *residuals,
                                  const uint64_t *validity,
                                  size_t length,
                                  double alpha,
                                  double *out_result,
                                  struct AnofoxError *out_error);

/**
 * Apply a conformity score to point forecasts to create prediction intervals.
 *
 * Creates symmetric intervals: [forecast - score, forecast + score].
 *
 * # Safety
 * All pointer arguments must be valid and non-null.
 */
bool anofox_ts_conformal_intervals(const double *forecasts,
                                   size_t length,
                                   double conformity_score,
                                   double **out_lower,
                                   double **out_upper,
                                   struct AnofoxError *out_error);

/**
 * Perform split conformal prediction in one step.
 *
 * Computes conformity score from residuals and applies to forecasts.
 *
 * # Safety
 * All pointer arguments must be valid and non-null.
 */
bool anofox_ts_conformal_predict(const double *residuals,
                                 const uint64_t *residuals_validity,
                                 size_t residuals_length,
                                 const double *forecasts,
                                 size_t forecasts_length,
                                 double alpha,
                                 struct ConformalResultFFI *out_result,
                                 struct AnofoxError *out_error);

/**
 * Perform conformal prediction with multiple coverage levels.
 *
 * Computes prediction intervals at multiple alpha levels simultaneously.
 *
 * # Safety
 * All pointer arguments must be valid and non-null.
 */
bool anofox_ts_conformal_predict_multi(const double *residuals,
                                       const uint64_t *residuals_validity,
                                       size_t residuals_length,
                                       const double *forecasts,
                                       size_t forecasts_length,
                                       const double *alphas,
                                       size_t n_alphas,
                                       struct ConformalMultiResultFFI *out_result,
                                       struct AnofoxError *out_error);

/**
 * Perform locally-adaptive conformal prediction.
 *
 * Scales intervals based on local difficulty estimates.
 *
 * # Safety
 * All pointer arguments must be valid and non-null.
 */
bool anofox_ts_conformal_predict_adaptive(const double *residuals,
                                          const uint64_t *residuals_validity,
                                          size_t residuals_length,
                                          const double *forecasts,
                                          const double *difficulty,
                                          size_t forecasts_length,
                                          double alpha,
                                          struct ConformalResultFFI *out_result,
                                          struct AnofoxError *out_error);

/**
 * Perform asymmetric conformal prediction.
 *
 * Uses separate quantiles for positive and negative residuals.
 *
 * # Safety
 * All pointer arguments must be valid and non-null.
 */
bool anofox_ts_conformal_predict_asymmetric(const double *residuals,
                                            const uint64_t *residuals_validity,
                                            size_t residuals_length,
                                            const double *forecasts,
                                            size_t forecasts_length,
                                            double alpha,
                                            struct ConformalResultFFI *out_result,
                                            struct AnofoxError *out_error);

/**
 * Compute interval width (upper - lower) for each prediction.
 *
 * # Safety
 * All pointer arguments must be valid and non-null.
 */
bool anofox_ts_interval_width(const double *lower,
                              const double *upper,
                              size_t length,
                              double **out_widths,
                              struct AnofoxError *out_error);

/**
 * Compute mean interval width.
 *
 * # Safety
 * All pointer arguments must be valid and non-null.
 */
bool anofox_ts_mean_interval_width(const double *lower,
                                   const double *upper,
                                   size_t length,
                                   double *out_result,
                                   struct AnofoxError *out_error);

/**
 * Learn a calibration profile from residuals.
 *
 * # Safety
 * All pointer arguments must be valid and non-null.
 */
bool anofox_ts_conformal_learn(const double *residuals,
                               const uint64_t *residuals_validity,
                               size_t residuals_length,
                               const double *alphas,
                               size_t n_alphas,
                               enum ConformalMethodFFI method,
                               enum ConformalStrategyFFI strategy,
                               const double *difficulty,
                               struct CalibrationProfileFFI *out_profile,
                               struct AnofoxError *out_error);

/**
 * Apply a calibration profile to generate prediction intervals.
 *
 * # Safety
 * All pointer arguments must be valid and non-null.
 */
bool anofox_ts_conformal_apply(const double *forecasts,
                               size_t n_forecasts,
                               const struct CalibrationProfileFFI *profile,
                               const double *difficulty,
                               struct PredictionIntervalsFFI *out_intervals,
                               struct AnofoxError *out_error);

/**
 * Compute empirical coverage of prediction intervals.
 *
 * # Safety
 * All pointer arguments must be valid and non-null.
 */
bool anofox_ts_conformal_coverage(const double *actuals,
                                  const double *lower,
                                  const double *upper,
                                  size_t length,
                                  double *out_coverage,
                                  struct AnofoxError *out_error);

/**
 * Compute comprehensive conformal evaluation metrics.
 *
 * # Safety
 * All pointer arguments must be valid and non-null.
 */
bool anofox_ts_conformal_evaluate(const double *actuals,
                                  const double *lower,
                                  const double *upper,
                                  size_t length,
                                  double alpha,
                                  struct ConformalEvaluationFFI *out_eval,
                                  struct AnofoxError *out_error);

/**
 * Compute difficulty scores for adaptive conformal prediction.
 *
 * # Arguments
 * * `values` - Time series values
 * * `values_length` - Number of values
 * * `method` - Method for computing difficulty (Volatility, ChangepointProb, RollingStd)
 * * `window` - Window size (0 for default)
 * * `out_result` - Output difficulty score result
 * * `out_error` - Error output
 *
 * # Safety
 * All pointer arguments must be valid and non-null.
 */
bool anofox_ts_difficulty_score(const double *values,
                                size_t values_length,
                                enum DifficultyMethodFFI method,
                                size_t window,
                                struct DifficultyScoreResultFFI *out_result,
                                struct AnofoxError *out_error);

/**
 * Free a DifficultyScoreResultFFI.
 *
 * # Safety
 * Pointer must have been allocated by anofox_ts_difficulty_score.
 */
void anofox_free_difficulty_score_result(struct DifficultyScoreResultFFI *result);

/**
 * Convenience function combining conformal_learn and conformal_apply in one step.
 *
 * # Arguments
 * * `residuals` - Calibration residuals
 * * `residuals_validity` - Validity bitmask (NULL means all valid)
 * * `residuals_length` - Number of residuals
 * * `forecasts` - Point forecasts to wrap with intervals
 * * `forecasts_length` - Number of forecasts
 * * `alphas` - Miscoverage rates
 * * `n_alphas` - Number of alphas
 * * `method` - Conformal method (Symmetric, Asymmetric, Adaptive)
 * * `strategy` - Calibration strategy (Split, CrossVal, JackknifePlus)
 * * `out_intervals` - Output prediction intervals
 * * `out_error` - Error output
 *
 * # Safety
 * All pointer arguments must be valid and non-null.
 */
bool anofox_ts_conformalize(const double *residuals,
                            const uint64_t *residuals_validity,
                            size_t residuals_length,
                            const double *forecasts,
                            size_t forecasts_length,
                            const double *alphas,
                            size_t n_alphas,
                            enum ConformalMethodFFI method,
                            enum ConformalStrategyFFI strategy,
                            struct PredictionIntervalsFFI *out_intervals,
                            struct AnofoxError *out_error);

/**
 * Free a TsStatsResult.
 *
 * # Safety
 * The result pointer must be valid or null.
 */
void anofox_free_ts_stats_result(struct TsStatsResult *_result);

/**
 * Free a GapFillResult.
 *
 * # Safety
 * The result pointer must be valid or null.
 */
void anofox_free_gap_fill_result(struct GapFillResult *result);

/**
 * Free a FilledValuesResult.
 *
 * # Safety
 * The result pointer must be valid or null.
 */
void anofox_free_filled_values_result(struct FilledValuesResult *result);

/**
 * Free a ForecastResult.
 *
 * # Safety
 * The result pointer must be valid or null.
 */
void anofox_free_forecast_result(struct ForecastResult *result);

/**
 * Free a ChangepointResult.
 *
 * # Safety
 * The result pointer must be valid or null.
 */
void anofox_free_changepoint_result(struct ChangepointResult *result);

/**
 * Free a BocpdResult.
 *
 * # Safety
 * The result pointer must be valid or null.
 */
void anofox_free_bocpd_result(struct BocpdResult *result);

/**
 * Free a FeaturesResult.
 *
 * # Safety
 * The result pointer must be valid or null.
 */
void anofox_free_features_result(struct FeaturesResult *result);

/**
 * Free a SeasonalityResult.
 *
 * # Safety
 * The result pointer must be valid or null.
 */
void anofox_free_seasonality_result(struct SeasonalityResult *result);

/**
 * Free a MstlResult.
 *
 * # Safety
 * The result pointer must be valid or null.
 */
void anofox_free_mstl_result(struct MstlResult *result);

/**
 * Free a double array.
 *
 * # Safety
 * The pointer must be valid or null.
 */
void anofox_free_double_array(double *ptr);

/**
 * Free an int array.
 *
 * # Safety
 * The pointer must be valid or null.
 */
void anofox_free_int_array(int *ptr);

/**
 * Free a MultiPeriodResult.
 *
 * # Safety
 * The result pointer must be valid or null.
 */
void anofox_free_multi_period_result(struct MultiPeriodResult *result);

/**
 * Free a FlatMultiPeriodResult.
 *
 * Frees all parallel arrays allocated by the flat period detection functions.
 *
 * # Safety
 * The result pointer must be valid or null.
 */
void anofox_free_flat_multi_period_result(struct FlatMultiPeriodResult *result);

/**
 * Free a PeakDetectionResultFFI.
 *
 * # Safety
 * The result pointer must be valid or null.
 */
void anofox_free_peak_detection_result(struct PeakDetectionResultFFI *result);

/**
 * Free a PeakTimingResultFFI.
 *
 * # Safety
 * The result pointer must be valid or null.
 */
void anofox_free_peak_timing_result(struct PeakTimingResultFFI *result);

/**
 * Free a DetrendResultFFI.
 *
 * # Safety
 * The result pointer must be valid or null.
 */
void anofox_free_detrend_result(struct DetrendResultFFI *result);

/**
 * Free a DecomposeResultFFI.
 *
 * # Safety
 * The result pointer must be valid or null.
 */
void anofox_free_decompose_result(struct DecomposeResultFFI *result);

/**
 * Free a SeasonalityClassificationFFI.
 *
 * # Safety
 * The result pointer must be valid or null.
 */
void anofox_free_seasonality_classification_result(struct SeasonalityClassificationFFI *result);

/**
 * Free a ChangeDetectionResultFFI.
 *
 * # Safety
 * The result pointer must be valid or null.
 */
void anofox_free_change_detection_result(struct ChangeDetectionResultFFI *result);

/**
 * Free an InstantaneousPeriodResultFFI.
 *
 * # Safety
 * The result pointer must be valid or null.
 */
void anofox_free_instantaneous_period_result(struct InstantaneousPeriodResultFFI *result);

/**
 * Free an AmplitudeModulationResultFFI.
 *
 * # Safety
 * The result pointer must be valid or null.
 */
void anofox_free_amplitude_modulation_result(struct AmplitudeModulationResultFFI *result);

/**
 * Free a ConformalResultFFI.
 *
 * # Safety
 * The result pointer must be valid or null.
 */
void anofox_free_conformal_result(struct ConformalResultFFI *result);

/**
 * Free a ConformalMultiResultFFI.
 *
 * # Safety
 * The result pointer must be valid or null.
 */
void anofox_free_conformal_multi_result(struct ConformalMultiResultFFI *result);

/**
 * Free a CalibrationProfileFFI.
 *
 * # Safety
 * The result pointer must be valid or null.
 */
void anofox_free_calibration_profile(struct CalibrationProfileFFI *result);

/**
 * Free a PredictionIntervalsFFI.
 *
 * # Safety
 * The result pointer must be valid or null.
 */
void anofox_free_prediction_intervals(struct PredictionIntervalsFFI *result);

const char *anofox_fcst_version(void);

/**
 * Initialize telemetry from C/C++.
 *
 * # Safety
 * The api_key pointer must be valid or null.
 */
void anofox_telemetry_init(bool enabled, const char *api_key);

/**
 * Check if telemetry is enabled.
 */
bool anofox_telemetry_is_enabled(void);

/**
 * Capture extension load event from C/C++.
 */
void anofox_telemetry_capture_extension_load(void);

#ifdef __cplusplus
}  // extern "C"
#endif  // __cplusplus

#endif  /* ANOFOX_FCST_FFI_H */
