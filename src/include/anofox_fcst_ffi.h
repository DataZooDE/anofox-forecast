#ifndef ANOFOX_FCST_FFI_H
#define ANOFOX_FCST_FFI_H

#pragma once

/* Warning: this file is autogenerated by cbindgen. Don't modify this manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

/**
 * Date type enumeration for handling different DuckDB date types.
 */
typedef enum DateType {
    /**
     * Days since epoch (1970-01-01)
     */
    DATE = 0,
    /**
     * Microseconds since epoch
     */
    TIMESTAMP = 1,
    /**
     * Generic integer periods
     */
    INTEGER = 2,
} DateType;

/**
 * Error codes for FFI boundary.
 */
typedef enum ErrorCode {
    SUCCESS = 0,
    NULL_POINTER = 1,
    INVALID_INPUT = 2,
    COMPUTATION_ERROR = 3,
    ALLOCATION_ERROR = 4,
    INVALID_MODEL = 5,
    INSUFFICIENT_DATA = 6,
    INVALID_DATE_FORMAT = 7,
    INVALID_FREQUENCY = 8,
    PANIC_CAUGHT = 9,
    INTERNAL_ERROR = 10,
} ErrorCode;

/**
 * Time series statistics result (24 metrics).
 */
typedef struct TsStatsResult {
    /**
     * Total number of observations
     */
    size_t length;
    /**
     * Number of NULL values
     */
    size_t n_nulls;
    /**
     * Number of zero values
     */
    size_t n_zeros;
    /**
     * Number of positive values
     */
    size_t n_positive;
    /**
     * Number of negative values
     */
    size_t n_negative;
    /**
     * Arithmetic mean
     */
    double mean;
    /**
     * Median (50th percentile)
     */
    double median;
    /**
     * Standard deviation
     */
    double std_dev;
    /**
     * Variance
     */
    double variance;
    /**
     * Minimum value
     */
    double min;
    /**
     * Maximum value
     */
    double max;
    /**
     * Range (max - min)
     */
    double range;
    /**
     * Sum of all values
     */
    double sum;
    /**
     * Skewness
     */
    double skewness;
    /**
     * Kurtosis
     */
    double kurtosis;
    /**
     * Coefficient of variation
     */
    double coef_variation;
    /**
     * First quartile
     */
    double q1;
    /**
     * Third quartile
     */
    double q3;
    /**
     * Interquartile range
     */
    double iqr;
    /**
     * Autocorrelation at lag 1
     */
    double autocorr_lag1;
    /**
     * Trend strength (0-1)
     */
    double trend_strength;
    /**
     * Seasonality strength (0-1)
     */
    double seasonality_strength;
    /**
     * Approximate entropy
     */
    double entropy;
    /**
     * Stability measure
     */
    double stability;
} TsStatsResult;

/**
 * Error structure with message buffer for FFI.
 */
typedef struct AnofoxError {
    enum ErrorCode code;
    char message[256];
} AnofoxError;

/**
 * Seasonality analysis result.
 * C++ API compatible field names.
 */
typedef struct SeasonalityResult {
    /**
     * Array of detected periods (C++ name: detected_periods)
     */
    int *detected_periods;
    /**
     * Number of detected periods
     */
    size_t n_periods;
    /**
     * Primary (dominant) period (C++ name: primary_period)
     */
    int primary_period;
    /**
     * Seasonal strength (0-1)
     */
    double seasonal_strength;
    /**
     * Trend strength (0-1)
     */
    double trend_strength;
} SeasonalityResult;

/**
 * A detected period from multiple period detection.
 */
typedef struct DetectedPeriodFFI {
    /**
     * Estimated period (in samples)
     */
    double period;
    /**
     * Confidence measure
     */
    double confidence;
    /**
     * Seasonal strength at this period
     */
    double strength;
    /**
     * Amplitude of the sinusoidal component
     */
    double amplitude;
    /**
     * Phase of the sinusoidal component (radians)
     */
    double phase;
    /**
     * Iteration number (1-indexed)
     */
    size_t iteration;
} DetectedPeriodFFI;

/**
 * Result from multiple period detection.
 */
typedef struct MultiPeriodResult {
    /**
     * Array of detected periods
     */
    struct DetectedPeriodFFI *periods;
    /**
     * Number of detected periods
     */
    size_t n_periods;
    /**
     * Primary (strongest) period
     */
    double primary_period;
    /**
     * Method used for estimation
     */
    char method[32];
} MultiPeriodResult;

/**
 * Flattened result from multiple period detection.
 *
 * Uses parallel arrays instead of nested struct array for safer FFI.
 * This avoids memory management issues when crossing the Rust/C++ boundary,
 * particularly with R's DuckDB bindings.
 */
typedef struct FlatMultiPeriodResult {
    /**
     * Array of period values (in samples)
     */
    double *period_values;
    /**
     * Array of confidence values
     */
    double *confidence_values;
    /**
     * Array of strength values
     */
    double *strength_values;
    /**
     * Array of amplitude values
     */
    double *amplitude_values;
    /**
     * Array of phase values (radians)
     */
    double *phase_values;
    /**
     * Array of iteration values (1-indexed)
     */
    size_t *iteration_values;
    /**
     * Number of detected periods
     */
    size_t n_periods;
    /**
     * Primary (strongest) period
     */
    double primary_period;
    /**
     * Method used for estimation
     */
    char method[32];
} FlatMultiPeriodResult;

/**
 * Result from single period estimation.
 */
typedef struct SinglePeriodResult {
    /**
     * Estimated period (in samples)
     */
    double period;
    /**
     * Dominant frequency (1/period)
     */
    double frequency;
    /**
     * Power at the dominant frequency
     */
    double power;
    /**
     * Confidence measure
     */
    double confidence;
    /**
     * Method used for estimation
     */
    char method[32];
} SinglePeriodResult;

/**
 * A detected peak in the time series.
 */
typedef struct PeakFFI {
    /**
     * Index at which the peak occurs
     */
    size_t index;
    /**
     * Time at which the peak occurs
     */
    double time;
    /**
     * Value at the peak
     */
    double value;
    /**
     * Prominence of the peak
     */
    double prominence;
} PeakFFI;

/**
 * Result of peak detection.
 */
typedef struct PeakDetectionResultFFI {
    /**
     * Array of detected peaks
     */
    struct PeakFFI *peaks;
    /**
     * Number of peaks detected
     */
    size_t n_peaks;
    /**
     * Inter-peak distances
     */
    double *inter_peak_distances;
    /**
     * Number of inter-peak distances
     */
    size_t n_distances;
    /**
     * Mean period estimated from inter-peak distances
     */
    double mean_period;
} PeakDetectionResultFFI;

/**
 * Result of peak timing variability analysis.
 */
typedef struct PeakTimingResultFFI {
    /**
     * Peak times for each cycle
     */
    double *peak_times;
    /**
     * Peak values
     */
    double *peak_values;
    /**
     * Normalized timing (0-1 scale)
     */
    double *normalized_timing;
    /**
     * Number of peaks
     */
    size_t n_peaks;
    /**
     * Mean normalized timing
     */
    double mean_timing;
    /**
     * Standard deviation of normalized timing
     */
    double std_timing;
    /**
     * Range of normalized timing
     */
    double range_timing;
    /**
     * Variability score (0 = stable, 1 = highly variable)
     */
    double variability_score;
    /**
     * Trend in timing
     */
    double timing_trend;
    /**
     * Whether timing is considered stable
     */
    bool is_stable;
} PeakTimingResultFFI;

/**
 * Result of detrending operation.
 */
typedef struct DetrendResultFFI {
    /**
     * Estimated trend values
     */
    double *trend;
    /**
     * Detrended data
     */
    double *detrended;
    /**
     * Number of values
     */
    size_t length;
    /**
     * Method used for detrending
     */
    char method[32];
    /**
     * Polynomial coefficients (may be NULL)
     */
    double *coefficients;
    /**
     * Number of coefficients
     */
    size_t n_coefficients;
    /**
     * Residual sum of squares
     */
    double rss;
    /**
     * Number of parameters
     */
    size_t n_params;
} DetrendResultFFI;

/**
 * Result of seasonal decomposition.
 */
typedef struct DecomposeResultFFI {
    /**
     * Trend component
     */
    double *trend;
    /**
     * Seasonal component
     */
    double *seasonal;
    /**
     * Remainder/residual component
     */
    double *remainder;
    /**
     * Number of observations
     */
    size_t length;
    /**
     * Period used for decomposition
     */
    double period;
    /**
     * Decomposition method ("additive" or "multiplicative")
     */
    char method[32];
} DecomposeResultFFI;

/**
 * Result of seasonality classification.
 */
typedef struct SeasonalityClassificationFFI {
    /**
     * Whether series is classified as seasonal
     */
    bool is_seasonal;
    /**
     * Whether timing is stable across cycles
     */
    bool has_stable_timing;
    /**
     * Timing variability measure
     */
    double timing_variability;
    /**
     * Overall seasonal strength
     */
    double seasonal_strength;
    /**
     * Per-cycle seasonal strength
     */
    double *cycle_strengths;
    /**
     * Number of cycle strengths
     */
    size_t n_cycle_strengths;
    /**
     * Indices of weak/missing seasons
     */
    size_t *weak_seasons;
    /**
     * Number of weak seasons
     */
    size_t n_weak_seasons;
    /**
     * Classification type (stable, variable, intermittent, absent)
     */
    char classification[32];
} SeasonalityClassificationFFI;

/**
 * Seasonality change point.
 */
typedef struct SeasonalityChangePointFFI {
    /**
     * Index at which change occurs
     */
    size_t index;
    /**
     * Time at which change occurs
     */
    double time;
    /**
     * Type of change (onset, cessation)
     */
    char change_type[32];
    /**
     * Strength before change
     */
    double strength_before;
    /**
     * Strength after change
     */
    double strength_after;
} SeasonalityChangePointFFI;

/**
 * Result of seasonality change detection.
 */
typedef struct ChangeDetectionResultFFI {
    /**
     * Array of detected change points
     */
    struct SeasonalityChangePointFFI *change_points;
    /**
     * Number of change points
     */
    size_t n_changes;
    /**
     * Time-varying seasonal strength curve
     */
    double *strength_curve;
    /**
     * Number of strength curve values
     */
    size_t n_strength_curve;
} ChangeDetectionResultFFI;

/**
 * Result of instantaneous period estimation.
 */
typedef struct InstantaneousPeriodResultFFI {
    /**
     * Instantaneous period at each time point
     */
    double *periods;
    /**
     * Instantaneous frequency at each time point
     */
    double *frequencies;
    /**
     * Instantaneous amplitude (envelope) at each time point
     */
    double *amplitudes;
    /**
     * Number of values
     */
    size_t length;
} InstantaneousPeriodResultFFI;

/**
 * Result of amplitude modulation detection.
 */
typedef struct AmplitudeModulationResultFFI {
    /**
     * Whether seasonality is present
     */
    bool is_seasonal;
    /**
     * Overall seasonal strength
     */
    double seasonal_strength;
    /**
     * Whether amplitude modulation is detected
     */
    bool has_modulation;
    /**
     * Modulation type (stable, emerging, fading, oscillating, non_seasonal)
     */
    char modulation_type[32];
    /**
     * Coefficient of variation of wavelet amplitude
     */
    double modulation_score;
    /**
     * Trend in amplitude (-1 to 1)
     */
    double amplitude_trend;
    /**
     * Wavelet amplitude at the seasonal frequency over time
     */
    double *wavelet_amplitude;
    /**
     * Time points corresponding to wavelet_amplitude
     */
    double *time_points;
    /**
     * Number of amplitude/time values
     */
    size_t n_points;
    /**
     * Scale (period) used for wavelet analysis
     */
    double scale;
} AmplitudeModulationResultFFI;

/**
 * MSTL decomposition result.
 */
typedef struct MstlResult {
    /**
     * Trend component (may be NULL if decomposition was skipped)
     */
    double *trend;
    /**
     * Array of seasonal component arrays (one per period)
     */
    double **seasonal_components;
    /**
     * Remainder (residual) component (may be NULL if decomposition was skipped)
     */
    double *remainder;
    /**
     * Number of observations
     */
    size_t n_observations;
    /**
     * Number of seasonal components
     */
    size_t n_seasonal;
    /**
     * Array of seasonal periods
     */
    int *seasonal_periods;
    /**
     * Whether decomposition was actually applied
     */
    bool decomposition_applied;
} MstlResult;

/**
 * Changepoint detection result (PELT algorithm).
 */
typedef struct ChangepointResult {
    /**
     * Array of changepoint indices
     */
    size_t *changepoints;
    /**
     * Number of changepoints detected
     */
    size_t n_changepoints;
    /**
     * Total cost of segmentation
     */
    double cost;
} ChangepointResult;

/**
 * BOCPD changepoint detection result.
 * C++ API compatible: per-point is_changepoint and changepoint_probability.
 */
typedef struct BocpdResult {
    /**
     * Array of is_changepoint flags (one per input point)
     */
    bool *is_changepoint;
    /**
     * Array of changepoint probabilities (one per input point)
     */
    double *changepoint_probability;
    /**
     * Number of input points
     */
    size_t n_points;
    /**
     * Array of changepoint indices (convenience)
     */
    size_t *changepoint_indices;
    /**
     * Number of detected changepoints
     */
    size_t n_changepoints;
} BocpdResult;

/**
 * Feature extraction result.
 */
typedef struct FeaturesResult {
    /**
     * Array of feature values
     */
    double *features;
    /**
     * Array of feature name pointers
     */
    char **feature_names;
    /**
     * Number of features
     */
    size_t n_features;
} FeaturesResult;

/**
 * Forecast options.
 */
typedef struct ForecastOptions {
    /**
     * Model name (null-terminated string)
     */
    char model[32];
    /**
     * Forecast horizon
     */
    int horizon;
    /**
     * Confidence level (0-1)
     */
    double confidence_level;
    /**
     * Seasonal period (0 = auto-detect)
     */
    int seasonal_period;
    /**
     * Whether to auto-detect seasonality
     */
    bool auto_detect_seasonality;
    /**
     * Include in-sample fitted values
     */
    bool include_fitted;
    /**
     * Include residuals
     */
    bool include_residuals;
} ForecastOptions;

/**
 * Forecast result structure.
 */
typedef struct ForecastResult {
    /**
     * Point forecasts array
     */
    double *point_forecasts;
    /**
     * Lower confidence bounds
     */
    double *lower_bounds;
    /**
     * Upper confidence bounds
     */
    double *upper_bounds;
    /**
     * In-sample fitted values
     */
    double *fitted_values;
    /**
     * Residuals
     */
    double *residuals;
    /**
     * Number of forecast points
     */
    size_t n_forecasts;
    /**
     * Number of fitted values
     */
    size_t n_fitted;
    /**
     * Model name
     */
    char model_name[64];
    /**
     * AIC (Akaike Information Criterion)
     */
    double aic;
    /**
     * BIC (Bayesian Information Criterion)
     */
    double bic;
    /**
     * Mean Squared Error
     */
    double mse;
} ForecastResult;

/**
 * Data quality result (per-series).
 */
typedef struct DataQualityResult {
    /**
     * Structural dimension score
     */
    double structural_score;
    /**
     * Temporal dimension score
     */
    double temporal_score;
    /**
     * Magnitude dimension score
     */
    double magnitude_score;
    /**
     * Behavioral dimension score
     */
    double behavioral_score;
    /**
     * Overall quality score
     */
    double overall_score;
    /**
     * Number of gaps
     */
    size_t n_gaps;
    /**
     * Number of missing values
     */
    size_t n_missing;
    /**
     * Is constant series
     */
    bool is_constant;
} DataQualityResult;

/**
 * Gap fill result containing dates and values with filled gaps.
 */
typedef struct GapFillResult {
    /**
     * Array of filled date values
     */
    int64_t *dates;
    /**
     * Array of filled values
     */
    double *values;
    /**
     * Validity bitmask for filled values (bit `i` indicates if `values[i]` is valid)
     */
    uint64_t *validity;
    /**
     * Number of observations after gap filling
     */
    size_t length;
} GapFillResult;

/**
 * Filled values result (for imputation functions that return values with validity).
 */
typedef struct FilledValuesResult {
    /**
     * Array of filled values
     */
    double *values;
    /**
     * Validity bitmask (bit `i` indicates if `values[i]` is valid)
     */
    uint64_t *validity;
    /**
     * Number of values
     */
    size_t length;
} FilledValuesResult;

/**
 * Nullable data array for DuckDB integration.
 *
 * The validity bitmask follows DuckDB's convention where bit i of validity[i/64]
 * indicates if element i is valid (1) or NULL (0).
 */
typedef struct DataArray {
    /**
     * Pointer to the data values
     */
    const double *data;
    /**
     * Pointer to validity bitmask (NULL means all valid)
     */
    const uint64_t *validity;
    /**
     * Number of elements
     */
    size_t length;
} DataArray;

/**
 * Date array supporting multiple date types.
 */
typedef struct DateArray {
    /**
     * Pointer to date values (interpretation depends on date_type)
     */
    const int64_t *data;
    /**
     * Pointer to validity bitmask
     */
    const uint64_t *validity;
    /**
     * Number of elements
     */
    size_t length;
    /**
     * Type of date values
     */
    enum DateType date_type;
} DateArray;

/**
 * Quality report result.
 */
typedef struct QualityReportResult {
    /**
     * Number of series passing all checks
     */
    size_t n_passed;
    /**
     * Number of series with gap issues
     */
    size_t n_gap_issues;
    /**
     * Number of series with missing value issues
     */
    size_t n_missing_issues;
    /**
     * Number of constant series
     */
    size_t n_constant;
    /**
     * Total series analyzed
     */
    size_t n_total;
} QualityReportResult;

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/**
 * Compute time series statistics.
 *
 * # Safety
 * All pointer arguments must be valid and non-null. Arrays must have the specified lengths.
 */
bool anofox_ts_stats(const double *values,
                     const uint64_t *validity,
                     size_t length,
                     struct TsStatsResult *out_result,
                     struct AnofoxError *out_error);

/**
 * Mean Absolute Error
 *
 * # Safety
 * All pointer arguments must be valid and non-null. Arrays must have the specified lengths.
 */
bool anofox_ts_mae(const double *actual,
                   size_t actual_len,
                   const double *forecast,
                   size_t forecast_len,
                   double *out_result,
                   struct AnofoxError *out_error);

/**
 * Mean Squared Error
 *
 * # Safety
 * All pointer arguments must be valid and non-null. Arrays must have the specified lengths.
 */
bool anofox_ts_mse(const double *actual,
                   size_t actual_len,
                   const double *forecast,
                   size_t forecast_len,
                   double *out_result,
                   struct AnofoxError *out_error);

/**
 * Root Mean Squared Error
 *
 * # Safety
 * All pointer arguments must be valid and non-null. Arrays must have the specified lengths.
 */
bool anofox_ts_rmse(const double *actual,
                    size_t actual_len,
                    const double *forecast,
                    size_t forecast_len,
                    double *out_result,
                    struct AnofoxError *out_error);

/**
 * Mean Absolute Percentage Error
 *
 * # Safety
 * All pointer arguments must be valid and non-null. Arrays must have the specified lengths.
 */
bool anofox_ts_mape(const double *actual,
                    size_t actual_len,
                    const double *forecast,
                    size_t forecast_len,
                    double *out_result,
                    struct AnofoxError *out_error);

/**
 * Symmetric Mean Absolute Percentage Error
 *
 * # Safety
 * All pointer arguments must be valid and non-null. Arrays must have the specified lengths.
 */
bool anofox_ts_smape(const double *actual,
                     size_t actual_len,
                     const double *forecast,
                     size_t forecast_len,
                     double *out_result,
                     struct AnofoxError *out_error);

/**
 * R-squared (Coefficient of Determination)
 *
 * # Safety
 * All pointer arguments must be valid and non-null. Arrays must have the specified lengths.
 */
bool anofox_ts_r2(const double *actual,
                  size_t actual_len,
                  const double *forecast,
                  size_t forecast_len,
                  double *out_result,
                  struct AnofoxError *out_error);

/**
 * Bias (Mean Error)
 *
 * # Safety
 * All pointer arguments must be valid and non-null. Arrays must have the specified lengths.
 */
bool anofox_ts_bias(const double *actual,
                    size_t actual_len,
                    const double *forecast,
                    size_t forecast_len,
                    double *out_result,
                    struct AnofoxError *out_error);

/**
 * Relative MAE comparing two models.
 *
 * # Safety
 * All pointer arguments must be valid and non-null. Arrays must have the specified lengths.
 */
bool anofox_ts_rmae(const double *actual,
                    size_t actual_len,
                    const double *pred1,
                    size_t pred1_len,
                    const double *pred2,
                    size_t pred2_len,
                    double *out_result,
                    struct AnofoxError *out_error);

/**
 * Mean Absolute Scaled Error.
 *
 * # Safety
 * All pointer arguments must be valid and non-null. Arrays must have the specified lengths.
 */
bool anofox_ts_mase(const double *actual,
                    size_t actual_len,
                    const double *forecast,
                    size_t forecast_len,
                    const double *baseline,
                    size_t baseline_len,
                    double *out_result,
                    struct AnofoxError *out_error);

/**
 * Quantile loss function.
 *
 * # Safety
 * All pointer arguments must be valid and non-null. Arrays must have the specified lengths.
 */
bool anofox_ts_quantile_loss(const double *actual,
                             size_t actual_len,
                             const double *forecast,
                             size_t forecast_len,
                             double quantile,
                             double *out_result,
                             struct AnofoxError *out_error);

/**
 * Multi-quantile loss function.
 *
 * # Safety
 * All pointer arguments must be valid and non-null. Arrays must have the specified lengths.
 * quantiles is a 2D array: n_levels arrays, each of length actual_len.
 */
bool anofox_ts_mqloss(const double *actual,
                      size_t actual_len,
                      const double *const *quantiles,
                      size_t n_levels,
                      const double *levels,
                      double *out_result,
                      struct AnofoxError *out_error);

/**
 * Coverage of prediction intervals.
 *
 * # Safety
 * All pointer arguments must be valid and non-null. Arrays must have the specified lengths.
 */
bool anofox_ts_coverage(const double *actual,
                        size_t actual_len,
                        const double *lower,
                        const double *upper,
                        double *out_result,
                        struct AnofoxError *out_error);

/**
 * Detect seasonal periods in a time series.
 *
 * # Safety
 * All pointer arguments must be valid and non-null. Arrays must have the specified lengths.
 */
bool anofox_ts_detect_seasonality(const double *values,
                                  size_t length,
                                  int max_period,
                                  int **out_periods,
                                  size_t *out_n_periods,
                                  struct AnofoxError *out_error);

/**
 * Analyze seasonality in a time series.
 *
 * # Safety
 * All pointer arguments must be valid and non-null. Arrays must have the specified lengths.
 * Note: timestamps parameter is for API compatibility but is ignored internally.
 */
bool anofox_ts_analyze_seasonality(const int64_t *_timestamps,
                                   size_t _timestamps_len,
                                   const double *values,
                                   size_t length,
                                   int max_period,
                                   struct SeasonalityResult *out_result,
                                   struct AnofoxError *out_error);

/**
 * Detect periods using specified method.
 *
 * # Safety
 * All pointer arguments must be valid and non-null. Arrays must have the specified lengths.
 */
bool anofox_ts_detect_periods(const double *values,
                              size_t length,
                              const char *method,
                              struct MultiPeriodResult *out_result,
                              struct AnofoxError *out_error);

/**
 * Detect multiple periods in a time series using the specified method.
 *
 * Returns a flattened result with parallel arrays for safer FFI.
 * This version avoids memory issues when used through R's DuckDB bindings.
 *
 * # Safety
 * All pointer arguments must be valid and non-null.
 */
bool anofox_ts_detect_periods_flat(const double *values,
                                   size_t length,
                                   const char *method,
                                   struct FlatMultiPeriodResult *out_result,
                                   struct AnofoxError *out_error);

/**
 * Estimate period using FFT.
 *
 * # Safety
 * All pointer arguments must be valid and non-null.
 */
bool anofox_ts_estimate_period_fft(const double *values,
                                   size_t length,
                                   struct SinglePeriodResult *out_result,
                                   struct AnofoxError *out_error);

/**
 * Estimate period using ACF.
 *
 * # Safety
 * All pointer arguments must be valid and non-null.
 */
bool anofox_ts_estimate_period_acf(const double *values,
                                   size_t length,
                                   int max_lag,
                                   struct SinglePeriodResult *out_result,
                                   struct AnofoxError *out_error);

/**
 * Detect multiple periods in time series.
 *
 * # Safety
 * All pointer arguments must be valid and non-null.
 */
bool anofox_ts_detect_multiple_periods(const double *values,
                                       size_t length,
                                       int max_periods,
                                       double min_confidence,
                                       double min_strength,
                                       struct MultiPeriodResult *out_result,
                                       struct AnofoxError *out_error);

/**
 * Detect multiple periods in time series.
 *
 * Returns a flattened result with parallel arrays for safer FFI.
 * This version avoids memory issues when used through R's DuckDB bindings.
 *
 * # Safety
 * All pointer arguments must be valid and non-null.
 */
bool anofox_ts_detect_multiple_periods_flat(const double *values,
                                            size_t length,
                                            int max_periods,
                                            double min_confidence,
                                            double min_strength,
                                            struct FlatMultiPeriodResult *out_result,
                                            struct AnofoxError *out_error);

/**
 * Detect peaks in time series.
 *
 * # Safety
 * All pointer arguments must be valid and non-null.
 */
bool anofox_ts_detect_peaks(const double *values,
                            size_t length,
                            double min_distance,
                            double min_prominence,
                            bool smooth_first,
                            struct PeakDetectionResultFFI *out_result,
                            struct AnofoxError *out_error);

/**
 * Analyze peak timing variability.
 *
 * # Safety
 * All pointer arguments must be valid and non-null.
 */
bool anofox_ts_analyze_peak_timing(const double *values,
                                   size_t length,
                                   double period,
                                   struct PeakTimingResultFFI *out_result,
                                   struct AnofoxError *out_error);

/**
 * Detrend time series using specified method.
 *
 * # Safety
 * All pointer arguments must be valid and non-null.
 */
bool anofox_ts_detrend(const double *values,
                       size_t length,
                       const char *method,
                       struct DetrendResultFFI *out_result,
                       struct AnofoxError *out_error);

/**
 * Decompose time series into trend, seasonal, and remainder.
 *
 * # Safety
 * All pointer arguments must be valid and non-null.
 */
bool anofox_ts_decompose(const double *values,
                         size_t length,
                         double period,
                         const char *method,
                         struct DecomposeResultFFI *out_result,
                         struct AnofoxError *out_error);

/**
 * Compute seasonal strength using specified method.
 *
 * # Safety
 * All pointer arguments must be valid and non-null.
 */
bool anofox_ts_seasonal_strength(const double *values,
                                 size_t length,
                                 double period,
                                 const char *method,
                                 double *out_strength,
                                 struct AnofoxError *out_error);

/**
 * Compute windowed seasonal strength.
 *
 * # Safety
 * All pointer arguments must be valid and non-null.
 */
bool anofox_ts_seasonal_strength_windowed(const double *values,
                                          size_t length,
                                          double period,
                                          double window_size,
                                          const char *method,
                                          double **out_strengths,
                                          size_t *out_n_windows,
                                          struct AnofoxError *out_error);

/**
 * Classify seasonality type and pattern.
 *
 * # Safety
 * All pointer arguments must be valid and non-null.
 */
bool anofox_ts_classify_seasonality(const double *values,
                                    size_t length,
                                    double period,
                                    double strength_threshold,
                                    double timing_threshold,
                                    struct SeasonalityClassificationFFI *out_result,
                                    struct AnofoxError *out_error);

/**
 * Detect seasonality changes over time.
 *
 * # Safety
 * All pointer arguments must be valid and non-null.
 */
bool anofox_ts_detect_seasonality_changes(const double *values,
                                          size_t length,
                                          double period,
                                          double threshold,
                                          double window_size,
                                          double min_duration,
                                          struct ChangeDetectionResultFFI *out_result,
                                          struct AnofoxError *out_error);

/**
 * Compute instantaneous period using Hilbert transform.
 *
 * # Safety
 * All pointer arguments must be valid and non-null.
 */
bool anofox_ts_instantaneous_period(const double *values,
                                    size_t length,
                                    struct InstantaneousPeriodResultFFI *out_result,
                                    struct AnofoxError *out_error);

/**
 * Detect amplitude modulation in seasonal time series.
 *
 * # Safety
 * All pointer arguments must be valid and non-null.
 */
bool anofox_ts_detect_amplitude_modulation(const double *values,
                                           size_t length,
                                           double period,
                                           double modulation_threshold,
                                           double seasonality_threshold,
                                           struct AmplitudeModulationResultFFI *out_result,
                                           struct AnofoxError *out_error);

/**
 * MSTL decomposition.
 *
 * # Arguments
 * * `insufficient_data_mode` - How to handle insufficient data:
 *   - 0 (Fail): Error on insufficient data (default)
 *   - 1 (Trend): Apply trend-only decomposition, seasonal components are empty
 *   - 2 (None): Skip decomposition entirely, return empty result
 *
 * # Safety
 * All pointer arguments must be valid and non-null. Arrays must have the specified lengths.
 */
bool anofox_ts_mstl_decomposition(const double *values,
                                  size_t length,
                                  const int *periods,
                                  size_t n_periods,
                                  int insufficient_data_mode,
                                  struct MstlResult *out_result,
                                  struct AnofoxError *out_error);

/**
 * Detect changepoints using PELT algorithm.
 *
 * # Safety
 * All pointer arguments must be valid and non-null. Arrays must have the specified lengths.
 */
bool anofox_ts_detect_changepoints(const double *values,
                                   size_t length,
                                   int min_size,
                                   double penalty,
                                   struct ChangepointResult *out_result,
                                   struct AnofoxError *out_error);

/**
 * BOCPD changepoint detection.
 *
 * # Safety
 * All pointer arguments must be valid and non-null. Arrays must have the specified lengths.
 */
bool anofox_ts_detect_changepoints_bocpd(const double *values,
                                         size_t length,
                                         double hazard_lambda,
                                         bool include_probabilities,
                                         struct BocpdResult *out_result,
                                         struct AnofoxError *out_error);

/**
 * Extract time series features.
 *
 * # Safety
 * All pointer arguments must be valid and non-null. Arrays must have the specified lengths.
 */
bool anofox_ts_features(const double *values,
                        size_t length,
                        struct FeaturesResult *out_result,
                        struct AnofoxError *out_error);

/**
 * Validate feature parameter keys and return warnings for unknown keys.
 *
 * # Safety
 * All pointer arguments must be valid and non-null. Arrays must have the specified lengths.
 */
bool anofox_ts_validate_feature_params(const char *const *param_names,
                                       size_t n_params,
                                       char ***out_warnings,
                                       size_t *out_n_warnings);

/**
 * Free warnings array returned by validate_feature_params.
 *
 * # Safety
 * The pointer must be valid or null.
 */
void anofox_free_warnings(char **warnings, size_t n_warnings);

/**
 * List available feature names.
 *
 * # Safety
 * All pointer arguments must be valid and non-null.
 */
bool anofox_ts_features_list(char **out_names, size_t *out_count);

/**
 * Generate forecasts for a time series.
 *
 * # Safety
 * All pointer arguments must be valid and non-null. Arrays must have the specified lengths.
 */
bool anofox_ts_forecast(const double *values,
                        const uint64_t *validity,
                        size_t length,
                        const struct ForecastOptions *options,
                        struct ForecastResult *out_result,
                        struct AnofoxError *out_error);

/**
 * Compute data quality metrics.
 *
 * # Safety
 * All pointer arguments must be valid and non-null. Arrays must have the specified lengths.
 */
bool anofox_ts_data_quality(const double *values,
                            const uint64_t *validity,
                            size_t length,
                            struct DataQualityResult *out_result,
                            struct AnofoxError *out_error);

/**
 * Fill NULL values with a constant.
 *
 * # Safety
 * All pointer arguments must be valid and non-null. Arrays must have the specified lengths.
 */
bool anofox_ts_fill_nulls_const(const double *values,
                                const uint64_t *validity,
                                size_t length,
                                double fill_value,
                                double **out_values,
                                struct AnofoxError *out_error);

/**
 * Fill NULL values with the series mean.
 *
 * # Safety
 * All pointer arguments must be valid and non-null. Arrays must have the specified lengths.
 */
bool anofox_ts_fill_nulls_mean(const double *values,
                               const uint64_t *validity,
                               size_t length,
                               double **out_values,
                               struct AnofoxError *out_error);

/**
 * Compute differences of a time series.
 *
 * # Safety
 * All pointer arguments must be valid and non-null. Arrays must have the specified lengths.
 */
bool anofox_ts_diff(const double *values,
                    size_t length,
                    int order,
                    double **out_values,
                    size_t *out_length,
                    struct AnofoxError *out_error);

/**
 * Fill gaps in a time series with new timestamps.
 *
 * # Safety
 * All pointer arguments must be valid and non-null. Arrays must have the specified lengths.
 */
bool anofox_ts_fill_gaps(const int64_t *dates,
                         const double *values,
                         const uint64_t *validity,
                         size_t length,
                         int64_t frequency_seconds,
                         struct GapFillResult *out_result,
                         struct AnofoxError *out_error);

/**
 * Fill forward to a target date.
 *
 * # Safety
 * All pointer arguments must be valid and non-null. Arrays must have the specified lengths.
 */
bool anofox_ts_fill_forward_dates(const int64_t *dates,
                                  const double *values,
                                  const uint64_t *validity,
                                  size_t length,
                                  int64_t target_date,
                                  int64_t frequency_seconds,
                                  struct GapFillResult *out_result,
                                  struct AnofoxError *out_error);

/**
 * Detect the frequency of a time series.
 *
 * # Safety
 * All pointer arguments must be valid and non-null. Arrays must have the specified lengths.
 */
bool anofox_ts_detect_frequency(const int64_t *dates,
                                size_t length,
                                int64_t *out_frequency,
                                struct AnofoxError *out_error);

/**
 * Fill NULL values with forward fill.
 *
 * # Safety
 * All pointer arguments must be valid and non-null. Arrays must have the specified lengths.
 */
bool anofox_ts_fill_nulls_forward(const double *values,
                                  const uint64_t *validity,
                                  size_t length,
                                  struct FilledValuesResult *out_result,
                                  struct AnofoxError *out_error);

/**
 * Fill NULL values with backward fill.
 *
 * # Safety
 * All pointer arguments must be valid and non-null. Arrays must have the specified lengths.
 */
bool anofox_ts_fill_nulls_backward(const double *values,
                                   const uint64_t *validity,
                                   size_t length,
                                   struct FilledValuesResult *out_result,
                                   struct AnofoxError *out_error);

/**
 * Fill NULL values with linear interpolation.
 *
 * # Safety
 * All pointer arguments must be valid and non-null. Arrays must have the specified lengths.
 */
bool anofox_ts_fill_nulls_interpolate(const double *values,
                                      const uint64_t *validity,
                                      size_t length,
                                      double **out_values,
                                      struct AnofoxError *out_error);

/**
 * Free a TsStatsResult.
 *
 * # Safety
 * The result pointer must be valid or null.
 */
void anofox_free_ts_stats_result(struct TsStatsResult *_result);

/**
 * Free a GapFillResult.
 *
 * # Safety
 * The result pointer must be valid or null.
 */
void anofox_free_gap_fill_result(struct GapFillResult *result);

/**
 * Free a FilledValuesResult.
 *
 * # Safety
 * The result pointer must be valid or null.
 */
void anofox_free_filled_values_result(struct FilledValuesResult *result);

/**
 * Free a ForecastResult.
 *
 * # Safety
 * The result pointer must be valid or null.
 */
void anofox_free_forecast_result(struct ForecastResult *result);

/**
 * Free a ChangepointResult.
 *
 * # Safety
 * The result pointer must be valid or null.
 */
void anofox_free_changepoint_result(struct ChangepointResult *result);

/**
 * Free a BocpdResult.
 *
 * # Safety
 * The result pointer must be valid or null.
 */
void anofox_free_bocpd_result(struct BocpdResult *result);

/**
 * Free a FeaturesResult.
 *
 * # Safety
 * The result pointer must be valid or null.
 */
void anofox_free_features_result(struct FeaturesResult *result);

/**
 * Free a SeasonalityResult.
 *
 * # Safety
 * The result pointer must be valid or null.
 */
void anofox_free_seasonality_result(struct SeasonalityResult *result);

/**
 * Free a MstlResult.
 *
 * # Safety
 * The result pointer must be valid or null.
 */
void anofox_free_mstl_result(struct MstlResult *result);

/**
 * Free a double array.
 *
 * # Safety
 * The pointer must be valid or null.
 */
void anofox_free_double_array(double *ptr);

/**
 * Free an int array.
 *
 * # Safety
 * The pointer must be valid or null.
 */
void anofox_free_int_array(int *ptr);

/**
 * Free a MultiPeriodResult.
 *
 * # Safety
 * The result pointer must be valid or null.
 */
void anofox_free_multi_period_result(struct MultiPeriodResult *result);

/**
 * Free a FlatMultiPeriodResult.
 *
 * Frees all parallel arrays allocated by the flat period detection functions.
 *
 * # Safety
 * The result pointer must be valid or null.
 */
void anofox_free_flat_multi_period_result(struct FlatMultiPeriodResult *result);

/**
 * Free a PeakDetectionResultFFI.
 *
 * # Safety
 * The result pointer must be valid or null.
 */
void anofox_free_peak_detection_result(struct PeakDetectionResultFFI *result);

/**
 * Free a PeakTimingResultFFI.
 *
 * # Safety
 * The result pointer must be valid or null.
 */
void anofox_free_peak_timing_result(struct PeakTimingResultFFI *result);

/**
 * Free a DetrendResultFFI.
 *
 * # Safety
 * The result pointer must be valid or null.
 */
void anofox_free_detrend_result(struct DetrendResultFFI *result);

/**
 * Free a DecomposeResultFFI.
 *
 * # Safety
 * The result pointer must be valid or null.
 */
void anofox_free_decompose_result(struct DecomposeResultFFI *result);

/**
 * Free a SeasonalityClassificationFFI.
 *
 * # Safety
 * The result pointer must be valid or null.
 */
void anofox_free_seasonality_classification_result(struct SeasonalityClassificationFFI *result);

/**
 * Free a ChangeDetectionResultFFI.
 *
 * # Safety
 * The result pointer must be valid or null.
 */
void anofox_free_change_detection_result(struct ChangeDetectionResultFFI *result);

/**
 * Free an InstantaneousPeriodResultFFI.
 *
 * # Safety
 * The result pointer must be valid or null.
 */
void anofox_free_instantaneous_period_result(struct InstantaneousPeriodResultFFI *result);

/**
 * Free an AmplitudeModulationResultFFI.
 *
 * # Safety
 * The result pointer must be valid or null.
 */
void anofox_free_amplitude_modulation_result(struct AmplitudeModulationResultFFI *result);

const char *anofox_fcst_version(void);

/**
 * Initialize telemetry from C/C++.
 *
 * # Safety
 * The api_key pointer must be valid or null.
 */
void anofox_telemetry_init(bool enabled, const char *api_key);

/**
 * Check if telemetry is enabled.
 */
bool anofox_telemetry_is_enabled(void);

/**
 * Capture extension load event from C/C++.
 */
void anofox_telemetry_capture_extension_load(void);

#ifdef __cplusplus
}  // extern "C"
#endif  // __cplusplus

#endif  /* ANOFOX_FCST_FFI_H */
