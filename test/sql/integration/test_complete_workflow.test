# name: test/sql/integration/test_complete_workflow.test
# description: Test complete workflow: EDA -> Data Prep -> Forecast
# group: [integration]

require anofox_forecast

statement ok
LOAD anofox_forecast;

# Create realistic raw data with quality issues
statement ok
CREATE TABLE sales_data AS
SELECT 
    '2023-01-01'::DATE + INTERVAL (i) DAY AS date,
    'product_A' AS product_id,
    CASE 
        WHEN i <= 60 THEN 1000.0 + i * 5.0 + 100.0 * SIN(i * 2 * PI() / 7)  -- Weekly seasonality
        WHEN i BETWEEN 61 AND 65 THEN NULL  -- Missing data
        WHEN i = 80 THEN 5000.0  -- Spike (outlier)
        ELSE 1000.0 + i * 5.0 + 100.0 * SIN(i * 2 * PI() / 7)
    END AS sales
FROM generate_series(1, 100) t(i)
WHERE i NOT IN (70, 71)  -- Missing days
UNION ALL
SELECT 
    '2023-01-01'::DATE + INTERVAL (i) DAY AS date,
    'product_B' AS product_id,
    500.0 + i * 3.0 + 50.0 * COS(i * 2 * PI() / 7) AS sales
FROM generate_series(1, 100) t(i);

# STEP 1: Exploratory Data Analysis
# Signature: (table_name, group_cols, date_col, value_col)
statement ok
CREATE TABLE eda_results AS
WITH stats AS (
    SELECT * FROM ts_stats(sales_data, product_id, date, sales)
),
quality AS (
    SELECT * FROM ts_quality_report(sales_data, product_id, date, sales)
),
gaps AS (
    SELECT * FROM ts_detect_gaps(sales_data, product_id, date, sales)
),
outliers AS (
    SELECT * FROM ts_detect_outliers(sales_data, product_id, date, sales)
)
SELECT 
    s.series_id AS product_id,
    s.length AS n_observations,
    s.mean_value AS avg_sales,
    s.std_value AS std_dev,
    q.n_null AS null_count,
    q.n_zeros AS zero_count,
    q.is_constant,
    g.n_gaps AS gap_count,
    o.n_outliers AS outlier_count
FROM stats s
JOIN quality q ON s.series_id = q.series_id
JOIN gaps g ON s.series_id = g.series_id
JOIN outliers o ON s.series_id = o.series_id;

# Verify EDA detected issues in product_A
query IIIII
SELECT 
    product_id = 'product_A',
    null_count > 0,
    gap_count > 0,
    outlier_count > 0,
    n_observations < 100  -- Due to gaps
FROM eda_results
WHERE product_id = 'product_A';
----
true	true	true	true	true

# Verify product_B is clean
query III
SELECT 
    product_id = 'product_B',
    null_count = 0,
    gap_count = 0
FROM eda_results
WHERE product_id = 'product_B';
----
true	true	true

# STEP 2: Data Preparation
# Signature: (table_name, group_cols, date_col, value_col)
statement ok
CREATE TABLE clean_sales AS
WITH step1 AS (
    -- Fill gaps in time series
    SELECT * FROM ts_fill_gaps(sales_data, product_id, date, sales)
),
step2 AS (
    -- Fill NULL values using forward fill
    SELECT * FROM ts_fill_nulls_forward(step1, product_id, date, sales)
),
step3 AS (
    -- Remove outliers
    SELECT * FROM ts_remove_outliers(step2, product_id, date, sales)
)
SELECT * FROM step3
ORDER BY product_id, date;

# Verify clean data has no NULLs
query I
SELECT COUNT(*) = 0
FROM clean_sales
WHERE sales IS NULL;
----
true

# Verify both products have 100 observations (gaps filled)
query I
SELECT COUNT(*) = 100
FROM clean_sales
WHERE product_id = 'product_A';
----
true

query I
SELECT COUNT(*) = 100
FROM clean_sales
WHERE product_id = 'product_B';
----
true

# STEP 3: Forecasting
# Using ts_forecast_by table macro
# Signature: (table_name, group_col, date_col, target_col, method, horizon, params)
statement ok
CREATE TABLE forecasts AS
SELECT 
    product_id,
    forecast_step,
    date_col,
    point_forecast,
    lower,
    upper,
    model_name,
    insample_fitted,
    confidence_level
FROM ts_forecast_by(
    clean_sales,
    'product_id',
    'date',
    'sales',
    'AutoETS',
    14,  -- 2-week forecast
    {'season_length': 7, 'return_insample': true, 'confidence_level': 0.95}
);

# Verify forecasts were generated for both products
query I
SELECT COUNT(DISTINCT product_id) = 2
FROM forecasts;
----
true

# Verify forecast horizon is correct (14 days × 2 products = 28 rows)
query I
SELECT COUNT(*) = 28
FROM forecasts;
----
true

# Verify in-sample fitted values are available (check first row for each product)
statement ok
CREATE TABLE insample_check AS
SELECT 
    product_id,
    insample_fitted
FROM forecasts
WHERE forecast_step = 1;

query I
SELECT COUNT(*) = 2
FROM insample_check
WHERE insample_fitted IS NOT NULL AND len(insample_fitted) = 100;
----
true

# Verify confidence level is set correctly
query R
SELECT DISTINCT confidence_level
FROM forecasts;
----
0.950000

# Verify prediction intervals exist and are reasonable
query II
SELECT 
    MIN(lower) < MIN(point_forecast) AS lower_check,
    MAX(upper) > MAX(point_forecast) AS upper_check
FROM forecasts
WHERE product_id = 'product_A';
----
true	true

# STEP 4: Model Comparison
# Test multiple models on the same clean data
statement ok
CREATE TABLE model_comparison AS
SELECT 
    'Naive' AS model_name,
    product_id,
    COUNT(*) AS n_forecasts
FROM ts_forecast_by(
    clean_sales,
    'product_id',
    'date',
    'sales',
    'Naive',
    14,
    NULL
)
GROUP BY product_id
UNION ALL
SELECT 
    'SeasonalNaive' AS model_name,
    product_id,
    COUNT(*) AS n_forecasts
FROM ts_forecast_by(
    clean_sales,
    'product_id',
    'date',
    'sales',
    'SeasonalNaive',
    14,
    {'seasonal_period': 7}
)
GROUP BY product_id
UNION ALL
SELECT 
    'AutoETS' AS model_name,
    product_id,
    COUNT(*) AS n_forecasts
FROM ts_forecast_by(
    clean_sales,
    'product_id',
    'date',
    'sales',
    'AutoETS',
    14,
    {'season_length': 7}
)
GROUP BY product_id;

# Verify all models generated forecasts for both products
query I
SELECT COUNT(*) = 6  -- 3 models × 2 products
FROM model_comparison;
----
true

# Verify all forecasts have correct length
query I
SELECT COUNT(*) = 6
FROM model_comparison
WHERE n_forecasts = 14;
----
true

# STEP 5: Final Reporting
statement ok
CREATE TABLE final_report AS
SELECT 
    e.product_id,
    e.n_observations AS historical_points,
    e.avg_sales,
    e.null_count AS data_quality_nulls,
    e.gap_count AS data_quality_gaps,
    e.outlier_count AS data_quality_outliers,
    f.confidence_level,
    f.point_forecast AS first_forecast
FROM eda_results e
JOIN (SELECT DISTINCT product_id, confidence_level, point_forecast 
      FROM forecasts WHERE forecast_step = 1) f 
ON e.product_id = f.product_id;

# Verify final report has all information
query I
SELECT COUNT(*) = 2
FROM final_report;
----
true

# Verify report has all required fields for product_A
query IIIII
SELECT 
    product_id = 'product_A',
    historical_points IS NOT NULL,
    avg_sales IS NOT NULL,
    confidence_level = 0.95,
    first_forecast IS NOT NULL
FROM final_report
WHERE product_id = 'product_A';
----
true	true	true	true	true

# Cleanup
statement ok
DROP TABLE sales_data;

statement ok
DROP TABLE eda_results;

statement ok
DROP TABLE clean_sales;

statement ok
DROP TABLE forecasts;

statement ok
DROP TABLE insample_check;

statement ok
DROP TABLE model_comparison;

statement ok
DROP TABLE final_report;
