# name: test/sql/integration/test_complete_workflow.test
# description: Test complete workflow: EDA -> Data Prep -> Forecast
# group: [anofox_forecast]

require anofox_forecast

statement ok
LOAD anofox_forecast;

# Create realistic raw data with quality issues
statement ok
CREATE TABLE sales_data AS
SELECT 
    '2023-01-01'::DATE + INTERVAL (i) DAY AS date,
    'product_A' AS product_id,
    CASE 
        WHEN i <= 60 THEN 1000.0 + i * 5.0 + 100.0 * SIN(i * 2 * PI() / 7)  -- Weekly seasonality
        WHEN i BETWEEN 61 AND 65 THEN NULL  -- Missing data
        WHEN i = 80 THEN 5000.0  -- Spike (outlier)
        ELSE 1000.0 + i * 5.0 + 100.0 * SIN(i * 2 * PI() / 7)
    END AS sales
FROM generate_series(1, 100) t(i)
WHERE i NOT IN (70, 71)  -- Missing days
UNION ALL
SELECT 
    '2023-01-01'::DATE + INTERVAL (i) DAY AS date,
    'product_B' AS product_id,
    500.0 + i * 3.0 + 50.0 * COS(i * 2 * PI() / 7) AS sales
FROM generate_series(1, 100) t(i);

# STEP 1: Exploratory Data Analysis
statement ok
CREATE TABLE eda_results AS
WITH stats AS (
    SELECT * FROM TS_STATS('sales_data', 'date', 'sales', 'product_id')
),
quality AS (
    SELECT * FROM TS_QUALITY_REPORT('sales_data', 'date', 'sales', 'product_id')
),
gaps AS (
    SELECT * FROM TS_DETECT_GAPS('sales_data', 'date', 'sales', 'product_id', 'DAY')
),
outliers AS (
    SELECT * FROM TS_DETECT_OUTLIERS('sales_data', 'date', 'sales', 'product_id', 3.0)
)
SELECT 
    s.product_id,
    s.count_value AS n_observations,
    s.mean AS avg_sales,
    s.std_dev,
    q.null_count,
    q.zero_count,
    q.is_constant,
    g.gap_count,
    o.outlier_count
FROM stats s
JOIN quality q ON s.product_id = q.product_id
JOIN gaps g ON s.product_id = g.product_id
JOIN outliers o ON s.product_id = o.product_id;

# Verify EDA detected issues in product_A
query IIIII
SELECT 
    product_id = 'product_A',
    null_count > 0,
    gap_count > 0,
    outlier_count > 0,
    n_observations < 100  -- Due to gaps
FROM eda_results
WHERE product_id = 'product_A';
----
true	true	true	true	true

# Verify product_B is clean
query III
SELECT 
    product_id = 'product_B',
    null_count = 0,
    gap_count = 0
FROM eda_results
WHERE product_id = 'product_B';
----
true	true	true

# STEP 2: Data Preparation
statement ok
CREATE TABLE clean_sales AS
WITH step1 AS (
    -- Fill gaps in time series
    SELECT * FROM TS_FILL_GAPS('sales_data', 'date', 'sales', 'product_id', 'DAY', 'linear')
),
step2 AS (
    -- Fill NULL values using forward fill
    SELECT * FROM TS_FILL_NULLS_FORWARD(step1, 'date', 'sales', 'product_id')
),
step3 AS (
    -- Remove outliers using cap strategy
    SELECT * FROM TS_REMOVE_OUTLIERS(step2, 'date', 'sales', 'product_id', 3.0, 'cap')
)
SELECT * FROM step3
ORDER BY product_id, date;

# Verify clean data has no NULLs
query I
SELECT COUNT(*) = 0
FROM clean_sales
WHERE sales IS NULL;
----
true

# Verify both products have 100 observations (gaps filled)
query I
SELECT COUNT(*) = 100
FROM clean_sales
WHERE product_id = 'product_A';
----
true

query I
SELECT COUNT(*) = 100
FROM clean_sales
WHERE product_id = 'product_B';
----
true

# STEP 3: Forecasting
statement ok
CREATE TABLE forecasts AS
SELECT 
    product_id,
    result.forecast,
    result.lower,
    result.upper,
    result.insample_fitted,
    result.confidence_level,
    result.model_info
FROM ts_forecast_by(
    clean_sales,
    'date',
    'sales',
    'product_id',
    'AutoETS',
    14,  -- 2-week forecast
    {'seasonal_period': 7, 'return_insample': true, 'confidence_level': 0.95}
) AS result;

# Verify forecasts were generated for both products
query I
SELECT COUNT(DISTINCT product_id) = 2
FROM forecasts;
----
true

# Verify forecast horizon is correct (14 days)
query I
SELECT len(forecast) = 14
FROM forecasts
WHERE product_id = 'product_A';
----
true

# Verify in-sample fitted values are returned (100 historical points)
query I
SELECT len(insample_fitted) = 100
FROM forecasts
WHERE product_id = 'product_A';
----
true

# Verify confidence level is set correctly
query R
SELECT confidence_level
FROM forecasts
WHERE product_id = 'product_A';
----
0.950000

# Verify prediction intervals exist and are reasonable
query III
SELECT 
    len(lower) = 14,
    len(upper) = 14,
    (SELECT AVG(upper[i] - lower[i]) FROM generate_series(1, 14) t(i)) > 0
FROM forecasts
WHERE product_id = 'product_A';
----
true	true	true

# STEP 4: Model Comparison
# Test multiple models on the same clean data
statement ok
CREATE TABLE model_comparison AS
SELECT 
    'Naive' AS model_name,
    product_id,
    result.forecast,
    result.model_info
FROM ts_forecast_by(
    clean_sales,
    'date',
    'sales',
    'product_id',
    'Naive',
    14,
    {}
) AS result
UNION ALL
SELECT 
    'SeasonalNaive' AS model_name,
    product_id,
    result.forecast,
    result.model_info
FROM ts_forecast_by(
    clean_sales,
    'date',
    'sales',
    'product_id',
    'SeasonalNaive',
    14,
    {'seasonal_period': 7}
) AS result
UNION ALL
SELECT 
    'AutoETS' AS model_name,
    product_id,
    result.forecast,
    result.model_info
FROM ts_forecast_by(
    clean_sales,
    'date',
    'sales',
    'product_id',
    'AutoETS',
    14,
    {'season_length': 7}
) AS result;

# Verify all models generated forecasts for both products
query I
SELECT COUNT(*) = 6  -- 3 models Ã— 2 products
FROM model_comparison;
----
true

# Verify all forecasts have correct length
query I
SELECT COUNT(*) = 6
FROM model_comparison
WHERE len(forecast) = 14;
----
true

# STEP 5: Forecast Evaluation (if we had actual future values)
# Create hypothetical actual future values
statement ok
CREATE TABLE actual_future AS
SELECT 
    '2023-04-11'::DATE + INTERVAL (i) DAY AS date,
    'product_A' AS product_id,
    1000.0 + (100 + i) * 5.0 + 100.0 * SIN((100 + i) * 2 * PI() / 7) AS actual_sales
FROM generate_series(1, 14) t(i)
UNION ALL
SELECT 
    '2023-04-11'::DATE + INTERVAL (i) DAY AS date,
    'product_B' AS product_id,
    500.0 + (100 + i) * 3.0 + 50.0 * COS((100 + i) * 2 * PI() / 7) AS actual_sales
FROM generate_series(1, 14) t(i);

# Calculate forecast accuracy metrics
statement ok
CREATE TABLE forecast_accuracy AS
SELECT 
    f.product_id,
    TS_MAE(
        (SELECT list(actual_sales ORDER BY date) FROM actual_future af WHERE af.product_id = f.product_id),
        f.forecast
    ) AS mae,
    TS_RMSE(
        (SELECT list(actual_sales ORDER BY date) FROM actual_future af WHERE af.product_id = f.product_id),
        f.forecast
    ) AS rmse,
    TS_MAPE(
        (SELECT list(actual_sales ORDER BY date) FROM actual_future af WHERE af.product_id = f.product_id),
        f.forecast
    ) AS mape
FROM forecasts f;

# Verify metrics are calculated
query I
SELECT COUNT(*) = 2
FROM forecast_accuracy;
----
true

# Verify metrics are reasonable (not NULL, not infinite)
query III
SELECT 
    mae IS NOT NULL AND mae > 0,
    rmse IS NOT NULL AND rmse > 0,
    mape IS NOT NULL AND mape >= 0
FROM forecast_accuracy
WHERE product_id = 'product_A';
----
true	true	true

# STEP 6: Complete reporting table
statement ok
CREATE TABLE final_report AS
SELECT 
    e.product_id,
    e.n_observations AS historical_points,
    e.avg_sales,
    e.null_count AS data_quality_nulls,
    e.gap_count AS data_quality_gaps,
    e.outlier_count AS data_quality_outliers,
    f.confidence_level,
    fa.mae AS forecast_mae,
    fa.rmse AS forecast_rmse,
    fa.mape AS forecast_mape,
    f.forecast AS forecast_values,
    f.lower AS forecast_lower,
    f.upper AS forecast_upper
FROM eda_results e
JOIN forecasts f ON e.product_id = f.product_id
JOIN forecast_accuracy fa ON e.product_id = fa.product_id;

# Verify final report has all information
query I
SELECT COUNT(*) = 2
FROM final_report;
----
true

# Verify report has all required fields for product_A
query IIIIIII
SELECT 
    product_id = 'product_A',
    historical_points IS NOT NULL,
    avg_sales IS NOT NULL,
    confidence_level = 0.95,
    forecast_mae IS NOT NULL,
    len(forecast_values) = 14,
    len(forecast_lower) = 14
FROM final_report
WHERE product_id = 'product_A';
----
true	true	true	true	true	true	true

# Cleanup
statement ok
DROP TABLE sales_data;

statement ok
DROP TABLE eda_results;

statement ok
DROP TABLE clean_sales;

statement ok
DROP TABLE forecasts;

statement ok
DROP TABLE model_comparison;

statement ok
DROP TABLE actual_future;

statement ok
DROP TABLE forecast_accuracy;

statement ok
DROP TABLE final_report;

