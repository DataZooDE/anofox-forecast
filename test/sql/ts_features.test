# name: test/sql/ts_features.test
# description: Tests for ts_features aggregate function (C++ API compatible)
# group: [sql]

require anofox_forecast

require json

#######################################
# ts_features_list - List Available Features
#######################################

# Test ts_features_list returns non-empty table
query I
SELECT count(*) > 0 FROM ts_features_list();
----
true

# Test ts_features_list returns rows
query I
SELECT feature_name IS NOT NULL FROM ts_features_list() LIMIT 1;
----
true

#######################################
# ts_features_config_template - Config Template
#######################################

# Test ts_features_config_template returns non-empty table
query I
SELECT count(*) > 0 FROM ts_features_config_template();
----
true

# Test ts_features_config_template has feature and params_json columns
query II
SELECT feature IS NOT NULL, params_json IS NOT NULL FROM ts_features_config_template() LIMIT 1;
----
true	true

#######################################
# ts_features - Aggregate Function Tests (C++ API Compatible)
# Signature: ts_features(ts_col, val_col) â†’ STRUCT
#######################################

# Test ts_features aggregate returns STRUCT (2-param version)
query I
SELECT (SELECT ts_features(ts, val) FROM (
    SELECT '2023-01-01'::TIMESTAMP + INTERVAL (i) DAY as ts, i::DOUBLE as val
    FROM range(1, 11) t(i)
)).mean IS NOT NULL;
----
true

# Test ts_features aggregate mean calculation
query I
SELECT ABS((SELECT ts_features(ts, val) FROM (
    SELECT '2023-01-01'::TIMESTAMP + INTERVAL (i) DAY as ts, i::DOUBLE as val
    FROM range(1, 11) t(i)
)).mean - 5.5) < 0.01;
----
true

# Test length feature
query I
SELECT (SELECT ts_features(ts, val) FROM (
    SELECT '2023-01-01'::TIMESTAMP + INTERVAL (i) DAY as ts, i::DOUBLE as val
    FROM range(1, 11) t(i)
)).length = 10;
----
true

# Test variance is positive
query I
SELECT (SELECT ts_features(ts, val) FROM (
    SELECT '2023-01-01'::TIMESTAMP + INTERVAL (i) DAY as ts, i::DOUBLE as val
    FROM range(1, 11) t(i)
)).variance > 0;
----
true

# Test min/max features
query I
SELECT (SELECT ts_features(ts, val) FROM (
    SELECT '2023-01-01'::TIMESTAMP + INTERVAL (i) DAY as ts, i::DOUBLE as val
    FROM range(1, 11) t(i)
)).minimum = 1.0;
----
true

query I
SELECT (SELECT ts_features(ts, val) FROM (
    SELECT '2023-01-01'::TIMESTAMP + INTERVAL (i) DAY as ts, i::DOUBLE as val
    FROM range(1, 11) t(i)
)).maximum = 10.0;
----
true

#######################################
# 3-parameter version with feature_selection
#######################################

# Test 3-parameter version with feature_selection (NULL)
query I
SELECT (SELECT ts_features(ts, val, NULL) FROM (
    SELECT '2023-01-01'::TIMESTAMP + INTERVAL (i) DAY as ts, i::DOUBLE as val
    FROM range(1, 11) t(i)
)).mean IS NOT NULL;
----
true

# Test 3-parameter version with feature_selection list
query I
SELECT (SELECT ts_features(ts, val, ['mean', 'variance']) FROM (
    SELECT '2023-01-01'::TIMESTAMP + INTERVAL (i) DAY as ts, i::DOUBLE as val
    FROM range(1, 11) t(i)
)).mean IS NOT NULL;
----
true

#######################################
# 4-parameter version with feature_selection and feature_params
#######################################

# Test 4-parameter version with feature_selection and feature_params (NULL, NULL)
query I
SELECT (SELECT ts_features(ts, val, NULL, NULL) FROM (
    SELECT '2023-01-01'::TIMESTAMP + INTERVAL (i) DAY as ts, i::DOUBLE as val
    FROM range(1, 11) t(i)
)).variance IS NOT NULL;
----
true

#######################################
# Different Series Types
#######################################

# Constant series - variance should be zero
query I
SELECT (SELECT ts_features(ts, val) FROM (
    SELECT '2023-01-01'::TIMESTAMP + INTERVAL (i) DAY as ts, 5.0 as val
    FROM range(1, 11) t(i)
)).variance < 0.001;
----
true

# Seasonal series - features should exist
query I
SELECT (SELECT ts_features(ts, val) FROM (
    SELECT '2023-01-01'::TIMESTAMP + INTERVAL (i) DAY as ts, (1 + (i % 4))::DOUBLE as val
    FROM range(0, 12) t(i)
)).mean IS NOT NULL;
----
true

#######################################
# ts_features_agg - Alias Test
#######################################

# Test ts_features_agg alias works same as ts_features
query I
SELECT (SELECT ts_features_agg(ts, val) FROM (
    SELECT '2023-01-01'::TIMESTAMP + INTERVAL (i) DAY as ts, i::DOUBLE as val
    FROM range(1, 11) t(i)
)).mean IS NOT NULL;
----
true

#######################################
# ts_features_table - Single-Series Table Macro Tests
#######################################

statement ok
CREATE TABLE test_single_series AS
SELECT ('2023-01-01'::DATE + (i || ' days')::INTERVAL)::TIMESTAMP AS date,
       (i + 1)::DOUBLE AS value
FROM generate_series(0, 9) AS t(i);

# Test ts_features_table returns a result
query I
SELECT mean IS NOT NULL FROM ts_features_table('test_single_series', date, value);
----
true

# Test ts_features_table mean calculation
query I
SELECT ABS(mean - 5.5) < 0.01 FROM ts_features_table('test_single_series', date, value);
----
true

# Test ts_features_table length
query I
SELECT length = 10 FROM ts_features_table('test_single_series', date, value);
----
true

statement ok
DROP TABLE test_single_series;

#######################################
# ts_features_by - Multi-Series Table Macro Tests
#######################################

statement ok
CREATE TABLE test_multi_series AS
SELECT 'A' AS id,
       ('2023-01-01'::DATE + (i || ' days')::INTERVAL)::TIMESTAMP AS date,
       (i + 1)::DOUBLE AS value
FROM generate_series(0, 9) AS t(i)
UNION ALL
SELECT 'B' AS id,
       ('2023-01-01'::DATE + (i || ' days')::INTERVAL)::TIMESTAMP AS date,
       (i * 2)::DOUBLE AS value
FROM generate_series(0, 9) AS t(i);

# Test ts_features_by returns correct number of rows
query I
SELECT count(*) FROM ts_features_by('test_multi_series', id, date, value);
----
2

# Test ts_features_by has id column
query I
SELECT count(DISTINCT id) FROM ts_features_by('test_multi_series', id, date, value);
----
2

# Test ts_features_by mean per group
query IR
SELECT id, mean FROM ts_features_by('test_multi_series', id, date, value) ORDER BY id;
----
A	5.5
B	9.0

# Test ts_features_by length per group
query IR
SELECT id, length FROM ts_features_by('test_multi_series', id, date, value) ORDER BY id;
----
A	10.0
B	10.0

statement ok
DROP TABLE test_multi_series;
