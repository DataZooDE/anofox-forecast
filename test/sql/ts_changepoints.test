# name: test/sql/ts_changepoints.test
# description: Tests for ts_detect_changepoints table function (C++ API compatible)
# group: [sql]

require anofox_forecast

#######################################
# Internal _ts_detect_changepoints_bocpd Tests
#######################################

# Test returns STRUCT with is_changepoint field
query I
SELECT (_ts_detect_changepoints_bocpd([1.0, 1.0, 1.0, 1.0, 10.0, 10.0, 10.0, 10.0], 250.0, false)).is_changepoint IS NOT NULL;
----
true

# Test returns STRUCT with changepoint_probability field
query I
SELECT (_ts_detect_changepoints_bocpd([1.0, 1.0, 1.0, 1.0, 10.0, 10.0, 10.0, 10.0], 250.0, false)).changepoint_probability IS NOT NULL;
----
true

# Test returns STRUCT with changepoint_indices field
query I
SELECT (_ts_detect_changepoints_bocpd([1.0, 1.0, 1.0, 1.0, 10.0, 10.0, 10.0, 10.0], 250.0, false)).changepoint_indices IS NOT NULL;
----
true

# Test is_changepoint array has same length as input
query I
SELECT length((_ts_detect_changepoints_bocpd([1.0, 1.0, 1.0, 1.0, 10.0, 10.0, 10.0, 10.0], 250.0, false)).is_changepoint);
----
8

# Test changepoint_probability array has same length as input
query I
SELECT length((_ts_detect_changepoints_bocpd([1.0, 1.0, 1.0, 1.0, 10.0, 10.0, 10.0, 10.0], 250.0, false)).changepoint_probability);
----
8

#######################################
# Constant Series Tests
#######################################

# Constant series - should have no changepoints
query I
SELECT length((_ts_detect_changepoints_bocpd([5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0], 250.0, false)).changepoint_indices);
----
0

#######################################
# Boundary Condition Tests (GH#50)
# First/last observations should NOT be artificially marked as changepoints
#######################################

# First observation should NEVER be marked as changepoint (no prior segment exists)
query I
SELECT (_ts_detect_changepoints_bocpd([5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0], 250.0, true)).is_changepoint[1];
----
false

# Last observation should NOT be artificially marked as changepoint
query I
SELECT (_ts_detect_changepoints_bocpd([5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0], 250.0, true)).is_changepoint[8];
----
false

# Stable series with small random noise - first observation should not be changepoint
query I
SELECT (_ts_detect_changepoints_bocpd([50.1, 50.2, 50.3, 50.1, 50.4, 50.2, 50.3, 50.1], 250.0, true)).is_changepoint[1];
----
false

# Stable series with small random noise - last observation should not be changepoint
query I
SELECT (_ts_detect_changepoints_bocpd([50.1, 50.2, 50.3, 50.1, 50.4, 50.2, 50.3, 50.1], 250.0, true)).is_changepoint[8];
----
false

# Note: First observation probability (P(r=1)) is naturally high since there's no prior run.
# This is correct BOCPD behavior. The key is that is_changepoint[1] is FALSE (tested above).

# Changepoint probability for middle observations in stable series should be low (< 0.1)
# Testing position 5 (middle of series) to verify posterior is properly updating
query I
SELECT (_ts_detect_changepoints_bocpd([5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0], 250.0, true)).changepoint_probability[5] < 0.1;
----
true

# Changepoint probability for last observation should be low (< 0.1) for stable series
query I
SELECT (_ts_detect_changepoints_bocpd([5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0], 250.0, true)).changepoint_probability[8] < 0.1;
----
true

# Index 0 should NOT appear in changepoint_indices for stable data
query I
SELECT list_contains((_ts_detect_changepoints_bocpd([5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0], 250.0, true)).changepoint_indices, 0::UBIGINT);
----
false

# Last index (n-1) should NOT appear in changepoint_indices for stable data
query I
SELECT list_contains((_ts_detect_changepoints_bocpd([5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0], 250.0, true)).changepoint_indices, 7::UBIGINT);
----
false

#######################################
# NULL Handling
#######################################

# NULL input should return NULL
query I
SELECT _ts_detect_changepoints_bocpd(NULL, 250.0, false) IS NULL;
----
true

#######################################
# Table Function API Tests
#######################################

statement ok
CREATE TABLE changepoint_test AS
SELECT ('2023-01-01'::DATE + (i || ' day')::INTERVAL)::TIMESTAMP AS date,
       CASE WHEN i < 5 THEN 1.0 ELSE 10.0 END AS val
FROM generate_series(0, 9) AS t(i);

# Test ts_detect_changepoints table function returns results
query I
SELECT COUNT(*) FROM ts_detect_changepoints('changepoint_test', date, val, MAP(['hazard_lambda'], ['250.0']));
----
10

statement ok
DROP TABLE changepoint_test;

#######################################
# ts_detect_changepoints_agg - Aggregate Function Tests
#######################################

# Test ts_detect_changepoints_agg returns LIST
query I
SELECT (SELECT ts_detect_changepoints_agg(ts, val, MAP([], [])) FROM (
    SELECT '2023-01-01'::TIMESTAMP + INTERVAL (i) DAY as ts,
           CASE WHEN i < 5 THEN 1.0 ELSE 10.0 END as val
    FROM range(0, 10) t(i)
)) IS NOT NULL;
----
true

# Test list length matches input length
query I
SELECT length((SELECT ts_detect_changepoints_agg(ts, val, MAP([], [])) FROM (
    SELECT '2023-01-01'::TIMESTAMP + INTERVAL (i) DAY as ts,
           CASE WHEN i < 5 THEN 1.0 ELSE 10.0 END as val
    FROM range(0, 10) t(i)
)));
----
10

# Test STRUCT fields exist - timestamp
query I
SELECT ((SELECT ts_detect_changepoints_agg(ts, val, MAP([], [])) FROM (
    SELECT '2023-01-01'::TIMESTAMP + INTERVAL (i) DAY as ts,
           CASE WHEN i < 5 THEN 1.0 ELSE 10.0 END as val
    FROM range(0, 10) t(i)
))[1]).timestamp IS NOT NULL;
----
true

# Test STRUCT fields exist - value
query I
SELECT ((SELECT ts_detect_changepoints_agg(ts, val, MAP([], [])) FROM (
    SELECT '2023-01-01'::TIMESTAMP + INTERVAL (i) DAY as ts,
           CASE WHEN i < 5 THEN 1.0 ELSE 10.0 END as val
    FROM range(0, 10) t(i)
))[1]).value IS NOT NULL;
----
true

# Test STRUCT fields exist - is_changepoint
query I
SELECT ((SELECT ts_detect_changepoints_agg(ts, val, MAP([], [])) FROM (
    SELECT '2023-01-01'::TIMESTAMP + INTERVAL (i) DAY as ts,
           CASE WHEN i < 5 THEN 1.0 ELSE 10.0 END as val
    FROM range(0, 10) t(i)
))[1]).is_changepoint IS NOT NULL;
----
true

# Test STRUCT fields exist - changepoint_probability
query I
SELECT ((SELECT ts_detect_changepoints_agg(ts, val, MAP([], [])) FROM (
    SELECT '2023-01-01'::TIMESTAMP + INTERVAL (i) DAY as ts,
           CASE WHEN i < 5 THEN 1.0 ELSE 10.0 END as val
    FROM range(0, 10) t(i)
))[1]).changepoint_probability IS NOT NULL;
----
true

# Test with constant series - no changepoints expected (all is_changepoint should be false)
query I
SELECT list_reduce(
    list_transform(
        (SELECT ts_detect_changepoints_agg(ts, val, MAP([], [])) FROM (
            SELECT '2023-01-01'::TIMESTAMP + INTERVAL (i) DAY as ts, 5.0 as val
            FROM range(0, 10) t(i)
        )),
        x -> CASE WHEN x.is_changepoint THEN 1 ELSE 0 END
    ),
    (a, b) -> a + b
) = 0;
----
true

# Test with hazard_lambda parameter
query I
SELECT length((SELECT ts_detect_changepoints_agg(ts, val, MAP(['hazard_lambda'], ['100.0'])) FROM (
    SELECT '2023-01-01'::TIMESTAMP + INTERVAL (i) DAY as ts,
           CASE WHEN i < 5 THEN 1.0 ELSE 10.0 END as val
    FROM range(0, 10) t(i)
)));
----
10

# Test GROUP BY with aggregate - multiple groups
statement ok
CREATE TABLE changepoints_agg_test AS
SELECT 'A' as grp, '2023-01-01'::TIMESTAMP + INTERVAL (i) DAY as ts,
       CASE WHEN i < 5 THEN 1.0 ELSE 10.0 END as val
FROM range(0, 10) t(i)
UNION ALL
SELECT 'B' as grp, '2023-01-01'::TIMESTAMP + INTERVAL (i) DAY as ts,
       CASE WHEN i < 3 THEN 2.0 ELSE 20.0 END as val
FROM range(0, 10) t(i);

# Test aggregate with GROUP BY returns one result per group
query I
SELECT COUNT(*) FROM (
    SELECT grp, ts_detect_changepoints_agg(ts, val, MAP([], [])) as cps
    FROM changepoints_agg_test
    GROUP BY grp
);
----
2

# Test each group has correct list length
query I
SELECT length(ts_detect_changepoints_agg(ts, val, MAP([], []))) = 10
FROM changepoints_agg_test
GROUP BY grp
ORDER BY grp
LIMIT 1;
----
true

statement ok
DROP TABLE changepoints_agg_test;

#######################################
# ts_detect_changepoints_by - Table Macro Tests
#######################################

statement ok
CREATE TABLE changepoints_by_test AS
SELECT 'A' as grp, '2023-01-01'::TIMESTAMP + INTERVAL (i) DAY as ts,
       CASE WHEN i < 5 THEN 1.0 ELSE 10.0 END as val
FROM range(0, 10) t(i)
UNION ALL
SELECT 'B' as grp, '2023-01-01'::TIMESTAMP + INTERVAL (i) DAY as ts,
       CASE WHEN i < 3 THEN 2.0 ELSE 20.0 END as val
FROM range(0, 10) t(i);

# Test ts_detect_changepoints_by returns results
query I
SELECT COUNT(*) FROM ts_detect_changepoints_by('changepoints_by_test', grp, ts, val, MAP([], []));
----
2

# Test ts_detect_changepoints_by has id column
query I
SELECT COUNT(DISTINCT id) FROM ts_detect_changepoints_by('changepoints_by_test', grp, ts, val, MAP([], []));
----
2

# Test ts_detect_changepoints_by has changepoints column
query I
SELECT (changepoints).is_changepoint IS NOT NULL
FROM ts_detect_changepoints_by('changepoints_by_test', grp, ts, val, MAP([], []))
LIMIT 1;
----
true

# Test changepoints STRUCT has changepoint_probability field
query I
SELECT (changepoints).changepoint_probability IS NOT NULL
FROM ts_detect_changepoints_by('changepoints_by_test', grp, ts, val, MAP([], []))
LIMIT 1;
----
true

# Test changepoints STRUCT has changepoint_indices field
query I
SELECT (changepoints).changepoint_indices IS NOT NULL
FROM ts_detect_changepoints_by('changepoints_by_test', grp, ts, val, MAP([], []))
LIMIT 1;
----
true

# Test with hazard_lambda parameter
query I
SELECT COUNT(*) FROM ts_detect_changepoints_by('changepoints_by_test', grp, ts, val, MAP(['hazard_lambda'], ['100.0']));
----
2

# Test with include_probabilities parameter
query I
SELECT COUNT(*) FROM ts_detect_changepoints_by('changepoints_by_test', grp, ts, val, MAP(['include_probabilities'], ['true']));
----
2

statement ok
DROP TABLE changepoints_by_test;

#######################################
# Issue #71 Regression Tests
# BOCPD should return varying probabilities, not constant 1/hazard_lambda
#######################################

# Create test data with obvious step change: 100 for 12 points, then 10 for 12 points
statement ok
CREATE TABLE step_change_test AS
SELECT ('2023-01-01'::DATE + (i || ' day')::INTERVAL)::TIMESTAMP AS ts,
       CASE WHEN i < 12 THEN 100.0 ELSE 10.0 END AS val
FROM generate_series(0, 23) AS t(i);

# Test: Probabilities should NOT all be constant (the original bug)
# If fixed, max probability should be much higher than min probability
query I
SELECT
    max(prob) > min(prob) * 10  -- At changepoint, prob should be >>10x higher than baseline
FROM (
    SELECT unnest((_ts_detect_changepoints_bocpd(
        list(val ORDER BY ts), 10.0, true
    )).changepoint_probability) as prob
    FROM step_change_test
);
----
true

# Test: Probability at changepoint (index 12) should be significant (>0.5)
# Index is 0-based, so changepoint at position 12 is element 13 in 1-based array
query I
SELECT (_ts_detect_changepoints_bocpd(
    list(val ORDER BY ts), 10.0, true
)).changepoint_probability[13] > 0.5
FROM step_change_test;
----
true

# Test: Probability before changepoint (index 5-10) should be low (<0.1)
query I
SELECT
    avg(prob) < 0.1
FROM (
    SELECT unnest((_ts_detect_changepoints_bocpd(
        list(val ORDER BY ts), 10.0, true
    )).changepoint_probability[6:11]) as prob
    FROM step_change_test
);
----
true

# Test: Changepoint should be detected at index 12
query I
SELECT list_contains(
    (_ts_detect_changepoints_bocpd(
        list(val ORDER BY ts), 10.0, true
    )).changepoint_indices,
    12::UBIGINT
)
FROM step_change_test;
----
true

# Test via table function: ts_detect_changepoints should detect the step change
query I
SELECT COUNT(*) FROM ts_detect_changepoints('step_change_test', ts, val, MAP(['hazard_lambda'], ['10.0']))
WHERE is_changepoint = true;
----
1

# Test via table function: The detected changepoint should be at the correct position
query I
SELECT EXTRACT(DAY FROM date_col - '2023-01-01'::TIMESTAMP)::INTEGER
FROM ts_detect_changepoints('step_change_test', ts, val, MAP(['hazard_lambda'], ['10.0']))
WHERE is_changepoint = true;
----
12

# Test via aggregate function: Should also detect the changepoint
query I
SELECT list_reduce(
    list_transform(
        ts_detect_changepoints_agg(ts, val, MAP(['hazard_lambda'], ['10.0'])),
        x -> CASE WHEN x.is_changepoint THEN 1 ELSE 0 END
    ),
    (a, b) -> a + b
) = 1
FROM step_change_test;
----
true

statement ok
DROP TABLE step_change_test;

# Test with multiple step changes
statement ok
CREATE TABLE multi_step_test AS
SELECT ('2023-01-01'::DATE + (i || ' day')::INTERVAL)::TIMESTAMP AS ts,
       CASE
           WHEN i < 10 THEN 100.0
           WHEN i < 20 THEN 10.0
           ELSE 50.0
       END AS val
FROM generate_series(0, 29) AS t(i);

# Multiple changepoints should be detected (at least 2)
query I
SELECT COUNT(*) >= 2
FROM ts_detect_changepoints('multi_step_test', ts, val, MAP(['hazard_lambda'], ['10.0']))
WHERE is_changepoint = true;
----
true

# First changepoint should be around index 10
query I
SELECT EXTRACT(DAY FROM date_col - '2023-01-01'::TIMESTAMP)::INTEGER BETWEEN 9 AND 11
FROM ts_detect_changepoints('multi_step_test', ts, val, MAP(['hazard_lambda'], ['10.0']))
WHERE is_changepoint = true
ORDER BY date_col
LIMIT 1;
----
true

statement ok
DROP TABLE multi_step_test;
