# name: test/sql/ts_changepoints.test
# description: Tests for ts_detect_changepoints table function (C++ API compatible)
# group: [sql]

require anofox_forecast

require json

#######################################
# Internal _ts_detect_changepoints_bocpd Tests
#######################################

# Test returns STRUCT with is_changepoint field
query I
SELECT (_ts_detect_changepoints_bocpd([1.0, 1.0, 1.0, 1.0, 10.0, 10.0, 10.0, 10.0], 250.0, false)).is_changepoint IS NOT NULL;
----
true

# Test returns STRUCT with changepoint_probability field
query I
SELECT (_ts_detect_changepoints_bocpd([1.0, 1.0, 1.0, 1.0, 10.0, 10.0, 10.0, 10.0], 250.0, false)).changepoint_probability IS NOT NULL;
----
true

# Test returns STRUCT with changepoint_indices field
query I
SELECT (_ts_detect_changepoints_bocpd([1.0, 1.0, 1.0, 1.0, 10.0, 10.0, 10.0, 10.0], 250.0, false)).changepoint_indices IS NOT NULL;
----
true

# Test is_changepoint array has same length as input
query I
SELECT length((_ts_detect_changepoints_bocpd([1.0, 1.0, 1.0, 1.0, 10.0, 10.0, 10.0, 10.0], 250.0, false)).is_changepoint);
----
8

# Test changepoint_probability array has same length as input
query I
SELECT length((_ts_detect_changepoints_bocpd([1.0, 1.0, 1.0, 1.0, 10.0, 10.0, 10.0, 10.0], 250.0, false)).changepoint_probability);
----
8

#######################################
# Constant Series Tests
#######################################

# Constant series - should have no changepoints
query I
SELECT length((_ts_detect_changepoints_bocpd([5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0], 250.0, false)).changepoint_indices);
----
0

#######################################
# Boundary Condition Tests (GH#50)
# First/last observations should NOT be artificially marked as changepoints
#######################################

# First observation should NEVER be marked as changepoint (no prior segment exists)
query I
SELECT (_ts_detect_changepoints_bocpd([5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0], 250.0, true)).is_changepoint[1];
----
false

# Last observation should NOT be artificially marked as changepoint
query I
SELECT (_ts_detect_changepoints_bocpd([5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0], 250.0, true)).is_changepoint[8];
----
false

# Stable series with small random noise - first observation should not be changepoint
query I
SELECT (_ts_detect_changepoints_bocpd([50.1, 50.2, 50.3, 50.1, 50.4, 50.2, 50.3, 50.1], 250.0, true)).is_changepoint[1];
----
false

# Stable series with small random noise - last observation should not be changepoint
query I
SELECT (_ts_detect_changepoints_bocpd([50.1, 50.2, 50.3, 50.1, 50.4, 50.2, 50.3, 50.1], 250.0, true)).is_changepoint[8];
----
false

# Note: First observation probability (P(r=1)) is naturally high since there's no prior run.
# This is correct BOCPD behavior. The key is that is_changepoint[1] is FALSE (tested above).

# Changepoint probability for middle observations in stable series should be low (< 0.1)
# Testing position 5 (middle of series) to verify posterior is properly updating
query I
SELECT (_ts_detect_changepoints_bocpd([5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0], 250.0, true)).changepoint_probability[5] < 0.1;
----
true

# Changepoint probability for last observation should be low (< 0.1) for stable series
query I
SELECT (_ts_detect_changepoints_bocpd([5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0], 250.0, true)).changepoint_probability[8] < 0.1;
----
true

# Index 0 should NOT appear in changepoint_indices for stable data
query I
SELECT list_contains((_ts_detect_changepoints_bocpd([5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0], 250.0, true)).changepoint_indices, 0::UBIGINT);
----
false

# Last index (n-1) should NOT appear in changepoint_indices for stable data
query I
SELECT list_contains((_ts_detect_changepoints_bocpd([5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0], 250.0, true)).changepoint_indices, 7::UBIGINT);
----
false

#######################################
# NULL Handling
#######################################

# NULL input should return NULL
query I
SELECT _ts_detect_changepoints_bocpd(NULL, 250.0, false) IS NULL;
----
true

#######################################
# Empty/Small Array Edge Cases (Issue #82)
#######################################

# Empty array should return NULL (not crash)
query I
SELECT _ts_detect_changepoints_bocpd([]::DOUBLE[], 250.0, false) IS NULL;
----
true

# Single element should return NULL (need at least 3 points for BOCPD)
query I
SELECT _ts_detect_changepoints_bocpd([5.0], 250.0, false) IS NULL;
----
true

# Two elements should return NULL (BOCPD needs at least 3 points)
query I
SELECT _ts_detect_changepoints_bocpd([5.0, 10.0], 250.0, false) IS NULL;
----
true

# Three elements should work (minimum valid input for BOCPD)
query I
SELECT _ts_detect_changepoints_bocpd([5.0, 5.0, 5.0], 250.0, false) IS NOT NULL;
----
true

# Three identical elements should have no changepoints
query I
SELECT length((_ts_detect_changepoints_bocpd([5.0, 5.0, 5.0], 250.0, false)).changepoint_indices);
----
0

# Three elements returns array of length 3
query I
SELECT length((_ts_detect_changepoints_bocpd([5.0, 5.0, 5.0], 250.0, false)).is_changepoint);
----
3

#######################################
# Table Function API Tests
#######################################

statement ok
CREATE TABLE changepoint_test AS
SELECT ('2023-01-01'::DATE + (i || ' day')::INTERVAL)::TIMESTAMP AS date,
       CASE WHEN i < 5 THEN 1.0 ELSE 10.0 END AS val
FROM generate_series(0, 9) AS t(i);

# Test ts_detect_changepoints table function returns results
query I
SELECT COUNT(*) FROM ts_detect_changepoints('changepoint_test', date, val, MAP(['hazard_lambda'], ['250.0']));
----
10

statement ok
DROP TABLE changepoint_test;

#######################################
# ts_detect_changepoints_agg - Aggregate Function Tests
#######################################

# Test ts_detect_changepoints_agg returns LIST
query I
SELECT (SELECT ts_detect_changepoints_agg(ts, val, MAP([], [])) FROM (
    SELECT '2023-01-01'::TIMESTAMP + INTERVAL (i) DAY as ts,
           CASE WHEN i < 5 THEN 1.0 ELSE 10.0 END as val
    FROM range(0, 10) t(i)
)) IS NOT NULL;
----
true

# Test list length matches input length
query I
SELECT length((SELECT ts_detect_changepoints_agg(ts, val, MAP([], [])) FROM (
    SELECT '2023-01-01'::TIMESTAMP + INTERVAL (i) DAY as ts,
           CASE WHEN i < 5 THEN 1.0 ELSE 10.0 END as val
    FROM range(0, 10) t(i)
)));
----
10

# Test STRUCT fields exist - timestamp
query I
SELECT ((SELECT ts_detect_changepoints_agg(ts, val, MAP([], [])) FROM (
    SELECT '2023-01-01'::TIMESTAMP + INTERVAL (i) DAY as ts,
           CASE WHEN i < 5 THEN 1.0 ELSE 10.0 END as val
    FROM range(0, 10) t(i)
))[1]).timestamp IS NOT NULL;
----
true

# Test STRUCT fields exist - value
query I
SELECT ((SELECT ts_detect_changepoints_agg(ts, val, MAP([], [])) FROM (
    SELECT '2023-01-01'::TIMESTAMP + INTERVAL (i) DAY as ts,
           CASE WHEN i < 5 THEN 1.0 ELSE 10.0 END as val
    FROM range(0, 10) t(i)
))[1]).value IS NOT NULL;
----
true

# Test STRUCT fields exist - is_changepoint
query I
SELECT ((SELECT ts_detect_changepoints_agg(ts, val, MAP([], [])) FROM (
    SELECT '2023-01-01'::TIMESTAMP + INTERVAL (i) DAY as ts,
           CASE WHEN i < 5 THEN 1.0 ELSE 10.0 END as val
    FROM range(0, 10) t(i)
))[1]).is_changepoint IS NOT NULL;
----
true

# Test STRUCT fields exist - changepoint_probability
query I
SELECT ((SELECT ts_detect_changepoints_agg(ts, val, MAP([], [])) FROM (
    SELECT '2023-01-01'::TIMESTAMP + INTERVAL (i) DAY as ts,
           CASE WHEN i < 5 THEN 1.0 ELSE 10.0 END as val
    FROM range(0, 10) t(i)
))[1]).changepoint_probability IS NOT NULL;
----
true

# Test with constant series - no changepoints expected (all is_changepoint should be false)
query I
SELECT list_reduce(
    list_transform(
        (SELECT ts_detect_changepoints_agg(ts, val, MAP([], [])) FROM (
            SELECT '2023-01-01'::TIMESTAMP + INTERVAL (i) DAY as ts, 5.0 as val
            FROM range(0, 10) t(i)
        )),
        x -> CASE WHEN x.is_changepoint THEN 1 ELSE 0 END
    ),
    (a, b) -> a + b
) = 0;
----
true

# Test with hazard_lambda parameter
query I
SELECT length((SELECT ts_detect_changepoints_agg(ts, val, MAP(['hazard_lambda'], ['100.0'])) FROM (
    SELECT '2023-01-01'::TIMESTAMP + INTERVAL (i) DAY as ts,
           CASE WHEN i < 5 THEN 1.0 ELSE 10.0 END as val
    FROM range(0, 10) t(i)
)));
----
10

# Test GROUP BY with aggregate - multiple groups
statement ok
CREATE TABLE changepoints_agg_test AS
SELECT 'A' as grp, '2023-01-01'::TIMESTAMP + INTERVAL (i) DAY as ts,
       CASE WHEN i < 5 THEN 1.0 ELSE 10.0 END as val
FROM range(0, 10) t(i)
UNION ALL
SELECT 'B' as grp, '2023-01-01'::TIMESTAMP + INTERVAL (i) DAY as ts,
       CASE WHEN i < 3 THEN 2.0 ELSE 20.0 END as val
FROM range(0, 10) t(i);

# Test aggregate with GROUP BY returns one result per group
query I
SELECT COUNT(*) FROM (
    SELECT grp, ts_detect_changepoints_agg(ts, val, MAP([], [])) as cps
    FROM changepoints_agg_test
    GROUP BY grp
);
----
2

# Test each group has correct list length
query I
SELECT length(ts_detect_changepoints_agg(ts, val, MAP([], []))) = 10
FROM changepoints_agg_test
GROUP BY grp
ORDER BY grp
LIMIT 1;
----
true

statement ok
DROP TABLE changepoints_agg_test;

#######################################
# ts_detect_changepoints_by - Native Table Function Tests (Issue #149)
#######################################

statement ok
CREATE TABLE changepoints_by_test AS
SELECT 'A' as grp, '2023-01-01'::TIMESTAMP + INTERVAL (i) DAY as ts,
       CASE WHEN i < 5 THEN 1.0 ELSE 10.0 END as val
FROM range(0, 10) t(i)
UNION ALL
SELECT 'B' as grp, '2023-01-01'::TIMESTAMP + INTERVAL (i) DAY as ts,
       CASE WHEN i < 3 THEN 2.0 ELSE 20.0 END as val
FROM range(0, 10) t(i);

# Test ts_detect_changepoints_by returns row-level results (10 rows per group = 20 total)
query I
SELECT COUNT(*) FROM ts_detect_changepoints_by('changepoints_by_test', grp, ts, val, MAP([], []));
----
20

# Test column name is preserved (Issue #149 bug 1) - should be 'grp', not 'id'
query I
SELECT COUNT(DISTINCT grp) FROM ts_detect_changepoints_by('changepoints_by_test', grp, ts, val, MAP([], []));
----
2

# Test ts_detect_changepoints_by has date column (Issue #149 bug 2)
query I
SELECT ts IS NOT NULL
FROM ts_detect_changepoints_by('changepoints_by_test', grp, ts, val, MAP([], []))
LIMIT 1;
----
true

# Test ts_detect_changepoints_by has is_changepoint column
query I
SELECT is_changepoint IS NOT NULL
FROM ts_detect_changepoints_by('changepoints_by_test', grp, ts, val, MAP([], []))
LIMIT 1;
----
true

# Test ts_detect_changepoints_by has changepoint_probability column
query I
SELECT changepoint_probability IS NOT NULL
FROM ts_detect_changepoints_by('changepoints_by_test', grp, ts, val, MAP([], []))
LIMIT 1;
----
true

# Test with hazard_lambda parameter
query I
SELECT COUNT(*) FROM ts_detect_changepoints_by('changepoints_by_test', grp, ts, val, MAP(['hazard_lambda'], ['100.0']));
----
20

# Test changepoint is detected at the right place for group A (around index 5)
query I
SELECT COUNT(*)
FROM ts_detect_changepoints_by('changepoints_by_test', grp, ts, val, MAP(['hazard_lambda'], ['10.0']))
WHERE grp = 'A' AND is_changepoint = true;
----
1

# Test custom column name preservation
statement ok
CREATE TABLE cp_custom_cols AS
SELECT 'product_' || i AS my_product_id,
       '2023-01-01'::TIMESTAMP + INTERVAL (i % 10) DAY AS sale_date,
       CASE WHEN (i % 10) < 5 THEN 100.0 ELSE 200.0 END AS revenue
FROM range(1, 21) t(i);

# Verify the output column preserves the input name 'my_product_id'
query T
SELECT my_product_id FROM ts_detect_changepoints_by('cp_custom_cols', my_product_id, sale_date, revenue, MAP([], [])) ORDER BY my_product_id, sale_date LIMIT 1;
----
product_1

# Verify sale_date column is preserved
query I
SELECT sale_date IS NOT NULL FROM ts_detect_changepoints_by('cp_custom_cols', my_product_id, sale_date, revenue, MAP([], [])) LIMIT 1;
----
true

statement ok
DROP TABLE cp_custom_cols;

statement ok
DROP TABLE changepoints_by_test;

#######################################
# Issue #71 Regression Tests
# BOCPD should return varying probabilities, not constant 1/hazard_lambda
#######################################

# Create test data with obvious step change: 100 for 12 points, then 10 for 12 points
statement ok
CREATE TABLE step_change_test AS
SELECT ('2023-01-01'::DATE + (i || ' day')::INTERVAL)::TIMESTAMP AS ts,
       CASE WHEN i < 12 THEN 100.0 ELSE 10.0 END AS val
FROM generate_series(0, 23) AS t(i);

# Test: Probabilities should NOT all be constant (the original bug)
# If fixed, max probability should be much higher than min probability
query I
SELECT
    max(prob) > min(prob) * 10  -- At changepoint, prob should be >>10x higher than baseline
FROM (
    SELECT unnest((_ts_detect_changepoints_bocpd(
        list(val ORDER BY ts), 10.0, true
    )).changepoint_probability) as prob
    FROM step_change_test
);
----
true

# Test: Probability at changepoint (index 12) should be significant (>0.5)
# Index is 0-based, so changepoint at position 12 is element 13 in 1-based array
query I
SELECT (_ts_detect_changepoints_bocpd(
    list(val ORDER BY ts), 10.0, true
)).changepoint_probability[13] > 0.5
FROM step_change_test;
----
true

# Test: Probability before changepoint (index 5-10) should be low (<0.1)
query I
SELECT
    avg(prob) < 0.1
FROM (
    SELECT unnest((_ts_detect_changepoints_bocpd(
        list(val ORDER BY ts), 10.0, true
    )).changepoint_probability[6:11]) as prob
    FROM step_change_test
);
----
true

# Test: Changepoint should be detected at index 12
query I
SELECT list_contains(
    (_ts_detect_changepoints_bocpd(
        list(val ORDER BY ts), 10.0, true
    )).changepoint_indices,
    12::UBIGINT
)
FROM step_change_test;
----
true

# Test via table function: ts_detect_changepoints should detect the step change
query I
SELECT COUNT(*) FROM ts_detect_changepoints('step_change_test', ts, val, MAP(['hazard_lambda'], ['10.0']))
WHERE is_changepoint = true;
----
1

# Test via table function: The detected changepoint should be at the correct position
query I
SELECT EXTRACT(DAY FROM date_col - '2023-01-01'::TIMESTAMP)::INTEGER
FROM ts_detect_changepoints('step_change_test', ts, val, MAP(['hazard_lambda'], ['10.0']))
WHERE is_changepoint = true;
----
12

# Test via aggregate function: Should also detect the changepoint
query I
SELECT list_reduce(
    list_transform(
        ts_detect_changepoints_agg(ts, val, MAP(['hazard_lambda'], ['10.0'])),
        x -> CASE WHEN x.is_changepoint THEN 1 ELSE 0 END
    ),
    (a, b) -> a + b
) = 1
FROM step_change_test;
----
true

statement ok
DROP TABLE step_change_test;

# Test with multiple step changes
statement ok
CREATE TABLE multi_step_test AS
SELECT ('2023-01-01'::DATE + (i || ' day')::INTERVAL)::TIMESTAMP AS ts,
       CASE
           WHEN i < 10 THEN 100.0
           WHEN i < 20 THEN 10.0
           ELSE 50.0
       END AS val
FROM generate_series(0, 29) AS t(i);

# Multiple changepoints should be detected (at least 2)
query I
SELECT COUNT(*) >= 2
FROM ts_detect_changepoints('multi_step_test', ts, val, MAP(['hazard_lambda'], ['10.0']))
WHERE is_changepoint = true;
----
true

# First changepoint should be around index 10
query I
SELECT EXTRACT(DAY FROM date_col - '2023-01-01'::TIMESTAMP)::INTEGER BETWEEN 9 AND 11
FROM ts_detect_changepoints('multi_step_test', ts, val, MAP(['hazard_lambda'], ['10.0']))
WHERE is_changepoint = true
ORDER BY date_col
LIMIT 1;
----
true

statement ok
DROP TABLE multi_step_test;

#######################################
# Row Preservation Tests
# Ensure output row count = input row count
#######################################

# Test 1: NULL dates should be preserved with default values
statement ok
CREATE TABLE cp_null_dates AS
SELECT 'A' AS grp, '2024-01-01'::DATE AS dt, 100.0 AS val
UNION ALL SELECT 'A', '2024-01-02', 110.0
UNION ALL SELECT 'A', '2024-01-03', 105.0
UNION ALL SELECT 'A', NULL, 120.0;

# Should return 4 rows (not 3) - NULL date row preserved
query I
SELECT COUNT(*) FROM ts_detect_changepoints_by('cp_null_dates', grp, dt, val, MAP{});
----
4

# NULL date row should have is_changepoint=false
query I
SELECT COUNT(*) FROM ts_detect_changepoints_by('cp_null_dates', grp, dt, val, MAP{})
WHERE dt IS NULL AND is_changepoint = false;
----
1

# NULL date row should have probability=NULL
query I
SELECT COUNT(*) FROM ts_detect_changepoints_by('cp_null_dates', grp, dt, val, MAP{})
WHERE dt IS NULL AND changepoint_probability IS NULL;
----
1

statement ok
DROP TABLE cp_null_dates;

# Test 2: Singleton groups (< 2 points) should be preserved
statement ok
CREATE TABLE cp_singleton AS
SELECT 'A' AS grp, '2024-01-01'::DATE AS dt, 100.0 AS val
UNION ALL SELECT 'A', '2024-01-02', 110.0
UNION ALL SELECT 'A', '2024-01-03', 105.0
UNION ALL SELECT 'B', '2024-01-01', 50.0;

# Should return 4 rows (not 3) - singleton group preserved
query I
SELECT COUNT(*) FROM ts_detect_changepoints_by('cp_singleton', grp, dt, val, MAP{});
----
4

# Singleton group should have is_changepoint=false
query I
SELECT COUNT(*) FROM ts_detect_changepoints_by('cp_singleton', grp, dt, val, MAP{})
WHERE grp = 'B' AND is_changepoint = false;
----
1

# Singleton group should have probability=NULL
query I
SELECT COUNT(*) FROM ts_detect_changepoints_by('cp_singleton', grp, dt, val, MAP{})
WHERE grp = 'B' AND changepoint_probability IS NULL;
----
1

statement ok
DROP TABLE cp_singleton;

# Test 3: Combined - both NULL dates and singleton group
statement ok
CREATE TABLE cp_combined AS
SELECT 'A' AS grp, '2024-01-01'::DATE AS dt, 100.0 AS val
UNION ALL SELECT 'A', '2024-01-02', 110.0
UNION ALL SELECT 'A', NULL, 120.0
UNION ALL SELECT 'B', '2024-01-01', 50.0;

# Should return 4 rows (input = output)
query I
SELECT COUNT(*) FROM ts_detect_changepoints_by('cp_combined', grp, dt, val, MAP{});
----
4

# Both problematic rows should have is_changepoint=false, probability=NULL
query I
SELECT COUNT(*) FROM ts_detect_changepoints_by('cp_combined', grp, dt, val, MAP{})
WHERE is_changepoint = false AND changepoint_probability IS NULL;
----
2

statement ok
DROP TABLE cp_combined;

# Test 4: Large dataset row preservation
statement ok
CREATE TABLE cp_large AS
SELECT 'grp_' || (i / 10) AS grp,
       CASE WHEN i % 10 = 5 THEN NULL ELSE '2024-01-01'::DATE + (i % 10) END AS dt,
       (100 + i)::DOUBLE AS val
FROM range(0, 100) t(i);

# 100 input rows = 100 output rows (10 groups Ã— 10 rows, 10 NULL dates)
query I
SELECT COUNT(*) FROM ts_detect_changepoints_by('cp_large', grp, dt, val, MAP{});
----
100

statement ok
DROP TABLE cp_large;
