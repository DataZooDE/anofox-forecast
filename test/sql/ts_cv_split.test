# name: test/sql/ts_cv_split.test
# description: Tests for ts_cv_split - time series cross-validation splitting
# group: [sql]

require anofox_forecast

require json

#######################################
# Setup Test Data
#######################################

statement ok
CREATE TABLE cv_test AS
SELECT
    'A' AS series_id,
    '2024-01-01'::DATE + (i * INTERVAL '1 day') AS date,
    10.0 + i AS value
FROM generate_series(0, 29) AS t(i)
UNION ALL
SELECT
    'B' AS series_id,
    '2024-01-01'::DATE + (i * INTERVAL '1 day') AS date,
    100.0 + i AS value
FROM generate_series(0, 29) AS t(i);

#######################################
# ts_cv_split_folds - Basic Tests
#######################################

# Test returns correct number of folds
query I
SELECT COUNT(*) FROM ts_cv_split_folds_by('cv_test', series_id, date, ['2024-01-10'::DATE, '2024-01-15'::DATE, '2024-01-20'::DATE], 5, '1d', MAP{});
----
3

# Test fold boundaries are correct
query II
SELECT fold_id, horizon FROM ts_cv_split_folds_by('cv_test', series_id, date, ['2024-01-10'::DATE], 5, '1d', MAP{});
----
1	5

#######################################
# ts_cv_split_folds - Gap Parameter Tests
#######################################

# Test gap=0 (default): test starts immediately after train
query II
SELECT train_end::DATE, test_start::DATE FROM ts_cv_split_folds_by('cv_test', series_id, date, ['2024-01-10'::DATE], 5, '1d', MAP{});
----
2024-01-10	2024-01-11

# Test gap=2: test starts 3 days after train (2 gap days skipped)
query III
SELECT train_end::DATE, test_start::DATE, gap FROM ts_cv_split_folds_by('cv_test', series_id, date, ['2024-01-10'::DATE], 5, '1d', MAP{'gap': '2'});
----
2024-01-10	2024-01-13	2

# Test gap affects test_end correctly
query II
SELECT test_start::DATE, test_end::DATE FROM ts_cv_split_folds_by('cv_test', series_id, date, ['2024-01-10'::DATE], 5, '1d', MAP{'gap': '2'});
----
2024-01-13	2024-01-17

#######################################
# ts_cv_split - Expanding Window Tests
#######################################

# Test expanding window generates correct number of rows
# Fold 1: train 10 + test 5 = 15 × 2 series = 30
# Fold 2: train 15 + test 5 = 20 × 2 series = 40
# Total = 70
query I
SELECT COUNT(*) FROM ts_cv_split_by('cv_test', series_id, date, value, ['2024-01-10'::DATE, '2024-01-15'::DATE], 5, MAP{});
----
70

# Test expanding window train size grows (per series)
query II
SELECT fold_id, COUNT(*) as n_train FROM ts_cv_split_by('cv_test', series_id, date, value, ['2024-01-10'::DATE, '2024-01-15'::DATE], 5, MAP{})
WHERE split = 'train'
GROUP BY fold_id
ORDER BY fold_id;
----
1	20
2	30

# Test test size is consistent (per series)
query II
SELECT fold_id, COUNT(*) as n_test FROM ts_cv_split_by('cv_test', series_id, date, value, ['2024-01-10'::DATE, '2024-01-15'::DATE], 5, MAP{})
WHERE split = 'test'
GROUP BY fold_id
ORDER BY fold_id;
----
1	10
2	10

#######################################
# ts_cv_split - Fixed Window Tests
#######################################

# Test fixed window train size is constant (8 days × 2 series = 16)
query II
SELECT fold_id, COUNT(*) as n_train FROM ts_cv_split_by('cv_test', series_id, date, value, ['2024-01-10'::DATE, '2024-01-15'::DATE, '2024-01-20'::DATE], 5, MAP{'window_type': 'fixed', 'min_train_size': '7'})
WHERE split = 'train'
GROUP BY fold_id
ORDER BY fold_id;
----
1	16
2	16
3	16

#######################################
# ts_cv_split - Multiple Series Tests
#######################################

# Test both series are present in each fold
query II
SELECT fold_id, COUNT(DISTINCT group_col) as n_series FROM ts_cv_split_by('cv_test', series_id, date, value, ['2024-01-10'::DATE], 5, MAP{})
GROUP BY fold_id;
----
1	2

#######################################
# ts_cv_split - Gap Parameter Tests
#######################################

# Test gap=0 (default): test starts immediately after train
query II
SELECT split, MIN(date_col)::DATE as min_date FROM ts_cv_split_by('cv_test', series_id, date, value, ['2024-01-10'::DATE], 5, MAP{})
WHERE group_col = 'A'
GROUP BY split ORDER BY split DESC;
----
train	2024-01-01
test	2024-01-11

# Test gap=2: test starts 3 days after train (skips 2 gap days)
query II
SELECT split, MIN(date_col)::DATE as min_date FROM ts_cv_split_by('cv_test', series_id, date, value, ['2024-01-10'::DATE], 5, MAP{'gap': '2'})
WHERE group_col = 'A'
GROUP BY split ORDER BY split DESC;
----
train	2024-01-01
test	2024-01-13

# Test gap changes test count correctly (horizon stays same)
query II
SELECT split, COUNT(*) as n FROM ts_cv_split_by('cv_test', series_id, date, value, ['2024-01-10'::DATE], 5, MAP{'gap': '2'})
WHERE group_col = 'A'
GROUP BY split ORDER BY split DESC;
----
train	10
test	5

#######################################
# ts_cv_split - Embargo Parameter Tests
#######################################

# Test embargo=0 (default): train starts from beginning for all folds
query II
SELECT fold_id, MIN(date_col)::DATE as train_start FROM ts_cv_split_by('cv_test', series_id, date, value, ['2024-01-10'::DATE, '2024-01-15'::DATE], 5, MAP{})
WHERE group_col = 'A' AND split = 'train'
GROUP BY fold_id ORDER BY fold_id;
----
1	2024-01-01
2	2024-01-01

# Test embargo=2: fold 2 train_start = fold 1 test_end + 2 days
# Fold 1 test_end = 2024-01-15, so fold 2 train_start = 2024-01-17
query II
SELECT fold_id, MIN(date_col)::DATE as train_start FROM ts_cv_split_by('cv_test', series_id, date, value, ['2024-01-10'::DATE, '2024-01-20'::DATE], 5, MAP{'embargo': '2'})
WHERE group_col = 'A' AND split = 'train'
GROUP BY fold_id ORDER BY fold_id;
----
1	2024-01-01
2	2024-01-17

# Test embargo reduces training size for subsequent folds
query II
SELECT fold_id, COUNT(*) as n_train FROM ts_cv_split_by('cv_test', series_id, date, value, ['2024-01-10'::DATE, '2024-01-20'::DATE], 5, MAP{'embargo': '2'})
WHERE group_col = 'A' AND split = 'train'
GROUP BY fold_id ORDER BY fold_id;
----
1	10
2	4

# Test embargo works with ts_cv_split_folds
query III
SELECT fold_id, train_start::DATE, embargo FROM ts_cv_split_folds_by('cv_test', series_id, date, ['2024-01-10'::DATE, '2024-01-20'::DATE], 5, '1d', MAP{'embargo': '2'});
----
1	2024-01-01	2
2	2024-01-17	2

# Test embargo combined with gap
# gap affects test_start, embargo affects subsequent fold's train_start
query IIII
SELECT fold_id, train_start::DATE, test_start::DATE, gap FROM ts_cv_split_folds_by('cv_test', series_id, date, ['2024-01-10'::DATE, '2024-01-20'::DATE], 5, '1d', MAP{'embargo': '2', 'gap': '1'});
----
1	2024-01-01	2024-01-12	1
2	2024-01-18	2024-01-22	1

#######################################
# ts_cv_split_index - Skinny Index Tests
#######################################

# Test returns only 4 columns (no target_col)
query I
SELECT COUNT(*) FROM (
    DESCRIBE SELECT * FROM ts_cv_split_index_by('cv_test', series_id, date, ['2024-01-10'::DATE], 5, '1d', MAP{})
);
----
4

# Test has same row count as ts_cv_split
query II
SELECT
    (SELECT COUNT(*) FROM ts_cv_split_by('cv_test', series_id, date, value, ['2024-01-10'::DATE], 5, MAP{})) as with_target,
    (SELECT COUNT(*) FROM ts_cv_split_index_by('cv_test', series_id, date, ['2024-01-10'::DATE], 5, '1d', MAP{})) as without_target;
----
30	30

# Test has correct columns: group_col, date_col, fold_id, split
query IIII
SELECT group_col, date_col::DATE, fold_id, split FROM ts_cv_split_index_by('cv_test', series_id, date, ['2024-01-10'::DATE], 5, '1d', MAP{})
WHERE group_col = 'A' AND split = 'test'
ORDER BY date_col
LIMIT 1;
----
A	2024-01-11	1	test

# Test gap parameter works with skinny index
query II
SELECT split, MIN(date_col)::DATE as min_date FROM ts_cv_split_index_by('cv_test', series_id, date, ['2024-01-10'::DATE], 5, '1d', MAP{'gap': '2'})
WHERE group_col = 'A'
GROUP BY split ORDER BY split DESC;
----
train	2024-01-01
test	2024-01-13

# Test window_type works with skinny index
query II
SELECT fold_id, COUNT(*) as n_train FROM ts_cv_split_index_by('cv_test', series_id, date, ['2024-01-10'::DATE, '2024-01-15'::DATE], 5, '1d', MAP{'window_type': 'fixed', 'min_train_size': '5'})
WHERE split = 'train'
GROUP BY fold_id
ORDER BY fold_id;
----
1	12
2	12

#######################################
# Edge Cases
#######################################

# Test single fold
query I
SELECT COUNT(DISTINCT fold_id) FROM ts_cv_split_by('cv_test', series_id, date, value, ['2024-01-15'::DATE], 5, MAP{});
----
1

#######################################
# ts_cv_forecast_by - Parallel Fold Execution Tests
#######################################

# Create CV splits for forecasting test (includes both train and test)
statement ok
CREATE TABLE cv_splits AS
SELECT * FROM ts_cv_split_by('cv_test', series_id, date, value, ['2024-01-10'::DATE, '2024-01-15'::DATE], 5, MAP{});

# Test returns correct number of forecast rows
# 2 folds × 2 series × 5 horizon = 20 rows
query I
SELECT COUNT(*) FROM ts_cv_forecast_by('cv_splits', series_id, date, value, 'Naive', MAP{});
----
20

# Test has correct output columns
query I
SELECT COUNT(*) FROM (
    DESCRIBE SELECT * FROM ts_cv_forecast_by('cv_splits', series_id, date, value, 'Naive', MAP{})
);
----
9

# Test all folds are represented
query I
SELECT COUNT(DISTINCT fold_id) FROM ts_cv_forecast_by('cv_splits', series_id, date, value, 'Naive', MAP{});
----
2

# Test all groups are represented per fold
query II
SELECT fold_id, COUNT(DISTINCT series_id) as n_series FROM ts_cv_forecast_by('cv_splits', series_id, date, value, 'Naive', MAP{})
GROUP BY fold_id ORDER BY fold_id;
----
1	2
2	2

# Test forecast dates start after training end
query II
SELECT fold_id, MIN(date)::DATE as first_forecast FROM ts_cv_forecast_by('cv_splits', series_id, date, value, 'Naive', MAP{})
GROUP BY fold_id ORDER BY fold_id;
----
1	2024-01-11
2	2024-01-16

# Test point forecasts are numeric
query I
SELECT COUNT(*) FROM ts_cv_forecast_by('cv_splits', series_id, date, value, 'Naive', MAP{})
WHERE forecast IS NOT NULL;
----
20

# Test with AutoETS model
query I
SELECT COUNT(*) FROM ts_cv_forecast_by('cv_splits', series_id, date, value, 'AutoETS', MAP{});
----
20

#######################################
# STRUCT Params Tests (GH#95)
# Test that MAP syntax works for CV functions
#######################################

# Test ts_cv_split with MAP params (all string values)
query I
SELECT COUNT(*) FROM ts_cv_split_by('cv_test', series_id, date, value, ARRAY['2024-01-10'::TIMESTAMP, '2024-01-15'::TIMESTAMP], 5,
    MAP{'window_type': 'expanding', 'gap': '0', 'embargo': '0'});
----
70

# Test ts_cv_forecast_by with empty params (use MAP{} as empty STRUCT {} not valid)
query I
SELECT COUNT(*) FROM ts_cv_forecast_by('cv_splits', series_id, date, value, 'Naive', MAP{});
----
20

# Test ts_cv_forecast_by with MAP containing model param
query I
SELECT COUNT(*) FROM ts_cv_forecast_by('cv_splits', series_id, date, value, 'ETS', MAP{'model': 'AAA'});
----
20

# Test backward compatibility: MAP syntax still works
query I
SELECT COUNT(*) FROM ts_cv_split_by('cv_test', series_id, date, value, ARRAY['2024-01-10'::TIMESTAMP, '2024-01-15'::TIMESTAMP], 5,
    MAP{'window_type': 'expanding', 'gap': '0'});
----
70

statement ok
DROP TABLE cv_splits;

#######################################
# Cleanup
#######################################

statement ok
DROP TABLE cv_test;
