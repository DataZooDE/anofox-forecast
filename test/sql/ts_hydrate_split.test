# name: test/sql/ts_hydrate_split.test
# description: Tests for ts_cv_hydrate_by - join CV folds with source data and provide unknown feature masking values
# group: [sql]

require anofox_forecast

require json

#######################################
# Setup Test Data
#######################################

statement ok
CREATE TABLE backtest_sample AS
SELECT
    category,
    '2022-01-01'::DATE + ((i - 1) * INTERVAL '1 month') AS date,
    (100 + i * 5 + CASE WHEN category = 'A' THEN 50 ELSE 0 END)::DOUBLE AS sales,
    (i % 2)::INT AS promotion,
    (50 + (i % 12) * 3)::DOUBLE AS temperature
FROM generate_series(1, 24) AS t(i)
CROSS JOIN (SELECT 'A' AS category UNION ALL SELECT 'B') AS c;

# ts_cv_folds_by creates folds with: category, date, sales, fold_id, split
statement ok
CREATE TABLE cv_folds AS
SELECT *
FROM ts_cv_folds_by(
    'backtest_sample', category, date, sales,
    3, 3, MAP{}
);

# Verify cv_folds has original column names
query I
SELECT COUNT(*) FROM (
    DESCRIBE SELECT * FROM cv_folds
) WHERE column_name IN ('category', 'date', 'sales');
----
3

#######################################
# ts_cv_hydrate_by - Basic Join Test
#######################################

# Should return all cv_folds columns plus _last_known (matching ts_cv_folds_by output)
query I
SELECT COUNT(*) FROM ts_cv_hydrate_by(
    'cv_folds', 'backtest_sample', category, date, ['temperature'], MAP{}
) WHERE fold_id = 1;
----
36

# Should have split column for train/test identification
query II
SELECT split, COUNT(*) FROM ts_cv_hydrate_by(
    'cv_folds', 'backtest_sample', category, date, ['temperature'], MAP{}
) WHERE fold_id = 1
GROUP BY split
ORDER BY split;
----
test	6
train	30

#######################################
# ts_cv_hydrate_by - NULL Strategy
#######################################

# Using split to mask temperature in test rows (join with source to get temperature)
query II
SELECT split, COUNT(*) FROM (
    SELECT
        h.split,
        CASE WHEN h.split = 'test' THEN NULL ELSE s.temperature END AS masked_temp
    FROM ts_cv_hydrate_by(
        'cv_folds', 'backtest_sample', category, date, ['temperature'],
        MAP{'strategy': 'null'}
    ) h
    JOIN backtest_sample s ON h.category = s.category AND h.date = s.date
    WHERE h.fold_id = 1 AND h.category = 'A'
) WHERE masked_temp IS NULL OR masked_temp IS NOT NULL
GROUP BY split
ORDER BY split DESC;
----
train	15
test	3

# Verify train rows have actual temperature values (via join)
query I
SELECT COUNT(*) FROM ts_cv_hydrate_by(
    'cv_folds', 'backtest_sample', category, date, ['temperature'],
    MAP{'strategy': 'null'}
) h
JOIN backtest_sample s ON h.category = s.category AND h.date = s.date
WHERE h.fold_id = 1 AND h.split = 'train' AND s.temperature IS NOT NULL;
----
30

#######################################
# ts_cv_hydrate_by - LAST_VALUE Strategy
#######################################

# _last_known map should have the last training value for temperature
query I
SELECT COUNT(DISTINCT _last_known['temperature']) FROM ts_cv_hydrate_by(
    'cv_folds', 'backtest_sample', category, date, ['temperature'],
    MAP{'strategy': 'last_value'}
) WHERE fold_id = 1 AND category = 'A' AND split = 'test';
----
1

# Using _last_known to carry forward last training value (join with source)
query II
SELECT split, COUNT(*) FROM (
    SELECT
        h.split,
        CASE WHEN h.split = 'test' THEN h._last_known['temperature'] ELSE s.temperature::VARCHAR END AS filled_temp
    FROM ts_cv_hydrate_by(
        'cv_folds', 'backtest_sample', category, date, ['temperature'],
        MAP{'strategy': 'last_value'}
    ) h
    JOIN backtest_sample s ON h.category = s.category AND h.date = s.date
    WHERE h.fold_id = 1 AND h.category = 'A'
) WHERE filled_temp IS NOT NULL
GROUP BY split
ORDER BY split DESC;
----
train	15
test	3

#######################################
# ts_cv_hydrate_by - DEFAULT Strategy
#######################################

# _last_known should contain fill_value for default strategy
query I
SELECT DISTINCT _last_known['temperature'] FROM ts_cv_hydrate_by(
    'cv_folds', 'backtest_sample', category, date, ['temperature'],
    MAP{'strategy': 'default', 'fill_value': '999'}
) WHERE fold_id = 1 AND category = 'A' AND split = 'test';
----
999.0

#######################################
# ts_cv_hydrate_by - Multiple Unknown Features
#######################################

# Test with multiple unknown features
query I
SELECT COUNT(*) FROM (
    SELECT * FROM ts_cv_hydrate_by(
        'cv_folds', 'backtest_sample', category, date,
        ['temperature', 'promotion'],
        MAP{'strategy': 'last_value'}
    )
    WHERE fold_id = 1
);
----
36

# _last_known should have entries for both columns
query I
SELECT COUNT(*) FROM ts_cv_hydrate_by(
    'cv_folds', 'backtest_sample', category, date,
    ['temperature', 'promotion'],
    MAP{'strategy': 'last_value'}
) WHERE fold_id = 1 AND category = 'A' AND split = 'test'
  AND _last_known['temperature'] IS NOT NULL
  AND _last_known['promotion'] IS NOT NULL;
----
3

#######################################
# Multiple Folds Test
#######################################

# Each fold should have train and test splits
query III
SELECT fold_id, split, COUNT(*) as n FROM ts_cv_hydrate_by(
    'cv_folds', 'backtest_sample', category, date, ['temperature'], MAP{}
)
GROUP BY fold_id, split
ORDER BY fold_id, split DESC;
----
1	train	30
1	test	6
2	train	36
2	test	6
3	train	42
3	test	6

#######################################
# Manual Masking Pattern (Recommended)
#######################################

# The recommended pattern: join with source and use split for explicit masking
query III
SELECT
    h.fold_id,
    h.split,
    SUM(CASE WHEN h.split = 'test' THEN NULL ELSE s.temperature END) IS NOT NULL as has_train_temps
FROM ts_cv_hydrate_by(
    'cv_folds', 'backtest_sample', category, date, ['temperature'], MAP{}
) h
JOIN backtest_sample s ON h.category = s.category AND h.date = s.date
WHERE h.fold_id = 1 AND h.category = 'A'
GROUP BY h.fold_id, h.split
ORDER BY h.split DESC;
----
1	train	true
1	test	false

#######################################
# Cleanup
#######################################

statement ok
DROP TABLE backtest_sample;

statement ok
DROP TABLE cv_folds;
