# name: test/sql/ts_forecast_exog.test
# description: Tests for ts_forecast with exogenous variables
# group: [sql]

require anofox_forecast

#######################################
# _ts_forecast_exog Scalar Function Tests
#######################################

# Test basic exog forecast with single regressor
query I
SELECT length((_ts_forecast_exog(
    [10.0, 20.0, 15.0, 25.0, 20.0, 30.0, 25.0, 35.0],  -- y values
    [[1.0, 2.0, 1.0, 2.0, 1.0, 2.0, 1.0, 2.0]],        -- historical X (1 regressor)
    [[1.0, 2.0, 1.0]],                                   -- future X (horizon=3)
    3,                                                    -- horizon
    'AutoARIMA'                                           -- model
)).point);
----
3

# Test exog forecast returns model name
query I
SELECT (_ts_forecast_exog(
    [10.0, 20.0, 15.0, 25.0, 20.0, 30.0],
    [[1.0, 2.0, 1.0, 2.0, 1.0, 2.0]],
    [[1.0, 2.0]],
    2,
    'AutoARIMA'
)).model IS NOT NULL;
----
true

# Test exog forecast with two regressors
query I
SELECT length((_ts_forecast_exog(
    [100.0, 120.0, 110.0, 130.0, 125.0, 140.0],         -- y (sales)
    [[20.0, 22.0, 19.0, 23.0, 21.0, 24.0],              -- X1 (temperature)
     [0.0, 1.0, 0.0, 1.0, 0.0, 1.0]],                   -- X2 (promotion)
    [[22.0, 20.0, 21.0],                                 -- future temp
     [1.0, 0.0, 1.0]],                                   -- future promo
    3,
    'AutoARIMA'
)).point);
----
3

# Test that model name contains X suffix for exog models
query I
SELECT (_ts_forecast_exog(
    [10.0, 20.0, 15.0, 25.0, 20.0, 30.0],
    [[1.0, 2.0, 1.0, 2.0, 1.0, 2.0]],
    [[1.0, 2.0]],
    2,
    'AutoARIMA'
)).model LIKE '%X' OR (_ts_forecast_exog(
    [10.0, 20.0, 15.0, 25.0, 20.0, 30.0],
    [[1.0, 2.0, 1.0, 2.0, 1.0, 2.0]],
    [[1.0, 2.0]],
    2,
    'AutoARIMA'
)).model LIKE '%ARIMA%';
----
true

# Test confidence bounds have correct length
query I
SELECT length((_ts_forecast_exog(
    [10.0, 20.0, 15.0, 25.0, 20.0, 30.0],
    [[1.0, 2.0, 1.0, 2.0, 1.0, 2.0]],
    [[1.0, 2.0, 1.0, 2.0]],
    4,
    'AutoARIMA'
)).lower);
----
4

query I
SELECT length((_ts_forecast_exog(
    [10.0, 20.0, 15.0, 25.0, 20.0, 30.0],
    [[1.0, 2.0, 1.0, 2.0, 1.0, 2.0]],
    [[1.0, 2.0, 1.0, 2.0]],
    4,
    'AutoARIMA'
)).upper);
----
4

#######################################
# Exog Effect Validation Tests
#######################################

# Test that exogenous forecasting works with different models
query I
SELECT (_ts_forecast_exog(
    [10.0, 20.0, 15.0, 25.0, 20.0, 30.0],
    [[1.0, 2.0, 1.0, 2.0, 1.0, 2.0]],
    [[1.0, 2.0]],
    2,
    'ARIMA'
)).model;
----
ARIMAX

query I
SELECT (_ts_forecast_exog(
    [10.0, 20.0, 15.0, 25.0, 20.0, 30.0],
    [[1.0, 2.0, 1.0, 2.0, 1.0, 2.0]],
    [[1.0, 2.0]],
    2,
    'OptimizedTheta'
)).model;
----
ThetaX

query I
SELECT (_ts_forecast_exog(
    [10.0, 20.0, 15.0, 25.0, 20.0, 30.0],
    [[1.0, 2.0, 1.0, 2.0, 1.0, 2.0]],
    [[1.0, 2.0]],
    2,
    'MFLES'
)).model;
----
MFLESX

#######################################
# Error Handling Tests
#######################################

# Test with empty exogenous arrays (should still work, falls back to non-exog)
query I
SELECT length((_ts_forecast_exog(
    [10.0, 20.0, 15.0, 25.0, 20.0, 30.0],
    [],
    [],
    3,
    'AutoARIMA'
)).point);
----
3


#######################################
# ts_forecast_exog_by - Grouped Exogenous Forecasting
#######################################

# The ts_forecast_exog_by macro uses json_extract for dynamic column access
require json

# Create grouped historical data with exogenous variable
statement ok
CREATE TABLE exog_by_history AS
SELECT
    CASE WHEN i <= 20 THEN 'A' ELSE 'B' END AS group_id,
    '2023-01-01'::TIMESTAMP + INTERVAL ((i - 1) % 20) DAY AS date,
    (10.0 + (i % 20) * 2.0 + ((i % 20) % 7))::DOUBLE AS target,
    ((i % 20) + 5.0)::DOUBLE AS xreg1
FROM range(1, 41) t(i);

# Create future exogenous data
statement ok
CREATE TABLE exog_by_future AS
SELECT
    group_id,
    '2023-01-21'::TIMESTAMP + INTERVAL (i - 1) DAY AS date,
    (25.0 + i)::DOUBLE AS xreg1
FROM (VALUES ('A'), ('B')) AS groups(group_id),
     range(1, 8) t(i);

# Test ts_forecast_exog_by returns forecasts for both groups
query I
SELECT COUNT(DISTINCT id) FROM ts_forecast_exog_by(
    'exog_by_history',
    group_id,
    date,
    target,
    ['xreg1'],
    'exog_by_future',
    date,
    ['xreg1'],
    'AutoARIMA',
    7,
    MAP{},
    '1d'
);
----
2

# Test ts_forecast_exog_by returns correct number of forecast rows
query I
SELECT COUNT(*) FROM ts_forecast_exog_by(
    'exog_by_history',
    group_id,
    date,
    target,
    ['xreg1'],
    'exog_by_future',
    date,
    ['xreg1'],
    'AutoARIMA',
    7,
    MAP{},
    '1d'
);
----
14

statement ok
DROP TABLE exog_by_future;

statement ok
DROP TABLE exog_by_history;
