# name: test/sql/ts_forecast_statespace.test
# description: Tests for State Space and ARIMA models (ETS, ARIMA)
# group: [sql]

require anofox_forecast

require json

#######################################
# Setup: Create test data
#######################################

# Linear trend data for basic testing
statement ok
CREATE TABLE trend_data AS
SELECT
    ('2024-01-01'::DATE + (i || ' day')::INTERVAL)::TIMESTAMP AS ts,
    50.0 + i * 2.0 AS value
FROM generate_series(0, 29) AS t(i);

# Seasonal data with period 7 (weekly pattern) and trend
statement ok
CREATE TABLE seasonal_trend_data AS
SELECT
    ('2024-01-01'::DATE + (i || ' day')::INTERVAL)::TIMESTAMP AS ts,
    100.0 + (i % 7) * 10.0 + i * 0.5 AS value
FROM generate_series(0, 55) AS t(i);

# Pure seasonal data without trend
statement ok
CREATE TABLE pure_seasonal_data AS
SELECT
    ('2024-01-01'::DATE + (i || ' day')::INTERVAL)::TIMESTAMP AS ts,
    100.0 + (i % 7) * 15.0 AS value
FROM generate_series(0, 55) AS t(i);

# Noisy data with trend
statement ok
CREATE TABLE noisy_data AS
SELECT
    ('2024-01-01'::DATE + (i || ' day')::INTERVAL)::TIMESTAMP AS ts,
    50.0 + i * 1.5 + (i % 5) * 3.0 AS value
FROM generate_series(0, 39) AS t(i);

# Constant data
statement ok
CREATE TABLE constant_data AS
SELECT
    ('2024-01-01'::DATE + (i || ' day')::INTERVAL)::TIMESTAMP AS ts,
    75.0 AS value
FROM generate_series(0, 29) AS t(i);

# Grouped data for aggregate function testing
statement ok
CREATE TABLE grouped_data AS
SELECT
    'X' AS group_id,
    ('2024-01-01'::DATE + (i || ' day')::INTERVAL)::TIMESTAMP AS ts,
    30.0 + i * 1.2 + (i % 3) * 2.0 AS value
FROM generate_series(0, 29) AS t(i)
UNION ALL
SELECT
    'Y' AS group_id,
    ('2024-01-01'::DATE + (i || ' day')::INTERVAL)::TIMESTAMP AS ts,
    60.0 + i * 0.8 + (i % 4) * 3.0 AS value
FROM generate_series(0, 29) AS t(i);

#######################################
# ETS Model Tests (Error-Trend-Seasonal)
#######################################

# Test ETS model returns correct model name
query I
SELECT (_ts_forecast([10.0, 12.0, 14.0, 16.0, 18.0, 20.0, 22.0, 24.0, 26.0, 28.0], 3, 'ETS')).model;
----
ETS

# Test ETS returns correct horizon length
query I
SELECT length((_ts_forecast([10.0, 12.0, 14.0, 16.0, 18.0, 20.0, 22.0, 24.0, 26.0, 28.0], 5, 'ETS')).point);
----
5

# Test ETS with trending data - forecasts should continue trend
query I
SELECT (_ts_forecast([10.0, 12.0, 14.0, 16.0, 18.0, 20.0, 22.0, 24.0, 26.0, 28.0], 3, 'ETS')).point[1] > 25.0;
----
true

# Test ETS forecast increases over horizon for trending data
query I
SELECT (_ts_forecast([10.0, 12.0, 14.0, 16.0, 18.0, 20.0, 22.0, 24.0, 26.0, 28.0], 3, 'ETS')).point[2] >
       (_ts_forecast([10.0, 12.0, 14.0, 16.0, 18.0, 20.0, 22.0, 24.0, 26.0, 28.0], 3, 'ETS')).point[1];
----
true

# Test ETS with ts_forecast_agg
query I
SELECT (ts_forecast_agg(ts, value, 'ETS', 5, MAP([], []))).model_name
FROM trend_data;
----
ETS

# Test ETS forecasts are finite
query I
SELECT (ts_forecast_agg(ts, value, 'ETS', 3, MAP([], []))).point_forecast[1] IS NOT NULL
FROM trend_data;
----
true

# Test ETS confidence bounds
query I
SELECT (_ts_forecast([10.0, 12.0, 14.0, 16.0, 18.0, 20.0, 22.0, 24.0, 26.0, 28.0], 3, 'ETS')).lower[1] <=
       (_ts_forecast([10.0, 12.0, 14.0, 16.0, 18.0, 20.0, 22.0, 24.0, 26.0, 28.0], 3, 'ETS')).point[1];
----
true

query I
SELECT (_ts_forecast([10.0, 12.0, 14.0, 16.0, 18.0, 20.0, 22.0, 24.0, 26.0, 28.0], 3, 'ETS')).upper[1] >=
       (_ts_forecast([10.0, 12.0, 14.0, 16.0, 18.0, 20.0, 22.0, 24.0, 26.0, 28.0], 3, 'ETS')).point[1];
----
true

# Test ETS fitted values length
query I
SELECT length((_ts_forecast([10.0, 12.0, 14.0, 16.0, 18.0, 20.0, 22.0, 24.0, 26.0, 28.0], 3, 'ETS')).fitted);
----
10

# Test ETS residuals length
query I
SELECT length((_ts_forecast([10.0, 12.0, 14.0, 16.0, 18.0, 20.0, 22.0, 24.0, 26.0, 28.0], 3, 'ETS')).residuals);
----
10

# Test ETS case-insensitive name
query I
SELECT (_ts_forecast([10.0, 12.0, 14.0, 16.0, 18.0, 20.0, 22.0, 24.0, 26.0, 28.0], 3, 'ets')).model;
----
ETS

# Test ETS with seasonal data
query I
SELECT (ts_forecast_agg(ts, value, 'ETS', 7, MAP([], []))).model_name
FROM seasonal_trend_data;
----
ETS

# Test ETS with constant data
query I
SELECT ABS((_ts_forecast([50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0, 50.0], 3, 'ETS')).point[1] - 50.0) < 2.0;
----
true

#######################################
# ARIMA Model Tests
#######################################

# Test ARIMA model returns correct model name
query I
SELECT (_ts_forecast([10.0, 12.0, 14.0, 16.0, 18.0, 20.0, 22.0, 24.0, 26.0, 28.0], 3, 'ARIMA')).model;
----
ARIMA

# Test ARIMA returns correct horizon length
query I
SELECT length((_ts_forecast([10.0, 12.0, 14.0, 16.0, 18.0, 20.0, 22.0, 24.0, 26.0, 28.0], 5, 'ARIMA')).point);
----
5

# Test ARIMA with trending data - forecasts should continue trend
query I
SELECT (_ts_forecast([10.0, 12.0, 14.0, 16.0, 18.0, 20.0, 22.0, 24.0, 26.0, 28.0], 3, 'ARIMA')).point[1] > 28.0;
----
true

# Test ARIMA forecast increases over horizon for trending data
query I
SELECT (_ts_forecast([10.0, 12.0, 14.0, 16.0, 18.0, 20.0, 22.0, 24.0, 26.0, 28.0], 3, 'ARIMA')).point[2] >
       (_ts_forecast([10.0, 12.0, 14.0, 16.0, 18.0, 20.0, 22.0, 24.0, 26.0, 28.0], 3, 'ARIMA')).point[1];
----
true

# Test ARIMA with decreasing trend
query I
SELECT (_ts_forecast([50.0, 48.0, 46.0, 44.0, 42.0, 40.0, 38.0, 36.0, 34.0, 32.0], 3, 'ARIMA')).point[1] < 32.0;
----
true

# Test ARIMA with ts_forecast_agg
query I
SELECT (ts_forecast_agg(ts, value, 'ARIMA', 5, MAP([], []))).model_name
FROM trend_data;
----
ARIMA

# Test ARIMA forecasts are finite
query I
SELECT (ts_forecast_agg(ts, value, 'ARIMA', 3, MAP([], []))).point_forecast[1] IS NOT NULL
FROM trend_data;
----
true

# Test ARIMA confidence bounds
query I
SELECT (_ts_forecast([10.0, 12.0, 14.0, 16.0, 18.0, 20.0, 22.0, 24.0, 26.0, 28.0], 3, 'ARIMA')).lower[1] <=
       (_ts_forecast([10.0, 12.0, 14.0, 16.0, 18.0, 20.0, 22.0, 24.0, 26.0, 28.0], 3, 'ARIMA')).point[1];
----
true

query I
SELECT (_ts_forecast([10.0, 12.0, 14.0, 16.0, 18.0, 20.0, 22.0, 24.0, 26.0, 28.0], 3, 'ARIMA')).upper[1] >=
       (_ts_forecast([10.0, 12.0, 14.0, 16.0, 18.0, 20.0, 22.0, 24.0, 26.0, 28.0], 3, 'ARIMA')).point[1];
----
true

# Test ARIMA fitted values length
query I
SELECT length((_ts_forecast([10.0, 12.0, 14.0, 16.0, 18.0, 20.0, 22.0, 24.0, 26.0, 28.0], 3, 'ARIMA')).fitted);
----
10

# Test ARIMA residuals length
query I
SELECT length((_ts_forecast([10.0, 12.0, 14.0, 16.0, 18.0, 20.0, 22.0, 24.0, 26.0, 28.0], 3, 'ARIMA')).residuals);
----
10

# Test ARIMA case-insensitive name
query I
SELECT (_ts_forecast([10.0, 12.0, 14.0, 16.0, 18.0, 20.0, 22.0, 24.0, 26.0, 28.0], 3, 'arima')).model;
----
ARIMA

# Test ARIMA with noisy data
query I
SELECT (ts_forecast_agg(ts, value, 'ARIMA', 5, MAP([], []))).point_forecast[1] IS NOT NULL
FROM noisy_data;
----
true

# Test ARIMA with constant data - should produce near-constant forecasts
query I
SELECT ABS((_ts_forecast([40.0, 40.0, 40.0, 40.0, 40.0, 40.0, 40.0, 40.0, 40.0, 40.0], 3, 'ARIMA')).point[1] - 40.0) < 1.0;
----
true

#######################################
# Model Quality Metrics Tests
#######################################

# Test AIC exists for ETS
query I
SELECT (_ts_forecast([10.0, 12.0, 14.0, 16.0, 18.0, 20.0, 22.0, 24.0, 26.0, 28.0], 3, 'ETS')).aic IS NOT NULL;
----
true

# Test AIC exists for ARIMA
query I
SELECT (_ts_forecast([10.0, 12.0, 14.0, 16.0, 18.0, 20.0, 22.0, 24.0, 26.0, 28.0], 3, 'ARIMA')).aic IS NOT NULL;
----
true

# Test BIC exists
query I
SELECT (_ts_forecast([10.0, 12.0, 14.0, 16.0, 18.0, 20.0, 22.0, 24.0, 26.0, 28.0], 3, 'ETS')).bic IS NOT NULL;
----
true

query I
SELECT (_ts_forecast([10.0, 12.0, 14.0, 16.0, 18.0, 20.0, 22.0, 24.0, 26.0, 28.0], 3, 'ARIMA')).bic IS NOT NULL;
----
true

# Test MSE is non-negative
query I
SELECT (_ts_forecast([10.0, 12.0, 14.0, 16.0, 18.0, 20.0, 22.0, 24.0, 26.0, 28.0], 3, 'ETS')).mse >= 0;
----
true

query I
SELECT (_ts_forecast([10.0, 12.0, 14.0, 16.0, 18.0, 20.0, 22.0, 24.0, 26.0, 28.0], 3, 'ARIMA')).mse >= 0;
----
true

#######################################
# Integration with ts_forecast_agg - Grouped Tests
#######################################

# Test ETS works with grouped data
query II
SELECT group_id, length((ts_forecast_agg(ts, value, 'ETS', 5, MAP([], []))).point_forecast)
FROM grouped_data
GROUP BY group_id
ORDER BY group_id;
----
X	5
Y	5

# Test ARIMA works with grouped data
query II
SELECT group_id, length((ts_forecast_agg(ts, value, 'ARIMA', 5, MAP([], []))).point_forecast)
FROM grouped_data
GROUP BY group_id
ORDER BY group_id;
----
X	5
Y	5

# Test model names are correct in grouped context
query II
SELECT group_id, (ts_forecast_agg(ts, value, 'ETS', 5, MAP([], []))).model_name
FROM grouped_data
GROUP BY group_id
ORDER BY group_id;
----
X	ETS
Y	ETS

query II
SELECT group_id, (ts_forecast_agg(ts, value, 'ARIMA', 5, MAP([], []))).model_name
FROM grouped_data
GROUP BY group_id
ORDER BY group_id;
----
X	ARIMA
Y	ARIMA

# Test insample_fitted length matches input data length
query II
SELECT group_id, length((ts_forecast_agg(ts, value, 'ETS', 5, MAP([], []))).insample_fitted)
FROM grouped_data
GROUP BY group_id
ORDER BY group_id;
----
X	30
Y	30

query II
SELECT group_id, length((ts_forecast_agg(ts, value, 'ARIMA', 5, MAP([], []))).insample_fitted)
FROM grouped_data
GROUP BY group_id
ORDER BY group_id;
----
X	30
Y	30

# Test different groups produce different forecasts
query I
SELECT COUNT(*) FROM (
    SELECT DISTINCT (ts_forecast_agg(ts, value, 'ARIMA', 3, MAP([], []))).point_forecast[1] AS f
    FROM grouped_data
    GROUP BY group_id
);
----
2

#######################################
# Edge Cases
#######################################

# Test ETS with minimum data length (3 points)
query I
SELECT length((_ts_forecast([1.0, 2.0, 3.0], 2, 'ETS')).point);
----
2

# Test ARIMA with minimum useful data length (5 points needed for differencing)
query I
SELECT length((_ts_forecast([1.0, 2.0, 3.0, 4.0, 5.0], 2, 'ARIMA')).point);
----
2

# Test with large horizon
query I
SELECT length((_ts_forecast([10.0, 12.0, 14.0, 16.0, 18.0, 20.0, 22.0, 24.0, 26.0, 28.0], 50, 'ETS')).point);
----
50

query I
SELECT length((_ts_forecast([10.0, 12.0, 14.0, 16.0, 18.0, 20.0, 22.0, 24.0, 26.0, 28.0], 50, 'ARIMA')).point);
----
50

# Test all forecasts are finite
query I
SELECT (_ts_forecast([10.0, 12.0, 14.0, 16.0, 18.0, 20.0, 22.0, 24.0, 26.0, 28.0], 3, 'ETS')).point[1] IS NOT NULL;
----
true

query I
SELECT (_ts_forecast([10.0, 12.0, 14.0, 16.0, 18.0, 20.0, 22.0, 24.0, 26.0, 28.0], 3, 'ARIMA')).point[1] IS NOT NULL;
----
true

# Test ETS with seasonal data produces valid forecasts
query I
SELECT (ts_forecast_agg(ts, value, 'ETS', 7, MAP([], []))).point_forecast[1] IS NOT NULL
FROM pure_seasonal_data;
----
true

# Test ARIMA forecast values are reasonable (within data range extended by trend)
query I
SELECT (ts_forecast_agg(ts, value, 'ARIMA', 5, MAP([], []))).point_forecast[1] > 0
FROM trend_data;
----
true

#######################################
# Comparison Tests
#######################################

# Test ETS and ARIMA produce different forecasts for same data
# (they use different underlying methods)
query I
SELECT ABS((_ts_forecast([10.0, 15.0, 20.0, 25.0, 30.0, 35.0, 40.0, 45.0, 50.0, 55.0], 3, 'ETS')).point[1] -
           (_ts_forecast([10.0, 15.0, 20.0, 25.0, 30.0, 35.0, 40.0, 45.0, 50.0, 55.0], 3, 'ARIMA')).point[1]) >= 0;
----
true

# Test both models produce reasonable forecasts for the same trending data
query I
SELECT (_ts_forecast([10.0, 15.0, 20.0, 25.0, 30.0, 35.0, 40.0, 45.0, 50.0, 55.0], 3, 'ETS')).point[1] > 50.0;
----
true

query I
SELECT (_ts_forecast([10.0, 15.0, 20.0, 25.0, 30.0, 35.0, 40.0, 45.0, 50.0, 55.0], 3, 'ARIMA')).point[1] > 55.0;
----
true

#######################################
# Cleanup
#######################################

statement ok
DROP TABLE trend_data;

statement ok
DROP TABLE seasonal_trend_data;

statement ok
DROP TABLE pure_seasonal_data;

statement ok
DROP TABLE noisy_data;

statement ok
DROP TABLE constant_data;

statement ok
DROP TABLE grouped_data;
