# name: test/sql/extension_comparison.test
# description: Tests for C++ API compatible functionality
# group: [sql]

require anofox_forecast

require json

#######################################
# Setup: Create sample test data
#######################################

statement ok
CREATE TABLE test_series AS
SELECT
    'A' AS id,
    ('2024-01-01'::DATE + (i || ' day')::INTERVAL)::TIMESTAMP AS ds,
    10.0 + i * 0.5 + sin(i * 3.14159 / 7) * 2 AS value
FROM generate_series(0, 29) AS t(i)
UNION ALL
SELECT
    'B' AS id,
    ('2024-01-01'::DATE + (i || ' day')::INTERVAL)::TIMESTAMP AS ds,
    20.0 + i * 0.3 + cos(i * 3.14159 / 7) * 3 AS value
FROM generate_series(0, 29) AS t(i);

statement ok
CREATE TABLE test_single_series AS
SELECT
    ('2024-01-01'::DATE + (i || ' day')::INTERVAL)::TIMESTAMP AS ds,
    100.0 + i * 2.0 + sin(i * 3.14159 / 7) * 10 AS value
FROM generate_series(0, 59) AS t(i);

#######################################
# ts_stats: Table function API
#######################################

query I
SELECT (stats).length FROM ts_stats('test_series', id, ds, value, '1 day') WHERE id = 'A';
----
30

query I
SELECT round((stats).mean, 0) >= 17 FROM ts_stats('test_series', id, ds, value, '1 day') WHERE id = 'A';
----
true

#######################################
# Internal _ts_stats scalar function
#######################################

query IIIR
SELECT
    (stats).length,
    (stats).n_nulls,
    (stats).n_zeros,
    round((stats).mean, 1) AS mean
FROM (
    SELECT _ts_stats(LIST(value ORDER BY ds)) AS stats
    FROM test_single_series
);
----
60	0	0	159.0

#######################################
# ts_forecast_by: Grouped forecasts (long format)
#######################################

# Test ts_forecast_by returns long format with correct columns using MAP
query I
SELECT COUNT(*) FROM ts_forecast_by('test_series', id, ds, value, 'NAIVE', 3, MAP([], []));
----
6

# Test ts_forecast_by has forecast_step column
query I
SELECT COUNT(DISTINCT forecast_step) FROM ts_forecast_by('test_series', id, ds, value, 'NAIVE', 3, MAP([], []));
----
3

# Test ts_forecast_by has id column
query I
SELECT COUNT(DISTINCT id) FROM ts_forecast_by('test_series', id, ds, value, 'NAIVE', 3, MAP([], []));
----
2

#######################################
# Metrics: MAE, MSE, RMSE
#######################################

query R
SELECT round(ts_mae([1.0, 2.0, 3.0], [1.1, 2.2, 2.9]), 2);
----
0.13

query R
SELECT round(ts_mse([1.0, 2.0, 3.0], [1.1, 2.2, 2.9]), 4);
----
0.02

query R
SELECT round(ts_rmse([1.0, 2.0, 3.0], [1.1, 2.2, 2.9]), 4);
----
0.1414

query R
SELECT round(ts_mape([100.0, 200.0, 300.0], [110.0, 190.0, 310.0]), 2);
----
6.11

query R
SELECT round(ts_smape([100.0, 200.0, 300.0], [110.0, 190.0, 310.0]), 2);
----
5.98

#######################################
# ts_diff: Table function API
#######################################

statement ok
CREATE TABLE diff_test AS
SELECT 'X' AS id, ('2023-01-01'::DATE + (i || ' day')::INTERVAL)::TIMESTAMP AS date, (i+1.0)*(i+1.0) AS val
FROM generate_series(0, 3) AS t(i);

query I
SELECT COUNT(*) FROM ts_diff_by('diff_test', id, date, val, 1) WHERE diff_value IS NOT NULL;
----
3

#######################################
# ts_fill_nulls_*: Table function API
#######################################

statement ok
CREATE TABLE impute_test AS
SELECT 'X' AS id, '2023-01-01'::TIMESTAMP AS date, 1.0 AS val
UNION ALL SELECT 'X', '2023-01-02', NULL
UNION ALL SELECT 'X', '2023-01-03', 3.0;

query I
SELECT COUNT(*) FROM ts_fill_nulls_const_by('impute_test', id, date, val, 0.0);
----
3

query I
SELECT COUNT(*) FROM ts_fill_nulls_forward_by('impute_test', id, date, val);
----
3

query I
SELECT COUNT(*) FROM ts_fill_nulls_backward_by('impute_test', id, date, val);
----
3

query I
SELECT COUNT(*) FROM ts_fill_nulls_mean_by('impute_test', id, date, val);
----
3

#######################################
# ts_drop_*: Table function API
#######################################

statement ok
CREATE TABLE drop_test AS
SELECT 'X' AS id, '2023-01-01'::TIMESTAMP AS date, 0.0 AS val
UNION ALL SELECT 'X', '2023-01-02', 0.0
UNION ALL SELECT 'X', '2023-01-03', 1.0
UNION ALL SELECT 'X', '2023-01-04', 2.0
UNION ALL SELECT 'X', '2023-01-05', 0.0;

query I
SELECT COUNT(*) FROM ts_drop_leading_zeros_by('drop_test', id, date, val);
----
3

query I
SELECT COUNT(*) FROM ts_drop_trailing_zeros_by('drop_test', id, date, val);
----
4

query I
SELECT COUNT(*) FROM ts_drop_edge_zeros_by('drop_test', id, date, val);
----
2

#######################################
# ts_seasonality: Seasonality detection
#######################################

# Test with clear seasonal pattern
query I
WITH seasonal_data AS (
    SELECT sin(i * 3.14159 * 2 / 12.0) * 10 + 50 AS value
    FROM generate_series(0, 119) AS t(i)
)
SELECT length(ts_detect_seasonality(LIST(value))) >= 0
FROM seasonal_data;
----
true

#######################################
# ts_data_quality: Internal scalar function
#######################################

query I
SELECT (_ts_data_quality([1.0, 2.0, 3.0, 4.0, 5.0])).n_gaps;
----
0

query I
SELECT (_ts_data_quality([1.0, NULL, 3.0, NULL, 5.0])).n_missing;
----
2

#######################################
# Cleanup
#######################################

statement ok
DROP TABLE test_series;

statement ok
DROP TABLE test_single_series;

statement ok
DROP TABLE diff_test;

statement ok
DROP TABLE impute_test;

statement ok
DROP TABLE drop_test;
