# name: test/sql/ts_filter.test
# description: Tests for series filtering table functions (C++ API compatible)
# group: [sql]

require anofox_forecast

require json

#######################################
# Setup Test Data
#######################################

statement ok
CREATE TABLE test_series AS
SELECT 'A' AS id, '2023-01-01'::TIMESTAMP AS date, 1.0 AS val
UNION ALL SELECT 'A', '2023-01-02', 2.0
UNION ALL SELECT 'A', '2023-01-03', 3.0
UNION ALL SELECT 'A', '2023-01-04', 4.0
UNION ALL SELECT 'A', '2023-01-05', 5.0
UNION ALL SELECT 'B', '2023-01-01', 0.0
UNION ALL SELECT 'B', '2023-01-02', 0.0
UNION ALL SELECT 'B', '2023-01-03', 1.0
UNION ALL SELECT 'B', '2023-01-04', 2.0
UNION ALL SELECT 'B', '2023-01-05', 0.0
UNION ALL SELECT 'C', '2023-01-01', 5.0
UNION ALL SELECT 'C', '2023-01-02', 5.0
UNION ALL SELECT 'C', '2023-01-03', 5.0;

#######################################
# ts_drop_constant - Filter Constant Series
#######################################

# Should filter out constant series (C)
query I
SELECT COUNT(DISTINCT id) FROM ts_drop_constant_by('test_series', id, val);
----
2

# Verify series C is excluded
query I
SELECT COUNT(*) FROM ts_drop_constant_by('test_series', id, val) WHERE id = 'C';
----
0

# Verify A and B remain
query I
SELECT COUNT(*) FROM ts_drop_constant_by('test_series', id, val) WHERE id IN ('A', 'B');
----
10

#######################################
# ts_drop_short - Filter Short Series
#######################################

# Series C has only 3 rows, should be filtered with min_length=5
query I
SELECT COUNT(DISTINCT id) FROM ts_drop_short_by('test_series', id, 5);
----
2

# With min_length=3, all series should pass
query I
SELECT COUNT(DISTINCT id) FROM ts_drop_short_by('test_series', id, 3);
----
3

#######################################
# ts_drop_leading_zeros - Trim Leading Zeros
#######################################

# Series B starts with zeros, should remove them
query I
SELECT COUNT(*) FROM ts_drop_leading_zeros_by('test_series', id, date, val) WHERE id = 'B';
----
3

# Series A has no leading zeros, should remain unchanged
query I
SELECT COUNT(*) FROM ts_drop_leading_zeros_by('test_series', id, date, val) WHERE id = 'A';
----
5

#######################################
# ts_drop_trailing_zeros - Trim Trailing Zeros
#######################################

# Series B ends with zeros, should remove them
query I
SELECT COUNT(*) FROM ts_drop_trailing_zeros_by('test_series', id, date, val) WHERE id = 'B';
----
4

# Series A has no trailing zeros, should remain unchanged
query I
SELECT COUNT(*) FROM ts_drop_trailing_zeros_by('test_series', id, date, val) WHERE id = 'A';
----
5

#######################################
# ts_drop_edge_zeros - Trim Both Edges
#######################################

# Series B has leading and trailing zeros
query I
SELECT COUNT(*) FROM ts_drop_edge_zeros_by('test_series', id, date, val) WHERE id = 'B';
----
2

# Series A has no edge zeros
query I
SELECT COUNT(*) FROM ts_drop_edge_zeros_by('test_series', id, date, val) WHERE id = 'A';
----
5

#######################################
# ts_drop_gappy - Filter Gappy Series
#######################################

statement ok
CREATE TABLE gappy_series AS
SELECT 'X' AS id, '2023-01-01'::TIMESTAMP AS date, NULL::DOUBLE AS val
UNION ALL SELECT 'X', '2023-01-02', 1.0
UNION ALL SELECT 'X', '2023-01-03', 2.0
UNION ALL SELECT 'Y', '2023-01-01', 1.0
UNION ALL SELECT 'Y', '2023-01-02', 2.0
UNION ALL SELECT 'Y', '2023-01-03', 3.0;

# X has 33% gaps, Y has 0% - with 0.3 threshold, only Y passes
query I
SELECT COUNT(DISTINCT id) FROM ts_drop_gappy_by('gappy_series', id, val, 0.3);
----
1

# With 0.5 threshold, both pass
query I
SELECT COUNT(DISTINCT id) FROM ts_drop_gappy_by('gappy_series', id, val, 0.5);
----
2

#######################################
# ts_drop_zeros - Filter All-Zero Series
#######################################

statement ok
CREATE TABLE zero_series AS
SELECT 'X' AS id, '2023-01-01'::TIMESTAMP AS date, 0.0 AS val
UNION ALL SELECT 'X', '2023-01-02', 0.0
UNION ALL SELECT 'X', '2023-01-03', 0.0
UNION ALL SELECT 'Y', '2023-01-01', 1.0
UNION ALL SELECT 'Y', '2023-01-02', 0.0
UNION ALL SELECT 'Y', '2023-01-03', 2.0;

# X is all zeros, should be filtered
query I
SELECT COUNT(DISTINCT id) FROM ts_drop_zeros_by('zero_series', id, val);
----
1

# Y has non-zero values
query I
SELECT COUNT(*) FROM ts_drop_zeros_by('zero_series', id, val) WHERE id = 'Y';
----
3
