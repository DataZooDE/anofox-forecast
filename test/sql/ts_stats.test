# name: test/sql/ts_stats.test
# description: Tests for ts_stats time series statistics table function (C++ API compatible)
# group: [sql]

require anofox_forecast

require json

#######################################
# Table Function Tests (C++ API Compatible)
#######################################

# Create test data table
statement ok
CREATE TABLE test_series AS
SELECT 'A' AS id,
       ('2023-01-01'::DATE + (i || ' days')::INTERVAL)::TIMESTAMP AS date,
       (i + 1)::DOUBLE AS value
FROM generate_series(0, 4) AS t(i)
UNION ALL
SELECT 'B' AS id,
       ('2023-01-01'::DATE + (i || ' days')::INTERVAL)::TIMESTAMP AS date,
       (i * 2)::DOUBLE AS value
FROM generate_series(0, 4) AS t(i);

# Test basic ts_stats table function
query II
SELECT id, length FROM ts_stats('test_series', id, date, value, '1 day') ORDER BY id;
----
A	5
B	5

# Test mean calculation
query IR
SELECT id, mean FROM ts_stats('test_series', id, date, value, '1 day') ORDER BY id;
----
A	3.0
B	4.0

# Test min/max
query IRR
SELECT id, min, max FROM ts_stats('test_series', id, date, value, '1 day') ORDER BY id;
----
A	1.0	5.0
B	0.0	8.0

#######################################
# Internal Scalar Function Tests
#######################################

# Test the internal _ts_stats scalar function (used by table macro)
query I
SELECT (_ts_stats([1.0, 2.0, 3.0, 4.0, 5.0])).length;
----
5

query I
SELECT (_ts_stats([1.0, 2.0, 3.0, 4.0, 5.0])).mean;
----
3.0

query I
SELECT (_ts_stats([1.0, 2.0, 3.0, 4.0, 5.0])).median;
----
3.0

query I
SELECT (_ts_stats([1.0, 2.0, 3.0, 4.0, 5.0])).min;
----
1.0

query I
SELECT (_ts_stats([1.0, 2.0, 3.0, 4.0, 5.0])).max;
----
5.0

query I
SELECT (_ts_stats([1.0, 2.0, 3.0, 4.0, 5.0])).range;
----
4.0

query I
SELECT (_ts_stats([1.0, 2.0, 3.0, 4.0, 5.0])).sum;
----
15.0

# Test n_zeros count
query I
SELECT (_ts_stats([0.0, 1.0, 0.0, 2.0, 0.0])).n_zeros;
----
3

# Test n_positive count
query I
SELECT (_ts_stats([-1.0, 0.0, 1.0, 2.0, 3.0])).n_positive;
----
3

# Test n_negative count
query I
SELECT (_ts_stats([-2.0, -1.0, 0.0, 1.0, 2.0])).n_negative;
----
2

# Test skewness for symmetric distribution (should be near 0)
query I
SELECT ABS((_ts_stats([1.0, 2.0, 3.0, 4.0, 5.0])).skewness) < 0.1;
----
true

# Test autocorrelation lag 1 for trending series (should be positive)
query I
SELECT (_ts_stats([1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0])).autocorr_lag1 > 0;
----
true

# Test with single value
query I
SELECT (_ts_stats([5.0])).length;
----
1

# Test with constant series
query I
SELECT (_ts_stats([3.0, 3.0, 3.0, 3.0, 3.0])).variance;
----
0.0

# Test with NULL in array
query I
SELECT (_ts_stats([1.0, NULL, 3.0, NULL, 5.0])).n_nulls;
----
2

# Test NULL input
query I
SELECT _ts_stats(NULL) IS NULL;
----
true

#######################################
# ts_stats_by - Native Table Function Tests (Issue #147)
#######################################

statement ok
CREATE TABLE test_stats_by AS
SELECT
    CASE WHEN i <= 10 THEN 'A' ELSE 'B' END AS group_id,
    '2023-01-01'::TIMESTAMP + INTERVAL (i % 10) DAY AS date,
    (i % 10 + 1)::DOUBLE AS value
FROM range(1, 21) t(i);

# Test ts_stats_by works
query I
SELECT count(*) FROM ts_stats_by('test_stats_by', group_id, date, value, '1d');
----
2

# Test column name is preserved (Issue #147 bug 1)
# The first column should be named 'group_id', not 'id'
# We verify this by selecting the column by name
query T
SELECT group_id FROM ts_stats_by('test_stats_by', group_id, date, value, '1d') ORDER BY group_id LIMIT 1;
----
A

statement ok
DROP TABLE test_stats_by;

#######################################
# ts_stats_by - Monthly Frequency Tests (Issue #147 bugs 2 & 3)
#######################################

# Create monthly data: Jan 2023 through Dec 2023 (12 months, no gaps)
statement ok
CREATE TABLE test_monthly_complete AS
SELECT
    'series_1' AS product_id,
    ('2023-' || LPAD(CAST(i AS VARCHAR), 2, '0') || '-15')::TIMESTAMP AS date,
    (100 + i * 10)::DOUBLE AS sales
FROM generate_series(1, 12) AS t(i);

# Test monthly expected_length - should be 12 (12 months from Jan to Dec)
query II
SELECT length, expected_length
FROM ts_stats_by('test_monthly_complete', product_id, date, sales, '1mo');
----
12	12

# Test monthly n_gaps - should be 0 (no missing months)
query I
SELECT n_gaps
FROM ts_stats_by('test_monthly_complete', product_id, date, sales, '1mo');
----
0

statement ok
DROP TABLE test_monthly_complete;

# Create monthly data with gaps: Jan, Feb, Mar, May, Jun (missing April)
statement ok
CREATE TABLE test_monthly_gaps AS
SELECT
    'series_1' AS product_id,
    ('2023-' || LPAD(CAST(m AS VARCHAR), 2, '0') || '-15')::TIMESTAMP AS date,
    (100 + m * 10)::DOUBLE AS sales
FROM (VALUES (1), (2), (3), (5), (6)) AS t(m);

# Test monthly expected_length with gaps - should be 6 (Jan to Jun = 6 months)
query II
SELECT length, expected_length
FROM ts_stats_by('test_monthly_gaps', product_id, date, sales, '1mo');
----
5	6

# Test monthly n_gaps - should be 1 (April is missing)
query I
SELECT n_gaps
FROM ts_stats_by('test_monthly_gaps', product_id, date, sales, '1mo');
----
1

statement ok
DROP TABLE test_monthly_gaps;

# Create quarterly data: Q1-Q4 2023 (4 quarters, no gaps)
statement ok
CREATE TABLE test_quarterly AS
SELECT
    'product_A' AS sku,
    ('2023-' || LPAD(CAST((q-1) * 3 + 1 AS VARCHAR), 2, '0') || '-01')::TIMESTAMP AS quarter_start,
    (1000 + q * 100)::DOUBLE AS revenue
FROM generate_series(1, 4) AS t(q);

# Test quarterly expected_length - should be 4
query II
SELECT length, expected_length
FROM ts_stats_by('test_quarterly', sku, quarter_start, revenue, '1q');
----
4	4

# Test quarterly n_gaps - should be 0
query I
SELECT n_gaps
FROM ts_stats_by('test_quarterly', sku, quarter_start, revenue, '1q');
----
0

statement ok
DROP TABLE test_quarterly;

# Create yearly data: 2020-2024 with 2022 missing (gap)
statement ok
CREATE TABLE test_yearly_gaps AS
SELECT
    'region_1' AS region,
    (CAST(y AS VARCHAR) || '-06-15')::TIMESTAMP AS year_mid,
    (50000 + (y - 2020) * 5000)::DOUBLE AS annual_sales
FROM (VALUES (2020), (2021), (2023), (2024)) AS t(y);

# Test yearly expected_length with gaps - should be 5 (2020 to 2024 = 5 years)
query II
SELECT length, expected_length
FROM ts_stats_by('test_yearly_gaps', region, year_mid, annual_sales, '1y');
----
4	5

# Test yearly n_gaps - should be 1 (2022 is missing)
query I
SELECT n_gaps
FROM ts_stats_by('test_yearly_gaps', region, year_mid, annual_sales, '1y');
----
1

statement ok
DROP TABLE test_yearly_gaps;

#######################################
# ts_stats_by - Column Name Preservation with Different Names
#######################################

statement ok
CREATE TABLE test_custom_cols AS
SELECT
    'SKU_' || i AS my_custom_product_name,
    '2023-01-01'::TIMESTAMP + INTERVAL i DAY AS transaction_date,
    (100 + i)::DOUBLE AS amount
FROM generate_series(1, 5) AS t(i);

# Verify the output column preserves the input name 'my_custom_product_name'
query T
SELECT my_custom_product_name FROM ts_stats_by('test_custom_cols', my_custom_product_name, transaction_date, amount, '1d') ORDER BY my_custom_product_name LIMIT 1;
----
SKU_1

statement ok
DROP TABLE test_custom_cols;


#######################################
# ts_quality_report - Quality Report from Stats
#######################################

statement ok
CREATE TABLE test_qr_data AS
SELECT
    CASE 
        WHEN i <= 10 THEN 'series_ok'
        WHEN i <= 15 THEN 'series_short'
        ELSE 'series_constant'
    END AS id,
    '2023-01-01'::TIMESTAMP + INTERVAL (i % 10) DAY AS date,
    CASE 
        WHEN i > 15 THEN 5.0  -- constant series
        ELSE (i % 10 + 1)::DOUBLE
    END AS value
FROM range(1, 21) t(i);

statement ok
CREATE TABLE test_qr_stats AS
SELECT * FROM ts_stats('test_qr_data', id, date, value, '1d');

# Test ts_quality_report returns expected columns
query IIIII
SELECT n_passed, n_nan_issues, n_missing_issues, n_constant, n_total
FROM ts_quality_report('test_qr_stats', 8);
----
1	0	0	1	3

statement ok
DROP TABLE test_qr_stats;

statement ok
DROP TABLE test_qr_data;

#######################################
# ts_stats_summary - Summary Statistics
#######################################

statement ok
CREATE TABLE test_summary_data AS
SELECT
    CASE WHEN i <= 15 THEN 'A' ELSE 'B' END AS id,
    '2023-01-01'::TIMESTAMP + INTERVAL (i % 15) DAY AS date,
    (i * 1.5 + 10.0)::DOUBLE AS value
FROM range(1, 26) t(i);

statement ok
CREATE TABLE test_summary_stats AS
SELECT * FROM ts_stats('test_summary_data', id, date, value, '1d');

# Test ts_stats_summary returns expected columns
query IIIIII
SELECT n_series, avg_length, min_length, max_length, total_nulls, total_nans
FROM ts_stats_summary('test_summary_stats');
----
2	12.5	10	15	0	0

statement ok
DROP TABLE test_summary_stats;

statement ok
DROP TABLE test_summary_data;

#######################################
# ts_stats_agg - Aggregate Function Tests
#######################################

# Create test data for aggregate tests
statement ok
CREATE TABLE test_agg_series AS
SELECT 'A' AS id,
       ('2023-01-01'::DATE + (i || ' days')::INTERVAL)::TIMESTAMP AS date,
       (i + 1)::DOUBLE AS value
FROM generate_series(0, 9) AS t(i)
UNION ALL
SELECT 'B' AS id,
       ('2023-01-01'::DATE + (i || ' days')::INTERVAL)::TIMESTAMP AS date,
       (i * 2)::DOUBLE AS value
FROM generate_series(0, 9) AS t(i);

# Test ts_stats_agg basic aggregation
query II
SELECT id, (ts_stats_agg(date, value)).length
FROM test_agg_series
GROUP BY id
ORDER BY id;
----
A	10
B	10

# Test ts_stats_agg mean calculation
query IR
SELECT id, (ts_stats_agg(date, value)).mean
FROM test_agg_series
GROUP BY id
ORDER BY id;
----
A	5.5
B	9.0

# Test ts_stats_agg min/max
query IRR
SELECT id, (ts_stats_agg(date, value)).min, (ts_stats_agg(date, value)).max
FROM test_agg_series
GROUP BY id
ORDER BY id;
----
A	1.0	10.0
B	0.0	18.0

# Test ts_stats_agg variance (should be non-zero for non-constant series)
query I
SELECT (ts_stats_agg(date, value)).variance > 0
FROM test_agg_series
WHERE id = 'A';
----
true

# Test ts_stats_agg returns STRUCT with expected fields
query I
SELECT (ts_stats_agg(date, value)).sum IS NOT NULL
FROM test_agg_series
WHERE id = 'A';
----
true

# Test ts_stats_agg with aliased name
query I
SELECT (anofox_fcst_ts_stats_agg(date, value)).length
FROM test_agg_series
WHERE id = 'A';
----
10

statement ok
DROP TABLE test_agg_series;
