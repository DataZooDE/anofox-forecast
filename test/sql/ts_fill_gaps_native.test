# name: test/sql/_ts_fill_gaps_native.test
# description: Test _ts_fill_gaps_native table-in-out function with type preservation
# group: [anofox_forecast]

require anofox_forecast

require json

# Test DATE type preservation
statement ok
CREATE TABLE test_date AS
SELECT 'A' as group_col, d::DATE as date_col, v as value
FROM (VALUES
    ('2024-01-01', 10.0),
    ('2024-01-02', 20.0),
    ('2024-01-04', 40.0)
) AS t(d, v);

query III
SELECT * FROM _ts_fill_gaps_native(
    (SELECT group_col, date_col, value FROM test_date ORDER BY group_col, date_col),
    '1d'
);
----
A	2024-01-01	10.0
A	2024-01-02	20.0
A	2024-01-03	NULL
A	2024-01-04	40.0

# Verify DATE type is preserved
query I
SELECT typeof(date_col) FROM _ts_fill_gaps_native(
    (SELECT group_col, date_col, value FROM test_date ORDER BY group_col, date_col),
    '1d'
) LIMIT 1;
----
DATE

# Test TIMESTAMP type preservation with hourly frequency
statement ok
DROP TABLE IF EXISTS test_timestamp;

statement ok
CREATE TABLE test_timestamp AS
SELECT 'B' as group_col, ts as date_col, val as value
FROM (VALUES
    ('2024-01-01 00:00:00'::TIMESTAMP, 10.0),
    ('2024-01-01 01:00:00'::TIMESTAMP, 20.0),
    ('2024-01-01 03:00:00'::TIMESTAMP, 40.0)
) AS t(ts, val);

query III
SELECT * FROM _ts_fill_gaps_native(
    (SELECT group_col, date_col, value FROM test_timestamp ORDER BY group_col, date_col),
    '1h'
);
----
B	2024-01-01 00:00:00	10.0
B	2024-01-01 01:00:00	20.0
B	2024-01-01 02:00:00	NULL
B	2024-01-01 03:00:00	40.0

# Verify TIMESTAMP type is preserved
query I
SELECT typeof(date_col) FROM _ts_fill_gaps_native(
    (SELECT group_col, date_col, value FROM test_timestamp ORDER BY group_col, date_col),
    '1h'
) LIMIT 1;
----
TIMESTAMP

# Test BIGINT with raw integer frequency
statement ok
DROP TABLE IF EXISTS test_bigint;

statement ok
CREATE TABLE test_bigint AS
SELECT 'C'::VARCHAR as group_col, ts as date_col, val as value
FROM (VALUES
    (1::BIGINT, 10.0),
    (2::BIGINT, 20.0),
    (4::BIGINT, 40.0)
) AS t(ts, val);

query III
SELECT * FROM _ts_fill_gaps_native(
    (SELECT group_col, date_col, value FROM test_bigint ORDER BY group_col, date_col),
    '1'
);
----
C	1	10.0
C	2	20.0
C	3	NULL
C	4	40.0

# Verify BIGINT type is preserved
query I
SELECT typeof(date_col) FROM _ts_fill_gaps_native(
    (SELECT group_col, date_col, value FROM test_bigint ORDER BY group_col, date_col),
    '1'
) LIMIT 1;
----
BIGINT

# Test INTEGER with raw integer frequency
statement ok
DROP TABLE IF EXISTS test_integer;

statement ok
CREATE TABLE test_integer AS
SELECT 'D'::VARCHAR as group_col, ts::INTEGER as date_col, val as value
FROM (VALUES
    (100, 10.0),
    (200, 20.0),
    (400, 40.0)
) AS t(ts, val);

query III
SELECT * FROM _ts_fill_gaps_native(
    (SELECT group_col, date_col, value FROM test_integer ORDER BY group_col, date_col),
    '100'
);
----
D	100	10.0
D	200	20.0
D	300	NULL
D	400	40.0

# Test multiple groups
statement ok
DROP TABLE IF EXISTS test_multi;

statement ok
CREATE TABLE test_multi AS
SELECT group_col, date_col::DATE as date_col, value FROM (VALUES
    ('G1', '2024-01-01', 10.0),
    ('G1', '2024-01-03', 30.0),
    ('G2', '2024-01-01', 100.0),
    ('G2', '2024-01-02', 200.0),
    ('G2', '2024-01-04', 400.0)
) AS t(group_col, date_col, value);

query III
SELECT * FROM _ts_fill_gaps_native(
    (SELECT group_col, date_col, value FROM test_multi ORDER BY group_col, date_col),
    '1d'
) ORDER BY group_col, date_col;
----
G1	2024-01-01	10.0
G1	2024-01-02	NULL
G1	2024-01-03	30.0
G2	2024-01-01	100.0
G2	2024-01-02	200.0
G2	2024-01-03	NULL
G2	2024-01-04	400.0

# Test with DuckDB interval-style frequency
statement ok
DROP TABLE IF EXISTS test_interval;

statement ok
CREATE TABLE test_interval AS
SELECT 'E' as group_col, d::DATE as date_col, v as value
FROM (VALUES
    ('2024-01-01', 10.0),
    ('2024-01-08', 80.0)
) AS t(d, v);

query III
SELECT * FROM _ts_fill_gaps_native(
    (SELECT group_col, date_col, value FROM test_interval ORDER BY group_col, date_col),
    '1 week'
);
----
E	2024-01-01	10.0
E	2024-01-08	80.0

# Test alias with anofox_fcst prefix
query III
SELECT * FROM anofox_fcst__ts_fill_gaps_native(
    (SELECT group_col, date_col, value FROM test_date ORDER BY group_col, date_col),
    '1d'
);
----
A	2024-01-01	10.0
A	2024-01-02	20.0
A	2024-01-03	NULL
A	2024-01-04	40.0

# ==============================================================================
# Test monthly frequency with calendar-aware gap filling
# ==============================================================================

statement ok
DROP TABLE IF EXISTS test_monthly;

statement ok
CREATE TABLE test_monthly AS
SELECT 'M' as group_col, d::DATE as date_col, v as value
FROM (VALUES
    ('2023-01-01', 100.0),
    ('2023-03-01', 300.0)
) AS t(d, v);

# Monthly frequency should correctly insert February (not Jan 31)
query III
SELECT * FROM _ts_fill_gaps_native(
    (SELECT group_col, date_col, value FROM test_monthly ORDER BY group_col, date_col),
    '1mo'
);
----
M	2023-01-01	100.0
M	2023-02-01	NULL
M	2023-03-01	300.0

# Test monthly with multiple missing months
statement ok
DROP TABLE IF EXISTS test_monthly_multi;

statement ok
CREATE TABLE test_monthly_multi AS
SELECT 'N' as group_col, d::DATE as date_col, v as value
FROM (VALUES
    ('2023-01-15', 100.0),
    ('2023-05-15', 500.0)
) AS t(d, v);

# Should fill Feb, Mar, Apr (4 gaps)
query III
SELECT * FROM _ts_fill_gaps_native(
    (SELECT group_col, date_col, value FROM test_monthly_multi ORDER BY group_col, date_col),
    '1mo'
);
----
N	2023-01-15	100.0
N	2023-02-01	NULL
N	2023-03-01	NULL
N	2023-04-01	NULL
N	2023-05-15	500.0

# Test monthly with DuckDB interval-style "1 month"
statement ok
DROP TABLE IF EXISTS test_monthly_interval;

statement ok
CREATE TABLE test_monthly_interval AS
SELECT 'O' as group_col, d::DATE as date_col, v as value
FROM (VALUES
    ('2024-10-01', 100.0),
    ('2024-12-01', 300.0)
) AS t(d, v);

query III
SELECT * FROM _ts_fill_gaps_native(
    (SELECT group_col, date_col, value FROM test_monthly_interval ORDER BY group_col, date_col),
    '1 month'
);
----
O	2024-10-01	100.0
O	2024-11-01	NULL
O	2024-12-01	300.0

# ==============================================================================
# Test quarterly frequency
# ==============================================================================

statement ok
DROP TABLE IF EXISTS test_quarterly;

statement ok
CREATE TABLE test_quarterly AS
SELECT 'Q' as group_col, d::DATE as date_col, v as value
FROM (VALUES
    ('2023-01-01', 100.0),
    ('2023-07-01', 300.0)
) AS t(d, v);

# Should fill Q2 (Apr 1)
query III
SELECT * FROM _ts_fill_gaps_native(
    (SELECT group_col, date_col, value FROM test_quarterly ORDER BY group_col, date_col),
    '1q'
);
----
Q	2023-01-01	100.0
Q	2023-04-01	NULL
Q	2023-07-01	300.0

# ==============================================================================
# Test yearly frequency
# ==============================================================================

statement ok
DROP TABLE IF EXISTS test_yearly;

statement ok
CREATE TABLE test_yearly AS
SELECT 'Y' as group_col, d::DATE as date_col, v as value
FROM (VALUES
    ('2020-01-01', 100.0),
    ('2023-01-01', 400.0)
) AS t(d, v);

# Should fill 2021, 2022
query III
SELECT * FROM _ts_fill_gaps_native(
    (SELECT group_col, date_col, value FROM test_yearly ORDER BY group_col, date_col),
    '1y'
);
----
Y	2020-01-01	100.0
Y	2021-01-01	NULL
Y	2022-01-01	NULL
Y	2023-01-01	400.0
