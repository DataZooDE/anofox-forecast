# name: test/sql/ts_backtest_auto.test
# description: Tests for ts_backtest_auto - one-liner backtest macro
# group: [sql]

require anofox_forecast

require json

#######################################
# Setup Test Data
#######################################

statement ok
CREATE TABLE backtest_demo AS
SELECT
    series_id,
    '2024-01-01'::DATE + (i * INTERVAL '1 day') AS date,
    10.0 + CASE WHEN series_id = 'A' THEN 50 ELSE 0 END + i AS value
FROM generate_series(0, 59) AS t(i)
CROSS JOIN (SELECT UNNEST(['A', 'B']) AS series_id) s;

#######################################
# ts_backtest_auto - Basic Tests
#######################################

# Test returns correct number of rows (folds × series × horizon)
# 3 folds × 2 series × 7 horizon = 42
query I
SELECT COUNT(*) FROM ts_backtest_auto_by(
    'backtest_demo', series_id, date, value, 7, 3, '1d', MAP{}
);
----
42

# Test has all expected columns (11 columns including fold_metric_score)
query I
SELECT COUNT(*) FROM (
    DESCRIBE SELECT * FROM ts_backtest_auto_by(
        'backtest_demo', series_id, date, value, 7, 3, '1d', MAP{}
    )
);
----
11

# Test all folds are represented
query I
SELECT COUNT(DISTINCT fold_id) FROM ts_backtest_auto_by(
    'backtest_demo', series_id, date, value, 7, 3, '1d', MAP{}
);
----
3

# Test all series are represented per fold
query II
SELECT fold_id, COUNT(DISTINCT group_col) FROM ts_backtest_auto_by(
    'backtest_demo', series_id, date, value, 7, 3, '1d', MAP{}
)
GROUP BY fold_id ORDER BY fold_id;
----
1	2
2	2
3	2

# Test forecast count per fold per series matches horizon
query III
SELECT fold_id, group_col, COUNT(*) as n FROM ts_backtest_auto_by(
    'backtest_demo', series_id, date, value, 7, 3, '1d', MAP{}
)
GROUP BY fold_id, group_col ORDER BY fold_id, group_col;
----
1	A	7
1	B	7
2	A	7
2	B	7
3	A	7
3	B	7

#######################################
# ts_backtest_auto - Method Parameter Tests
#######################################

# Test with Naive method
query I
SELECT DISTINCT model_name FROM ts_backtest_auto_by(
    'backtest_demo', series_id, date, value, 7, 3, '1d', MAP{'method': 'Naive'}
);
----
Naive

# Test with different method
query I
SELECT COUNT(DISTINCT model_name) >= 1 FROM ts_backtest_auto_by(
    'backtest_demo', series_id, date, value, 7, 3, '1d', MAP{'method': 'AutoETS'}
);
----
true

#######################################
# ts_backtest_auto - Output Validation
#######################################

# Test forecast and actual are numeric
query I
SELECT COUNT(*) FROM ts_backtest_auto_by(
    'backtest_demo', series_id, date, value, 7, 3, '1d', MAP{}
) WHERE forecast IS NOT NULL AND actual IS NOT NULL;
----
42

# Test error = forecast - actual
query I
SELECT COUNT(*) FROM ts_backtest_auto_by(
    'backtest_demo', series_id, date, value, 7, 3, '1d', MAP{}
) WHERE ABS(error - (forecast - actual)) < 0.0001;
----
42

# Test abs_error = |error|
query I
SELECT COUNT(*) FROM ts_backtest_auto_by(
    'backtest_demo', series_id, date, value, 7, 3, '1d', MAP{}
) WHERE ABS(abs_error - ABS(error)) < 0.0001;
----
42

#######################################
# ts_backtest_auto - Gap Parameter Tests
#######################################

# Test gap parameter affects forecast dates
# With gap=2: forecast dates start 3 days after train_end instead of 1 day
# Verify we still get some forecasts (may be fewer due to data range limits)
query I
SELECT COUNT(*) > 0 FROM ts_backtest_auto_by(
    'backtest_demo', series_id, date, value, 7, 2, '1d', MAP{'gap': '2'}
);
----
true

#######################################
# ts_backtest_auto - Aggregate Metrics
#######################################

# Test can compute aggregate metrics
query II
SELECT
    group_col,
    ROUND(AVG(abs_error), 2) > 0 AS has_error
FROM ts_backtest_auto_by(
    'backtest_demo', series_id, date, value, 7, 3, '1d', MAP{'method': 'Naive'}
)
GROUP BY group_col
ORDER BY group_col;
----
A	true
B	true

#######################################
# ts_backtest_auto - Metric Parameter Tests
#######################################

# Test fold_metric_score column exists and is numeric
query I
SELECT COUNT(*) FROM ts_backtest_auto_by(
    'backtest_demo', series_id, date, value, 7, 3, '1d', MAP{}
) WHERE fold_metric_score IS NOT NULL;
----
42

# Test metric='mae' returns MAE scores
query I
SELECT COUNT(DISTINCT fold_metric_score) >= 1 FROM ts_backtest_auto_by(
    'backtest_demo', series_id, date, value, 7, 3, '1d', MAP{},
    metric => 'mae'
);
----
true

# Test metric='rmse' returns RMSE scores (default)
query I
SELECT COUNT(DISTINCT fold_metric_score) >= 1 FROM ts_backtest_auto_by(
    'backtest_demo', series_id, date, value, 7, 3, '1d', MAP{},
    metric => 'rmse'
);
----
true

# Test metric='mse' returns MSE scores
query I
SELECT COUNT(DISTINCT fold_metric_score) >= 1 FROM ts_backtest_auto_by(
    'backtest_demo', series_id, date, value, 7, 3, '1d', MAP{},
    metric => 'mse'
);
----
true

# Test fold_metric_score is consistent within each fold
query I
SELECT COUNT(DISTINCT n_unique_scores) FROM (
    SELECT fold_id, COUNT(DISTINCT ROUND(fold_metric_score, 6)) AS n_unique_scores
    FROM ts_backtest_auto_by(
        'backtest_demo', series_id, date, value, 7, 3, '1d', MAP{}
    )
    GROUP BY fold_id
);
----
1

#######################################
# ts_backtest_auto - Features Parameter Tests
#######################################

# Test features parameter accepts empty array (default)
query I
SELECT COUNT(*) FROM ts_backtest_auto_by(
    'backtest_demo', series_id, date, value, 7, 3, '1d', MAP{},
    features => []::VARCHAR[]
);
----
42

#######################################
# Single Series Test
#######################################

statement ok
CREATE TABLE single_series AS
SELECT
    'X' AS series_id,
    '2024-01-01'::DATE + (i * INTERVAL '1 day') AS date,
    100.0 + i AS value
FROM generate_series(0, 59) AS t(i);

# Test with single series
query I
SELECT COUNT(*) FROM ts_backtest_auto_by(
    'single_series', series_id, date, value, 7, 3, '1d', MAP{}
);
----
21

#######################################
# MAP Params Tests
# Test that MAP syntax works with string values
#######################################

# Test MAP with method (VARCHAR)
query I
SELECT DISTINCT model_name FROM ts_backtest_auto_by(
    'backtest_demo', series_id, date, value, 7, 3, '1d', MAP{'method': 'Naive'}
);
----
Naive

# Test MAP with method and gap (both VARCHAR - MAP requires same types)
query I
SELECT COUNT(*) > 0 FROM ts_backtest_auto_by(
    'backtest_demo', series_id, date, value, 7, 2, '1d', MAP{'method': 'Naive', 'gap': '2'}
);
----
true

# Test MAP with clip_horizon (VARCHAR 'true')
query I
SELECT COUNT(*) > 0 FROM ts_backtest_auto_by(
    'backtest_demo', series_id, date, value, 7, 2, '1d', MAP{'clip_horizon': 'true'}
);
----
true

# Test MAP with multiple params (all VARCHAR)
query I
SELECT COUNT(*) > 0 FROM ts_backtest_auto_by(
    'backtest_demo', series_id, date, value, 7, 2, '1d',
    MAP{'method': 'Naive', 'gap': '1', 'embargo': '0', 'clip_horizon': 'false'}
);
----
true

# Test MAP with string values
query I
SELECT DISTINCT model_name FROM ts_backtest_auto_by(
    'backtest_demo', series_id, date, value, 7, 3, '1d', MAP{'method': 'Naive', 'gap': '0'}
);
----
Naive

# Test empty params - use MAP{} syntax (empty STRUCT {} not valid in DuckDB)
query I
SELECT COUNT(*) FROM ts_backtest_auto_by(
    'backtest_demo', series_id, date, value, 7, 3, '1d', MAP{}
);
----
42

#######################################
# ts_backtest_auto - All Frequency Tests (GH#151)
# Tests ensure backtest works correctly for all supported frequencies:
# - Fixed: hourly (1h), daily (1d), weekly (1w)
# - Calendar: monthly (1mo), quarterly (1q), yearly (1y)
# Calendar frequencies have irregular intervals that don't align with
# fixed-interval calculations (28-31 days for months, etc.)
#######################################

# --- Hourly Frequency Tests ---

statement ok
CREATE TABLE hourly_data AS
SELECT
    'sensor_A' AS sensor_id,
    '2023-01-01'::TIMESTAMP + INTERVAL (i) HOUR AS ts,
    100.0 + i AS reading
FROM generate_series(0, 167) t(i);

# Test hourly frequency returns results
query I
SELECT COUNT(*) FROM ts_backtest_auto_by(
    'hourly_data', sensor_id, ts, reading, 24, 1, '1h', MAP{'method': 'Naive'}
);
----
24

# Test hourly with multiple folds
query I
SELECT COUNT(DISTINCT fold_id) FROM ts_backtest_auto_by(
    'hourly_data', sensor_id, ts, reading, 12, 2, '1h', MAP{'method': 'Naive'}
);
----
2

statement ok
DROP TABLE hourly_data;

# --- Daily Frequency Tests (already covered in main tests, verify here) ---

statement ok
CREATE TABLE daily_data AS
SELECT
    'store_A' AS store_id,
    '2023-01-01'::TIMESTAMP + INTERVAL (i) DAY AS dt,
    100.0 + i AS sales
FROM generate_series(0, 99) t(i);

# Test daily frequency returns expected rows
query I
SELECT COUNT(*) FROM ts_backtest_auto_by(
    'daily_data', store_id, dt, sales, 7, 1, '1d', MAP{'method': 'Naive'}
);
----
7

statement ok
DROP TABLE daily_data;

# --- Weekly Frequency Tests ---

statement ok
CREATE TABLE weekly_data AS
SELECT
    'region_A' AS region_id,
    '2023-01-01'::TIMESTAMP + INTERVAL (i) WEEK AS week_start,
    100.0 + i * 5 AS metric
FROM generate_series(0, 51) t(i);

# Test weekly frequency returns results
query I
SELECT COUNT(*) FROM ts_backtest_auto_by(
    'weekly_data', region_id, week_start, metric, 4, 1, '1w', MAP{'method': 'Naive'}
);
----
4

# Test weekly with multiple folds
query I
SELECT COUNT(DISTINCT fold_id) FROM ts_backtest_auto_by(
    'weekly_data', region_id, week_start, metric, 4, 3, '1w', MAP{'method': 'Naive'}
);
----
3

statement ok
DROP TABLE weekly_data;

# --- Monthly Frequency Tests (Calendar - irregular intervals) ---

statement ok
CREATE TABLE monthly_data AS
SELECT
    'product_A' AS item_id,
    '2022-01-01'::TIMESTAMP + INTERVAL (i) MONTH AS ds,
    100.0 + i * 2 AS value
FROM generate_series(0, 35) t(i);

# Test monthly frequency returns results (not 0 rows - was bug in GH#151)
query I
SELECT COUNT(*) > 0 FROM ts_backtest_auto_by(
    'monthly_data', item_id, ds, value, 6, 1, '1mo', MAP{'method': 'Naive'}
);
----
true

# Test monthly frequency returns expected number of results
query I
SELECT COUNT(*) FROM ts_backtest_auto_by(
    'monthly_data', item_id, ds, value, 6, 1, '1mo', MAP{'method': 'Naive'}
);
----
6

# Test monthly frequency with multiple folds
query I
SELECT COUNT(DISTINCT fold_id) FROM ts_backtest_auto_by(
    'monthly_data', item_id, ds, value, 3, 2, '1mo', MAP{'method': 'Naive'}
);
----
2

# Test monthly data returns actual calendar dates (1st of month, not calculated dates)
query I
SELECT COUNT(*) FROM ts_backtest_auto_by(
    'monthly_data', item_id, ds, value, 3, 1, '1mo', MAP{'method': 'Naive'}
) WHERE EXTRACT(DAY FROM date) = 1;
----
3

# Test column name preserved
query I
SELECT COUNT(DISTINCT item_id) FROM ts_backtest_auto_by(
    'monthly_data', item_id, ds, value, 3, 1, '1mo', MAP{'method': 'Naive'}
);
----
1

statement ok
DROP TABLE monthly_data;

# --- Quarterly Frequency Tests (Calendar - irregular intervals) ---

statement ok
CREATE TABLE quarterly_data AS
SELECT
    'company_A' AS company_id,
    '2018-01-01'::TIMESTAMP + INTERVAL (i * 3) MONTH AS quarter_start,
    1000.0 + i * 50 AS revenue
FROM generate_series(0, 23) t(i);

# Test quarterly frequency returns results (not 0 rows)
query I
SELECT COUNT(*) > 0 FROM ts_backtest_auto_by(
    'quarterly_data', company_id, quarter_start, revenue, 4, 1, '1q', MAP{'method': 'Naive'}
);
----
true

# Test quarterly returns expected rows
query I
SELECT COUNT(*) FROM ts_backtest_auto_by(
    'quarterly_data', company_id, quarter_start, revenue, 4, 1, '1q', MAP{'method': 'Naive'}
);
----
4

# Test quarterly data returns actual quarter start dates (1st of quarter month)
query I
SELECT COUNT(*) FROM ts_backtest_auto_by(
    'quarterly_data', company_id, quarter_start, revenue, 2, 1, '1q', MAP{'method': 'Naive'}
) WHERE EXTRACT(DAY FROM date) = 1 AND EXTRACT(MONTH FROM date) IN (1, 4, 7, 10);
----
2

statement ok
DROP TABLE quarterly_data;

# --- Yearly Frequency Tests (Calendar - irregular intervals due to leap years) ---

statement ok
CREATE TABLE yearly_data AS
SELECT
    'country_A' AS country_id,
    '2005-01-01'::TIMESTAMP + INTERVAL (i) YEAR AS year_start,
    10000.0 + i * 500 AS gdp
FROM generate_series(0, 19) t(i);

# Test yearly frequency returns results (not 0 rows)
query I
SELECT COUNT(*) > 0 FROM ts_backtest_auto_by(
    'yearly_data', country_id, year_start, gdp, 3, 1, '1y', MAP{'method': 'Naive'}
);
----
true

# Test yearly returns expected rows
query I
SELECT COUNT(*) FROM ts_backtest_auto_by(
    'yearly_data', country_id, year_start, gdp, 3, 1, '1y', MAP{'method': 'Naive'}
);
----
3

# Test yearly data returns actual year start dates (Jan 1st)
query I
SELECT COUNT(*) FROM ts_backtest_auto_by(
    'yearly_data', country_id, year_start, gdp, 2, 1, '1y', MAP{'method': 'Naive'}
) WHERE EXTRACT(DAY FROM date) = 1 AND EXTRACT(MONTH FROM date) = 1;
----
2

statement ok
DROP TABLE yearly_data;

# --- Multi-period Frequency Tests (e.g., 2d, 4h, 2w) ---

statement ok
CREATE TABLE biweekly_data AS
SELECT
    'team_A' AS team_id,
    '2023-01-01'::TIMESTAMP + INTERVAL (i * 2) WEEK AS sprint_start,
    50.0 + i * 3 AS velocity
FROM generate_series(0, 25) t(i);

# Test 2-week frequency returns results
query I
SELECT COUNT(*) FROM ts_backtest_auto_by(
    'biweekly_data', team_id, sprint_start, velocity, 3, 1, '2w', MAP{'method': 'Naive'}
);
----
3

statement ok
DROP TABLE biweekly_data;

#######################################
# Cleanup
#######################################

statement ok
DROP TABLE backtest_demo;

statement ok
DROP TABLE single_series;
