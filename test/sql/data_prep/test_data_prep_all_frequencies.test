# name: test/sql/data_prep/test_data_prep_all_frequencies.test
# description: Test all data preparation functions across multiple date frequencies (30min, 1h, 1d, 1w, 1mo, 1q, 1y)
# group: [data_prep]

require anofox_forecast

statement ok
LOAD anofox_forecast;

#############################################
# 30 MINUTE FREQUENCY TESTS
#############################################

# Create test data with 30-minute frequency
statement ok
CREATE TABLE test_30min AS
SELECT 
    ('2024-01-01 00:00:00'::TIMESTAMP + INTERVAL (i * 30) MINUTE) AS date_col,
    'series_1' AS series_id,
    CASE 
        WHEN i BETWEEN 5 AND 7 THEN NULL  -- NULL values
        WHEN i = 15 THEN 500.0            -- Outlier
        ELSE 100.0 + i * 2.0
    END AS value
FROM generate_series(1, 50) t(i)
WHERE i NOT IN (20, 21, 22);  -- Create gaps

# Test: anofox_fcst_ts_fill_gaps with 30min frequency
statement ok
CREATE TABLE filled_gaps_30min AS
SELECT * FROM anofox_fcst_ts_fill_gaps(test_30min, series_id, date_col, value, '30m');

# Verify gaps filled (should have more rows than original)
query I
SELECT COUNT(*) >= 50
FROM filled_gaps_30min
WHERE group_col = 'series_1';
----
true

# Test: anofox_fcst_ts_fill_nulls_forward with 30min frequency
statement ok
CREATE TABLE filled_forward_30min AS
SELECT * FROM anofox_fcst_ts_fill_nulls_forward(test_30min, series_id, date_col, value);

# Verify NULLs are reduced
query I
SELECT SUM(CASE WHEN value_col IS NULL THEN 1 ELSE 0 END)::INT < 3
FROM filled_forward_30min;
----
true

# Test: anofox_fcst_ts_fill_nulls_backward with 30min frequency
statement ok
CREATE TABLE filled_backward_30min AS
SELECT * FROM anofox_fcst_ts_fill_nulls_backward(test_30min, series_id, date_col, value);

# Verify NULLs are reduced
query I
SELECT SUM(CASE WHEN value_col IS NULL THEN 1 ELSE 0 END)::INT < 3
FROM filled_backward_30min;
----
true

# Test: anofox_fcst_ts_fill_nulls_mean with 30min frequency
statement ok
CREATE TABLE filled_mean_30min AS
SELECT * FROM anofox_fcst_ts_fill_nulls_mean(test_30min, series_id, date_col, value);

# Verify all NULLs are filled
query I
SELECT SUM(CASE WHEN value_col IS NULL THEN 1 ELSE 0 END) = 0
FROM filled_mean_30min;
----
true

# Test: anofox_fcst_ts_fill_forward with 30min frequency
statement ok
CREATE TABLE extended_30min AS
SELECT * FROM anofox_fcst_ts_fill_forward(test_30min, series_id, date_col, value, '2024-01-02 12:00:00'::TIMESTAMP, '30m');

# Verify series extended (original has ~47 rows, extended to target should have more)
query I
SELECT COUNT(*) >= 47
FROM extended_30min
WHERE group_col = 'series_1';
----
true

# Test: TS_DIFF with 30min frequency
statement ok
CREATE TABLE diff_30min AS
SELECT * FROM ts_diff(test_30min, series_id, date_col, value, 1);

# Verify differencing applied
query I
SELECT COUNT(*) > 0
FROM diff_30min
WHERE value_col IS NOT NULL;
----
true

#############################################
# 1 HOUR FREQUENCY TESTS
#############################################

# Create test data with 1-hour frequency
statement ok
CREATE TABLE test_1h AS
SELECT 
    ('2024-01-01 00:00:00'::TIMESTAMP + INTERVAL (i) HOUR) AS date_col,
    'series_1' AS series_id,
    CASE 
        WHEN i BETWEEN 5 AND 7 THEN NULL
        WHEN i = 15 THEN 500.0
        ELSE 100.0 + i * 2.0
    END AS value
FROM generate_series(1, 50) t(i)
WHERE i NOT IN (20, 21, 22);

# Test: anofox_fcst_ts_fill_gaps with 1h frequency
statement ok
CREATE TABLE filled_gaps_1h AS
SELECT * FROM anofox_fcst_ts_fill_gaps(test_1h, series_id, date_col, value, '1h');

query I
SELECT COUNT(*) >= 50
FROM filled_gaps_1h
WHERE group_col = 'series_1';
----
true

# Test: anofox_fcst_ts_fill_forward with 1h frequency
statement ok
CREATE TABLE extended_1h AS
SELECT * FROM anofox_fcst_ts_fill_forward(test_1h, series_id, date_col, value, '2024-01-04 00:00:00'::TIMESTAMP, '1h');

# Verify series extended (original has ~47 rows, extended should have more)
query I
SELECT COUNT(*) >= 47
FROM extended_1h
WHERE group_col = 'series_1';
----
true

# Test: anofox_fcst_ts_fill_nulls_const with 1h frequency
statement ok
CREATE TABLE filled_const_1h AS
SELECT * FROM anofox_fcst_ts_fill_nulls_const(test_1h, series_id, date_col, value, 0.0);

query I
SELECT SUM(CASE WHEN value_col IS NULL THEN 1 ELSE 0 END) = 0
FROM filled_const_1h;
----
true

#############################################
# 1 DAY FREQUENCY TESTS (baseline)
#############################################

# Create test data with 1-day frequency
statement ok
CREATE TABLE test_1d AS
SELECT 
    ('2024-01-01'::TIMESTAMP + INTERVAL (i) DAY) AS date_col,
    'series_1' AS series_id,
    CASE 
        WHEN i BETWEEN 5 AND 7 THEN NULL
        WHEN i = 15 THEN 500.0
        ELSE 100.0 + i * 2.0
    END AS value
FROM generate_series(1, 50) t(i)
WHERE i NOT IN (20, 21, 22);

# Test: anofox_fcst_ts_fill_gaps with 1d frequency (default)
statement ok
CREATE TABLE filled_gaps_1d AS
SELECT * FROM anofox_fcst_ts_fill_gaps(test_1d, series_id, date_col, value, '1d');

query I
SELECT COUNT(*) >= 50
FROM filled_gaps_1d
WHERE group_col = 'series_1';
----
true

# Test: anofox_fcst_ts_fill_gaps with NULL frequency (should default to 1d)
# Note: NULL must be cast to VARCHAR to select the date-based overload
statement ok
CREATE TABLE filled_gaps_1d_default AS
SELECT * FROM anofox_fcst_ts_fill_gaps(test_1d, series_id, date_col, value, NULL::VARCHAR);

query I
SELECT COUNT(*) >= 50
FROM filled_gaps_1d_default
WHERE group_col = 'series_1';
----
true

# Test: anofox_fcst_ts_drop_constant with 1d frequency
statement ok
CREATE TABLE test_constant_1d AS
SELECT date_col, 'constant' AS sid, 50.0 AS val
FROM test_1d
LIMIT 10;

statement ok
CREATE TABLE no_constant_1d AS
SELECT * FROM anofox_fcst_ts_drop_constant(test_constant_1d, sid, val);

query I
SELECT COUNT(DISTINCT sid) = 0
FROM no_constant_1d;
----
true

# Test: anofox_fcst_ts_drop_short with 1d frequency
statement ok
CREATE TABLE no_short_1d AS
SELECT * FROM anofox_fcst_ts_drop_short(test_1d, series_id, 30);

query I
SELECT COUNT(*) > 0
FROM no_short_1d;
----
true

# Test: TS_DROP_ZEROS with 1d frequency
statement ok
CREATE TABLE test_zeros_1d AS
SELECT date_col, 'zeros' AS sid, 0.0 AS val
FROM test_1d
LIMIT 10;

statement ok
CREATE TABLE no_zeros_1d AS
SELECT * FROM ts_drop_zeros(test_zeros_1d, sid, val);

query I
SELECT COUNT(DISTINCT sid) = 0
FROM no_zeros_1d;
----
true

# Test: anofox_fcst_ts_drop_leading_zeros with 1d frequency
statement ok
CREATE TABLE test_leading_1d AS
SELECT date_col, 'lead' AS sid, CASE WHEN i <= 3 THEN 0.0 ELSE i::DOUBLE END AS val
FROM (SELECT date_col, ROW_NUMBER() OVER (ORDER BY date_col) AS i FROM test_1d LIMIT 10);

statement ok
CREATE TABLE no_leading_1d AS
SELECT * FROM anofox_fcst_ts_drop_leading_zeros(test_leading_1d, sid, date_col, val);

query I
SELECT COUNT(*) <= 7
FROM no_leading_1d;
----
true

# Test: anofox_fcst_ts_drop_trailing_zeros with 1d frequency
statement ok
CREATE TABLE test_trailing_1d AS
SELECT date_col, 'trail' AS sid, CASE WHEN i >= 8 THEN 0.0 ELSE i::DOUBLE END AS val
FROM (SELECT date_col, ROW_NUMBER() OVER (ORDER BY date_col) AS i FROM test_1d LIMIT 10);

statement ok
CREATE TABLE no_trailing_1d AS
SELECT * FROM anofox_fcst_ts_drop_trailing_zeros(test_trailing_1d, sid, date_col, val);

query I
SELECT COUNT(*) <= 7
FROM no_trailing_1d;
----
true

# Test: anofox_fcst_ts_drop_edge_zeros with 1d frequency
statement ok
CREATE TABLE test_edge_1d AS
SELECT date_col, 'edge' AS sid, 
    CASE 
        WHEN i <= 3 THEN 0.0
        WHEN i >= 8 THEN 0.0
        ELSE i::DOUBLE
    END AS val
FROM (SELECT date_col, ROW_NUMBER() OVER (ORDER BY date_col) AS i FROM test_1d LIMIT 10);

statement ok
CREATE TABLE no_edge_1d AS
SELECT * FROM anofox_fcst_ts_drop_edge_zeros(test_edge_1d, sid, date_col, val);

query I
SELECT COUNT(*) <= 4
FROM no_edge_1d;
----
true

#############################################
# 1 WEEK FREQUENCY TESTS
#############################################

# Create test data with 1-week frequency
statement ok
CREATE TABLE test_1w AS
SELECT 
    ('2024-01-01'::TIMESTAMP + INTERVAL (i) WEEK) AS date_col,
    'series_1' AS series_id,
    CASE 
        WHEN i BETWEEN 5 AND 7 THEN NULL
        WHEN i = 15 THEN 500.0
        ELSE 100.0 + i * 2.0
    END AS value
FROM generate_series(1, 20) t(i)
WHERE i NOT IN (10, 11);

# Test: anofox_fcst_ts_fill_gaps with 1w frequency
statement ok
CREATE TABLE filled_gaps_1w AS
SELECT * FROM anofox_fcst_ts_fill_gaps(test_1w, series_id, date_col, value, '1w');

query I
SELECT COUNT(*) >= 20
FROM filled_gaps_1w
WHERE group_col = 'series_1';
----
true

# Test: anofox_fcst_ts_fill_forward with 1w frequency
statement ok
CREATE TABLE extended_1w AS
SELECT * FROM anofox_fcst_ts_fill_forward(test_1w, series_id, date_col, value, '2024-06-01'::TIMESTAMP, '1w');

query I
SELECT COUNT(*) >= 20
FROM extended_1w
WHERE group_col = 'series_1';
----
true

#############################################
# 1 MONTH FREQUENCY TESTS
#############################################

# Create test data with 1-month frequency
statement ok
CREATE TABLE test_1mo AS
SELECT 
    ('2024-01-01'::TIMESTAMP + INTERVAL (i) MONTH) AS date_col,
    'series_1' AS series_id,
    CASE 
        WHEN i BETWEEN 3 AND 4 THEN NULL
        WHEN i = 10 THEN 500.0
        ELSE 100.0 + i * 2.0
    END AS value
FROM generate_series(1, 12) t(i)
WHERE i NOT IN (8, 9);

# Test: anofox_fcst_ts_fill_gaps with 1mo frequency
statement ok
CREATE TABLE filled_gaps_1mo AS
SELECT * FROM anofox_fcst_ts_fill_gaps(test_1mo, series_id, date_col, value, '1mo');

query I
SELECT COUNT(*) >= 12
FROM filled_gaps_1mo
WHERE group_col = 'series_1';
----
true

# Test: anofox_fcst_ts_fill_forward with 1mo frequency
statement ok
CREATE TABLE extended_1mo AS
SELECT * FROM anofox_fcst_ts_fill_forward(test_1mo, series_id, date_col, value, '2025-01-01'::TIMESTAMP, '1mo');

# Verify series extended (original has ~10 rows due to gaps, extended should have at least that many)
query I
SELECT COUNT(*) >= 10
FROM extended_1mo
WHERE group_col = 'series_1';
----
true

#############################################
# 1 QUARTER FREQUENCY TESTS
#############################################

# Create test data with 1-quarter frequency
statement ok
CREATE TABLE test_1q AS
SELECT 
    ('2024-01-01'::TIMESTAMP + INTERVAL (i * 3) MONTH) AS date_col,
    'series_1' AS series_id,
    CASE 
        WHEN i BETWEEN 2 AND 3 THEN NULL
        WHEN i = 6 THEN 500.0
        ELSE 100.0 + i * 2.0
    END AS value
FROM generate_series(1, 8) t(i)
WHERE i NOT IN (5);

# Test: anofox_fcst_ts_fill_gaps with 1q frequency
statement ok
CREATE TABLE filled_gaps_1q AS
SELECT * FROM anofox_fcst_ts_fill_gaps(test_1q, series_id, date_col, value, '1q');

query I
SELECT COUNT(*) >= 8
FROM filled_gaps_1q
WHERE group_col = 'series_1';
----
true

# Test: anofox_fcst_ts_fill_forward with 1q frequency
statement ok
CREATE TABLE extended_1q AS
SELECT * FROM anofox_fcst_ts_fill_forward(test_1q, series_id, date_col, value, '2025-12-01'::TIMESTAMP, '1q');

# Verify series extended (original has ~7 rows due to gaps, extended should have at least that many)
query I
SELECT COUNT(*) >= 7
FROM extended_1q
WHERE group_col = 'series_1';
----
true

#############################################
# 1 YEAR FREQUENCY TESTS
#############################################

# Create test data with 1-year frequency
statement ok
CREATE TABLE test_1y AS
SELECT 
    ('2020-01-01'::TIMESTAMP + INTERVAL (i) YEAR) AS date_col,
    'series_1' AS series_id,
    CASE 
        WHEN i BETWEEN 2 AND 3 THEN NULL
        WHEN i = 6 THEN 500.0
        ELSE 100.0 + i * 2.0
    END AS value
FROM generate_series(1, 10) t(i)
WHERE i NOT IN (5);

# Test: anofox_fcst_ts_fill_gaps with 1y frequency
statement ok
CREATE TABLE filled_gaps_1y AS
SELECT * FROM anofox_fcst_ts_fill_gaps(test_1y, series_id, date_col, value, '1y');

query I
SELECT COUNT(*) >= 10
FROM filled_gaps_1y
WHERE group_col = 'series_1';
----
true

# Test: anofox_fcst_ts_fill_forward with 1y frequency
statement ok
CREATE TABLE extended_1y AS
SELECT * FROM anofox_fcst_ts_fill_forward(test_1y, series_id, date_col, value, '2030-01-01'::TIMESTAMP, '1y');

query I
SELECT COUNT(*) >= 10
FROM extended_1y
WHERE group_col = 'series_1';
----
true

#############################################
# INTEGER-BASED FREQUENCY TESTS
#############################################

# Create test data with INTEGER date column
statement ok
CREATE TABLE test_int AS
SELECT 
    i AS date_col,
    'series_1' AS series_id,
    CASE 
        WHEN i BETWEEN 5 AND 7 THEN NULL
        WHEN i = 15 THEN 500.0
        ELSE 100.0 + i * 2.0
    END AS value
FROM generate_series(1, 50) t(i)
WHERE i NOT IN (20, 21, 22);

# Test: anofox_fcst_ts_fill_gaps with integer frequency step=1
statement ok
CREATE TABLE filled_gaps_int1 AS
SELECT * FROM anofox_fcst_ts_fill_gaps(test_int, series_id, date_col, value, 1);

# Verify gaps filled
query I
SELECT COUNT(*) >= 50
FROM filled_gaps_int1
WHERE group_col = 'series_1';
----
true

# Test: anofox_fcst_ts_fill_gaps with integer frequency step=2
statement ok
CREATE TABLE filled_gaps_int2 AS
SELECT * FROM anofox_fcst_ts_fill_gaps(test_int, series_id, date_col, value, 2);

# Verify gaps filled with step=2
query I
SELECT COUNT(*) >= 25
FROM filled_gaps_int2
WHERE group_col = 'series_1';
----
true

# Test: anofox_fcst_ts_fill_forward with integer frequency step=1
statement ok
CREATE TABLE extended_int1 AS
SELECT * FROM anofox_fcst_ts_fill_forward(test_int, series_id, date_col, value, 60, 1);

# Verify series extended
query I
SELECT COUNT(*) >= 50
FROM extended_int1
WHERE group_col = 'series_1';
----
true

# Test: anofox_fcst_ts_fill_forward with integer frequency step=5
statement ok
CREATE TABLE extended_int5 AS
SELECT * FROM anofox_fcst_ts_fill_forward(test_int, series_id, date_col, value, 60, 5);

# Verify series extended with step=5
query I
SELECT COUNT(*) >= 10
FROM extended_int5
WHERE group_col = 'series_1';
----
true

# Test: Validation error - INTEGER date with date-based frequency (should fail at runtime)
# Note: DuckDB will try to match the VARCHAR overload, which will fail when trying to use INTERVAL with INTEGER columns
statement error
SELECT * FROM anofox_fcst_ts_fill_gaps(test_int, series_id, date_col, value, '1d');
----
Binder Error

# Test: Validation error - DATE date with integer frequency (should fail at runtime)
# Note: DuckDB will try to match the INTEGER overload, which will fail when trying to use INTEGER step with DATE columns
statement ok
CREATE TABLE test_date_for_validation AS
SELECT 
    ('2024-01-01'::DATE + INTERVAL (i) DAY)::DATE AS date_col,
    'series_1' AS series_id,
    100.0 + i * 2.0 AS value
FROM generate_series(1, 10) t(i);

statement error
SELECT * FROM anofox_fcst_ts_fill_gaps(test_date_for_validation, series_id, date_col, value, 1);
----
Binder Error

#############################################
# CLEANUP
#############################################

statement ok
DROP TABLE test_30min;

statement ok
DROP TABLE filled_gaps_30min;

statement ok
DROP TABLE filled_forward_30min;

statement ok
DROP TABLE filled_backward_30min;

statement ok
DROP TABLE filled_mean_30min;

statement ok
DROP TABLE extended_30min;

statement ok
DROP TABLE diff_30min;

statement ok
DROP TABLE test_1h;

statement ok
DROP TABLE filled_gaps_1h;

statement ok
DROP TABLE extended_1h;

statement ok
DROP TABLE filled_const_1h;

statement ok
DROP TABLE test_1d;

statement ok
DROP TABLE filled_gaps_1d;

statement ok
DROP TABLE filled_gaps_1d_default;

statement ok
DROP TABLE test_constant_1d;

statement ok
DROP TABLE no_constant_1d;

statement ok
DROP TABLE no_short_1d;

statement ok
DROP TABLE test_zeros_1d;

statement ok
DROP TABLE no_zeros_1d;

statement ok
DROP TABLE test_leading_1d;

statement ok
DROP TABLE no_leading_1d;

statement ok
DROP TABLE test_trailing_1d;

statement ok
DROP TABLE no_trailing_1d;

statement ok
DROP TABLE test_edge_1d;

statement ok
DROP TABLE no_edge_1d;

statement ok
DROP TABLE test_1w;

statement ok
DROP TABLE filled_gaps_1w;

statement ok
DROP TABLE extended_1w;

statement ok
DROP TABLE test_1mo;

statement ok
DROP TABLE filled_gaps_1mo;

statement ok
DROP TABLE extended_1mo;

statement ok
DROP TABLE test_1q;

statement ok
DROP TABLE filled_gaps_1q;

statement ok
DROP TABLE extended_1q;

statement ok
DROP TABLE test_1y;

statement ok
DROP TABLE filled_gaps_1y;

statement ok
DROP TABLE extended_1y;

statement ok
DROP TABLE test_int;

statement ok
DROP TABLE filled_gaps_int1;

statement ok
DROP TABLE filled_gaps_int2;

statement ok
DROP TABLE extended_int1;

statement ok
DROP TABLE extended_int5;

statement ok
DROP TABLE test_date_for_validation;

