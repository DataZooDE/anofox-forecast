# name: test/sql/data_prep/test_data_prep_macros.test
# description: Test data preparation table macros
# group: [data_prep]

require anofox_forecast

statement ok
LOAD anofox_forecast;

# Create test data with various issues to be fixed
statement ok
CREATE TABLE raw_data AS
SELECT 
    '2024-01-01'::DATE + INTERVAL (i) DAY AS date,
    'series_1' AS series_id,
    CASE 
        WHEN i <= 10 THEN 100.0 + i * 2.0  -- Normal data
        WHEN i BETWEEN 11 AND 15 THEN NULL  -- NULL values to fill
        WHEN i BETWEEN 16 AND 20 THEN 0.0   -- Zero values
        WHEN i = 25 THEN 500.0              -- Outlier to remove
        ELSE 100.0 + i * 2.0
    END AS value
FROM generate_series(1, 50) t(i)
WHERE i NOT IN (30, 31, 32)  -- Create gaps to fill
UNION ALL
SELECT 
    '2024-01-01'::DATE + INTERVAL (i) DAY AS date,
    'series_2' AS series_id,
    50.0 AS value  -- Constant series to drop
FROM generate_series(1, 30) t(i)
UNION ALL
SELECT 
    '2024-01-01'::DATE + INTERVAL (i) DAY AS date,
    'series_3' AS series_id,
    0.0 AS value  -- All zeros to drop
FROM generate_series(1, 20) t(i);

# Test: TS_FILL_GAPS - Fill missing timestamps
# Signature: ts_fill_gaps(table_name, group_cols, date_col, value_col)
statement ok
CREATE TABLE filled_gaps AS
SELECT * FROM ts_fill_gaps(raw_data, 'series_id', 'date', 'value');

# Verify gaps are filled for series_1
# Original had 47 points (50 - 3 gaps), filled should have 50
query I
SELECT COUNT(*) = 50
FROM filled_gaps
WHERE series_id = 'series_1';
----
true

# Test: TS_FILL_NULLS_FORWARD - Forward fill NULL values
# Signature: ts_fill_nulls_forward(table_name, group_cols, date_col, value_col)
statement ok
CREATE TABLE filled_forward AS
SELECT * FROM ts_fill_nulls_forward(raw_data, 'series_id', 'date', 'value');

# Verify NULLs are reduced (forward fill from last known value)
query I
SELECT COUNT(*) < (SELECT COUNT(*) FROM raw_data WHERE series_id = 'series_1' AND value IS NULL)
FROM filled_forward
WHERE series_id = 'series_1' AND value IS NULL;
----
true

# Test: TS_FILL_NULLS_BACKWARD - Backward fill NULL values
# Signature: ts_fill_nulls_backward(table_name, group_cols, date_col, value_col)
statement ok
CREATE TABLE filled_backward AS
SELECT * FROM ts_fill_nulls_backward(raw_data, 'series_id', 'date', 'value');

# Verify NULLs are reduced (backward fill from next known value)
query I
SELECT COUNT(*) < (SELECT COUNT(*) FROM raw_data WHERE series_id = 'series_1' AND value IS NULL)
FROM filled_backward
WHERE series_id = 'series_1' AND value IS NULL;
----
true

# Test: TS_REMOVE_OUTLIERS - Remove outliers
# Signature: ts_remove_outliers(table_name, group_cols, date_col, value_col)
statement ok
CREATE TABLE outliers_removed AS
SELECT * FROM ts_remove_outliers(raw_data, 'series_id', 'date', 'value');

# Verify outlier (value=500) is handled in series_1
query I
SELECT MAX(value) < 400
FROM outliers_removed
WHERE series_id = 'series_1';
----
true

# Test: TS_NORMALIZE - Normalization
# Signature: ts_normalize(table_name, group_cols, date_col, value_col)
statement ok
CREATE TABLE normalized AS
SELECT * FROM ts_normalize(raw_data, 'series_id', 'date', 'value');

# Verify normalized values exist
query I
SELECT COUNT(*) > 0
FROM normalized
WHERE series_id = 'series_1' AND normalized_value IS NOT NULL;
----
true

# Test: TS_DROP_CONSTANT - Remove constant series
# Signature: ts_drop_constant(table_name, group_cols, date_col, value_col)
statement ok
CREATE TABLE no_constants AS
SELECT * FROM ts_drop_constant(raw_data, 'series_id', 'date', 'value');

# Verify series_2 (constant) is removed
query I
SELECT COUNT(*) = 0
FROM no_constants
WHERE series_id = 'series_2';
----
true

# Verify series_1 and series_3 remain
query I
SELECT COUNT(DISTINCT series_id) = 2
FROM no_constants;
----
true

# Test: TS_DROP_ZEROS - Remove series with all zeros
# Signature: ts_drop_zeros(table_name, group_cols, date_col, value_col)
statement ok
CREATE TABLE no_zeros AS
SELECT * FROM ts_drop_zeros(raw_data, 'series_id', 'date', 'value');

# Verify series_3 (all zeros) is removed
query I
SELECT COUNT(*) = 0
FROM no_zeros
WHERE series_id = 'series_3';
----
true

# Verify series_1 and series_2 remain
query I
SELECT COUNT(DISTINCT series_id) = 2
FROM no_zeros;
----
true

# Test: Complete data preparation workflow
statement ok
CREATE TABLE clean_data AS
WITH step1 AS (
    -- Fill gaps
    SELECT * FROM ts_fill_gaps(raw_data, 'series_id', 'date', 'value')
),
step2 AS (
    -- Fill NULLs
    SELECT * FROM ts_fill_nulls_forward(step1, 'series_id', 'date', 'value')
),
step3 AS (
    -- Remove outliers
    SELECT * FROM ts_remove_outliers(step2, 'series_id', 'date', 'value')
),
step4 AS (
    -- Drop constant series
    SELECT * FROM ts_drop_constant(step3, 'series_id', 'date', 'value')
),
step5 AS (
    -- Drop zero series
    SELECT * FROM ts_drop_zeros(step4, 'series_id', 'date', 'value')
)
SELECT * FROM step5;

# Verify clean data results
# Should only have series_1 (series_2 is constant, series_3 is all zeros)
query I
SELECT COUNT(DISTINCT series_id) = 1
FROM clean_data;
----
true

query I
SELECT series_id = 'series_1'
FROM clean_data
GROUP BY series_id;
----
true

# Verify no NULLs remain
query I
SELECT COUNT(*) = 0
FROM clean_data
WHERE value IS NULL;
----
true

# Verify 50 points for series_1 (gaps filled)
query I
SELECT COUNT(*) = 50
FROM clean_data
WHERE series_id = 'series_1';
----
true

# Cleanup
statement ok
DROP TABLE raw_data;

statement ok
DROP TABLE filled_gaps;

statement ok
DROP TABLE filled_forward;

statement ok
DROP TABLE filled_backward;

statement ok
DROP TABLE outliers_removed;

statement ok
DROP TABLE normalized;

statement ok
DROP TABLE no_constants;

statement ok
DROP TABLE no_zeros;

statement ok
DROP TABLE clean_data;
