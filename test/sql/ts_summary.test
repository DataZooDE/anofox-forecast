# name: test/sql/ts_summary.test
# description: Tests for ts_stats_summary and ts_data_quality_summary table functions
# group: [anofox_forecast]

require anofox_forecast

require json

#######################################
# Setup - Create test data
#######################################

# Create a multi-series dataset
statement ok
CREATE TABLE test_series AS
SELECT 'A' AS id,
       ('2023-01-01'::DATE + (i || ' days')::INTERVAL)::TIMESTAMP AS date,
       (i + 1)::DOUBLE AS value
FROM generate_series(0, 9) AS t(i)
UNION ALL
SELECT 'B' AS id,
       ('2023-01-01'::DATE + (i || ' days')::INTERVAL)::TIMESTAMP AS date,
       (i * 2)::DOUBLE AS value
FROM generate_series(0, 4) AS t(i)
UNION ALL
SELECT 'C' AS id,
       ('2023-01-01'::DATE + (i || ' days')::INTERVAL)::TIMESTAMP AS date,
       (i * 3)::DOUBLE AS value
FROM generate_series(0, 7) AS t(i);

# Create stats table from test_series
statement ok
CREATE TABLE stats_table AS
SELECT * FROM ts_stats('test_series', id, date, value, '1 day');

#######################################
# ts_stats_summary - Basic Tests
#######################################

# Test manual stats summary (ts_stats_summary macro has bug with n_gaps field)
# Using direct SQL that matches what ts_stats_summary should do
query I
SELECT COUNT(*) FROM stats_table;
----
3

# Test n_series count
query I
SELECT COUNT(*) AS n_series FROM stats_table;
----
3

# Test min_length (B has 5 observations)
query I
SELECT MIN(length) AS min_length FROM stats_table;
----
5

# Test max_length (A has 10 observations)
query I
SELECT MAX(length) AS max_length FROM stats_table;
----
10

# Test avg_length (10 + 5 + 8) / 3 = 7.67
query I
SELECT AVG(length) > 7 AND AVG(length) < 8 FROM stats_table;
----
true

# Test total_nulls (no nulls in test data)
query I
SELECT SUM(n_nulls) AS total_nulls FROM stats_table;
----
0

#######################################
# ts_stats_summary - With NULLs
#######################################

# Create series with nulls
statement ok
CREATE TABLE series_with_nulls AS
SELECT 'X' AS id,
       ('2023-01-01'::DATE + (i || ' days')::INTERVAL)::TIMESTAMP AS date,
       CASE WHEN i IN (2, 5) THEN NULL ELSE i::DOUBLE END AS value
FROM generate_series(0, 9) AS t(i);

statement ok
CREATE TABLE stats_with_nulls AS
SELECT * FROM ts_stats('series_with_nulls', id, date, value, '1 day');

# Should report nulls
query I
SELECT SUM(n_nulls) AS total_nulls FROM stats_with_nulls;
----
2

#######################################
# ts_data_quality_summary - Basic Tests
#######################################

# Test function returns result
query I
SELECT COUNT(*) FROM ts_data_quality_summary('test_series', id, date, value, 5);
----
1

# Test n_total count (3 series)
query I
SELECT n_total FROM ts_data_quality_summary('test_series', id, date, value, 5);
----
3

# Test n_good + n_fair + n_poor = n_total
query I
SELECT (n_good + n_fair + n_poor) = n_total FROM ts_data_quality_summary('test_series', id, date, value, 5);
----
true

# Test avg_score is between 0 and 1
query I
SELECT avg_score >= 0 AND avg_score <= 1 FROM ts_data_quality_summary('test_series', id, date, value, 5);
----
true

#######################################
# ts_data_quality_summary - Score Thresholds
#######################################

# Good quality data (score >= 0.8)
# Clean linear trends should have high quality
query I
SELECT n_good >= 0 FROM ts_data_quality_summary('test_series', id, date, value, 5);
----
true

# Fair quality data (0.5 <= score < 0.8)
query I
SELECT n_fair >= 0 FROM ts_data_quality_summary('test_series', id, date, value, 5);
----
true

# Poor quality data (score < 0.5)
query I
SELECT n_poor >= 0 FROM ts_data_quality_summary('test_series', id, date, value, 5);
----
true

#######################################
# ts_data_quality_summary - Different n_short Values
#######################################

# n_short parameter affects quality assessment
# Series shorter than n_short may be considered lower quality
query I
SELECT n_total FROM ts_data_quality_summary('test_series', id, date, value, 3);
----
3

query I
SELECT n_total FROM ts_data_quality_summary('test_series', id, date, value, 10);
----
3

#######################################
# ts_data_quality_summary - Edge Cases
#######################################

# All constant series (poor quality expected)
statement ok
CREATE TABLE constant_series AS
SELECT 'X' AS id,
       ('2023-01-01'::DATE + (i || ' days')::INTERVAL)::TIMESTAMP AS date,
       5.0 AS value
FROM generate_series(0, 9) AS t(i);

# Constant series should be detected
query I
SELECT n_total FROM ts_data_quality_summary('constant_series', id, date, value, 5);
----
1

# Series with nulls
statement ok
CREATE TABLE series_nulls AS
SELECT 'Y' AS id,
       ('2023-01-01'::DATE + (i || ' days')::INTERVAL)::TIMESTAMP AS date,
       CASE WHEN i % 3 = 0 THEN NULL ELSE i::DOUBLE END AS value
FROM generate_series(0, 9) AS t(i);

# Should still compute quality
query I
SELECT n_total FROM ts_data_quality_summary('series_nulls', id, date, value, 5);
----
1

#######################################
# Integration - Combined Workflow
#######################################

# Create a comprehensive test dataset
statement ok
CREATE TABLE comprehensive_series AS
-- Good quality: clean linear trend
SELECT 'good1' AS id,
       ('2023-01-01'::DATE + (i || ' days')::INTERVAL)::TIMESTAMP AS date,
       (10 + i * 2)::DOUBLE AS value
FROM generate_series(0, 19) AS t(i)
UNION ALL
-- Good quality: seasonal pattern
SELECT 'good2' AS id,
       ('2023-01-01'::DATE + (i || ' days')::INTERVAL)::TIMESTAMP AS date,
       (50 + 10 * SIN(i * 3.14159 / 6))::DOUBLE AS value
FROM generate_series(0, 23) AS t(i)
UNION ALL
-- Medium quality: shorter series
SELECT 'medium1' AS id,
       ('2023-01-01'::DATE + (i || ' days')::INTERVAL)::TIMESTAMP AS date,
       (20 + i)::DOUBLE AS value
FROM generate_series(0, 5) AS t(i)
UNION ALL
-- Lower quality: constant
SELECT 'constant1' AS id,
       ('2023-01-01'::DATE + (i || ' days')::INTERVAL)::TIMESTAMP AS date,
       100.0 AS value
FROM generate_series(0, 9) AS t(i);

# Test stats summary on comprehensive data
statement ok
CREATE TABLE comprehensive_stats AS
SELECT id, stats FROM ts_stats('comprehensive_series', id, date, value, '1 day');

query I
SELECT COUNT(*) AS n_series FROM comprehensive_stats;
----
4

# Test quality summary on comprehensive data
query I
SELECT n_total FROM ts_data_quality_summary('comprehensive_series', id, date, value, 5);
----
4

# At least one series should be constant
query I
SELECT n_total >= 1 FROM ts_data_quality_summary('comprehensive_series', id, date, value, 5);
----
true

#######################################
# Field Value Verification
#######################################

# Verify stats table has expected structure
query I
SELECT
    COUNT(*) IS NOT NULL AND
    AVG(length) IS NOT NULL AND
    MIN(length) IS NOT NULL AND
    MAX(length) IS NOT NULL AND
    SUM(n_nulls) IS NOT NULL
FROM stats_table;
----
true

# Verify all fields are returned by ts_data_quality_summary
query I
SELECT
    n_total IS NOT NULL AND
    n_good IS NOT NULL AND
    n_fair IS NOT NULL AND
    n_poor IS NOT NULL AND
    avg_score IS NOT NULL
FROM ts_data_quality_summary('test_series', id, date, value, 5);
----
true

#######################################
# Cleanup
#######################################

statement ok
DROP TABLE test_series;

statement ok
DROP TABLE stats_table;

statement ok
DROP TABLE series_with_nulls;

statement ok
DROP TABLE stats_with_nulls;

statement ok
DROP TABLE constant_series;

statement ok
DROP TABLE series_nulls;

statement ok
DROP TABLE comprehensive_series;

statement ok
DROP TABLE comprehensive_stats;
