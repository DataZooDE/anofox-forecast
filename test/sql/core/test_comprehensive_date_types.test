# name: test/sql/core/test_comprehensive_date_types.test
# description: Comprehensive test for INTEGER, DATE, and TIMESTAMP support across all functions
# group: [core]

require anofox_forecast

statement ok
LOAD anofox_forecast;

#############################################
# FORECASTING FUNCTIONS - ts_forecast
#############################################

# Test ts_forecast with INTEGER
statement ok
CREATE TABLE test_int_single AS
SELECT i AS date_col, (100.0 + i * 5)::DOUBLE AS value
FROM generate_series(1, 30) t(i);

query I
SELECT COUNT(*) = 10
FROM ts_forecast(test_int_single, date_col, value, 'Naive', 10, NULL);
----
true

# Test ts_forecast with DATE
statement ok
CREATE TABLE test_date_single AS
SELECT ('2024-01-01'::DATE + INTERVAL (i) DAY)::DATE AS date_col, (100.0 + i * 5)::DOUBLE AS value
FROM generate_series(1, 30) t(i);

query I
SELECT COUNT(*) = 10
FROM ts_forecast(test_date_single, date_col, value, 'Naive', 10, NULL);
----
true

# Test ts_forecast with TIMESTAMP
statement ok
CREATE TABLE test_ts_single AS
SELECT ('2024-01-01'::TIMESTAMP + INTERVAL (i) DAY) AS date_col, (100.0 + i * 5)::DOUBLE AS value
FROM generate_series(1, 30) t(i);

query I
SELECT COUNT(*) = 10
FROM ts_forecast(test_ts_single, date_col, value, 'Naive', 10, NULL);
----
true

#############################################
# FORECASTING FUNCTIONS - TS_FORECAST_AGG
#############################################

# Test TS_FORECAST_AGG with INTEGER (using Naive model)
statement ok
CREATE TABLE agg_int_result AS
SELECT TS_FORECAST_AGG(date_col, value, 'Naive', 5, NULL) AS result
FROM test_int_single;

query I
SELECT len(result.point_forecast) = 5
FROM agg_int_result;
----
true

# Test TS_FORECAST_AGG with DATE (using Naive model)
statement ok
CREATE TABLE agg_date_result AS
SELECT TS_FORECAST_AGG(date_col, value, 'Naive', 5, NULL) AS result
FROM test_date_single;

query I
SELECT len(result.point_forecast) = 5
FROM agg_date_result;
----
true

# Test TS_FORECAST_AGG with TIMESTAMP (using Naive model)
statement ok
CREATE TABLE agg_ts_result AS
SELECT TS_FORECAST_AGG(date_col, value, 'Naive', 5, NULL) AS result
FROM test_ts_single;

query I
SELECT len(result.point_forecast) = 5
FROM agg_ts_result;
----
true

#############################################
# FORECASTING FUNCTIONS - ts_forecast_by
#############################################

# Test ts_forecast_by with INTEGER
statement ok
CREATE TABLE multi_int AS
SELECT i AS date_col, (i % 3)::VARCHAR AS series_id, (100.0 + i * (i % 3 + 1))::DOUBLE AS value
FROM generate_series(1, 30) t(i);

query I
SELECT COUNT(DISTINCT series_id) = 3
FROM ts_forecast_by(multi_int, series_id, date_col, value, 'Naive', 5, NULL);
----
true

# Test ts_forecast_by with DATE
statement ok
CREATE TABLE multi_date AS
SELECT ('2024-01-01'::DATE + INTERVAL (i) DAY)::DATE AS date_col, (i % 3)::VARCHAR AS series_id, (100.0 + i * (i % 3 + 1))::DOUBLE AS value
FROM generate_series(1, 30) t(i);

query I
SELECT COUNT(DISTINCT series_id) = 3
FROM ts_forecast_by(multi_date, series_id, date_col, value, 'Naive', 5, NULL);
----
true

# Test ts_forecast_by with TIMESTAMP
statement ok
CREATE TABLE multi_ts AS
SELECT ('2024-01-01'::TIMESTAMP + INTERVAL (i) DAY) AS date_col, (i % 3)::VARCHAR AS series_id, (100.0 + i * (i % 3 + 1))::DOUBLE AS value
FROM generate_series(1, 30) t(i);

query I
SELECT COUNT(DISTINCT series_id) = 3
FROM ts_forecast_by(multi_ts, series_id, date_col, value, 'Naive', 5, NULL);
----
true

#############################################
# DATA PREP - ts_fill_gaps
# NOTE: INTEGER support available via sql/data_preparation_integer.sql
# Skipping INTEGER test here to keep test simple - see data_prep test file
#############################################

# Test ts_fill_gaps with DATE
statement ok
CREATE TABLE gaps_date AS
SELECT ('2024-01-01'::DATE + INTERVAL (i) DAY)::DATE AS date_col, 'series_1' AS series_id, 100.0 AS value
FROM generate_series(1, 30) t(i)
WHERE i NOT IN (10, 15, 20);

query I
SELECT COUNT(*) = 30
FROM ts_fill_gaps(gaps_date, series_id, date_col, value, NULL::VARCHAR)
WHERE group_col = 'series_1';
----
true

# Test ts_fill_gaps with TIMESTAMP
statement ok
CREATE TABLE gaps_ts AS
SELECT ('2024-01-01'::TIMESTAMP + INTERVAL (i) DAY) AS date_col, 'series_1' AS series_id, 100.0 AS value
FROM generate_series(1, 30) t(i)
WHERE i NOT IN (10, 15, 20);

query I
SELECT COUNT(*) = 30
FROM ts_fill_gaps(gaps_ts, series_id, date_col, value, NULL::VARCHAR)
WHERE group_col = 'series_1';
----
true

#############################################
# DATA PREP - ts_fill_nulls_forward
# NOTE: This macro works with all date types (INTEGER, DATE, TIMESTAMP)
# Skipping INTEGER test here - see data_prep test file
#############################################

# Test ts_fill_nulls_forward with DATE
statement ok
CREATE TABLE nulls_date AS
SELECT ('2024-01-01'::DATE + INTERVAL (i) DAY)::DATE AS date_col, 'series_1' AS series_id,
    CASE WHEN i BETWEEN 5 AND 7 THEN NULL ELSE 100.0 END AS value
FROM generate_series(1, 30) t(i);

query I
SELECT SUM(CASE WHEN value_col IS NULL THEN 1 ELSE 0 END) < 3
FROM ts_fill_nulls_forward(nulls_date, series_id, date_col, value);
----
true

# Test ts_fill_nulls_forward with TIMESTAMP
statement ok
CREATE TABLE nulls_ts AS
SELECT ('2024-01-01'::TIMESTAMP + INTERVAL (i) DAY) AS date_col, 'series_1' AS series_id,
    CASE WHEN i BETWEEN 5 AND 7 THEN NULL ELSE 100.0 END AS value
FROM generate_series(1, 30) t(i);

query I
SELECT SUM(CASE WHEN value_col IS NULL THEN 1 ELSE 0 END) < 3
FROM ts_fill_nulls_forward(nulls_ts, series_id, date_col, value);
----
true

#############################################
# DATA PREP - ts_fill_nulls_backward
# NOTE: This macro works with all date types (INTEGER, DATE, TIMESTAMP)
# Skipping INTEGER test here - see data_prep test file
#############################################

# Test ts_fill_nulls_backward with DATE
query I
SELECT SUM(CASE WHEN value_col IS NULL THEN 1 ELSE 0 END) < 3
FROM ts_fill_nulls_backward(nulls_date, series_id, date_col, value);
----
true

# Test ts_fill_nulls_backward with TIMESTAMP
query I
SELECT SUM(CASE WHEN value_col IS NULL THEN 1 ELSE 0 END) < 3
FROM ts_fill_nulls_backward(nulls_ts, series_id, date_col, value);
----
true

#############################################
# DATA PREP - ts_fill_nulls_mean
# NOTE: This macro works with all date types (INTEGER, DATE, TIMESTAMP)
# Skipping INTEGER test here - see data_prep test file
#############################################

# Test ts_fill_nulls_mean with DATE
query I
SELECT SUM(CASE WHEN value_col IS NULL THEN 1 ELSE 0 END) = 0
FROM ts_fill_nulls_mean(nulls_date, series_id, date_col, value);
----
true

# Test ts_fill_nulls_mean with TIMESTAMP
query I
SELECT SUM(CASE WHEN value_col IS NULL THEN 1 ELSE 0 END) = 0
FROM ts_fill_nulls_mean(nulls_ts, series_id, date_col, value);
----
true

#############################################
# DATA PREP - ts_drop_constant
# NOTE: ts_drop_constant works with all date types (doesn't use date column)
#############################################

# Test ts_drop_constant with INTEGER
statement ok
CREATE TABLE const_int AS
SELECT i AS date_col, 'series_1' AS series_id, 100.0 AS value FROM generate_series(1, 30) t(i)
UNION ALL
SELECT i AS date_col, 'series_2' AS series_id, (100.0 + i)::DOUBLE AS value FROM generate_series(1, 30) t(i);

query I
SELECT COUNT(DISTINCT series_id) = 1
FROM ts_drop_constant(const_int, series_id, value);
----
true

# Test ts_drop_constant with DATE
statement ok
CREATE TABLE const_date AS
SELECT ('2024-01-01'::DATE + INTERVAL (i) DAY)::DATE AS date_col, 'series_1' AS series_id, 100.0 AS value FROM generate_series(1, 30) t(i)
UNION ALL
SELECT ('2024-01-01'::DATE + INTERVAL (i) DAY)::DATE AS date_col, 'series_2' AS series_id, (100.0 + i)::DOUBLE AS value FROM generate_series(1, 30) t(i);

query I
SELECT COUNT(DISTINCT series_id) = 1
FROM ts_drop_constant(const_date, series_id, value);
----
true

# Test ts_drop_constant with TIMESTAMP
statement ok
CREATE TABLE const_ts AS
SELECT ('2024-01-01'::TIMESTAMP + INTERVAL (i) DAY) AS date_col, 'series_1' AS series_id, 100.0 AS value FROM generate_series(1, 30) t(i)
UNION ALL
SELECT ('2024-01-01'::TIMESTAMP + INTERVAL (i) DAY) AS date_col, 'series_2' AS series_id, (100.0 + i)::DOUBLE AS value FROM generate_series(1, 30) t(i);

query I
SELECT COUNT(DISTINCT series_id) = 1
FROM ts_drop_constant(const_ts, series_id, value);
----
true

#############################################
# DATA PREP - ts_drop_zeros
#############################################

# Test ts_drop_zeros with INTEGER
statement ok
CREATE TABLE zeros_int AS
SELECT i AS date_col, 'series_1' AS series_id, 0.0 AS value FROM generate_series(1, 30) t(i)
UNION ALL
SELECT i AS date_col, 'series_2' AS series_id, (100.0 + i)::DOUBLE AS value FROM generate_series(1, 30) t(i);

query I
SELECT COUNT(DISTINCT series_id) = 1
FROM ts_drop_zeros(zeros_int, series_id, value);
----
true

# Test ts_drop_zeros with DATE
statement ok
CREATE TABLE zeros_date AS
SELECT ('2024-01-01'::DATE + INTERVAL (i) DAY)::DATE AS date_col, 'series_1' AS series_id, 0.0 AS value FROM generate_series(1, 30) t(i)
UNION ALL
SELECT ('2024-01-01'::DATE + INTERVAL (i) DAY)::DATE AS date_col, 'series_2' AS series_id, (100.0 + i)::DOUBLE AS value FROM generate_series(1, 30) t(i);

query I
SELECT COUNT(DISTINCT series_id) = 1
FROM ts_drop_zeros(zeros_date, series_id, value);
----
true

# Test ts_drop_zeros with TIMESTAMP
statement ok
CREATE TABLE zeros_ts AS
SELECT ('2024-01-01'::TIMESTAMP + INTERVAL (i) DAY) AS date_col, 'series_1' AS series_id, 0.0 AS value FROM generate_series(1, 30) t(i)
UNION ALL
SELECT ('2024-01-01'::TIMESTAMP + INTERVAL (i) DAY) AS date_col, 'series_2' AS series_id, (100.0 + i)::DOUBLE AS value FROM generate_series(1, 30) t(i);

query I
SELECT COUNT(DISTINCT series_id) = 1
FROM ts_drop_zeros(zeros_ts, series_id, value);
----
true

#############################################
# DATA PREP - ts_drop_short
#############################################

# Test ts_drop_short with INTEGER
statement ok
CREATE TABLE short_int AS
SELECT i AS date_col, 'series_1' AS series_id, 100.0 AS value FROM generate_series(1, 5) t(i)
UNION ALL
SELECT i AS date_col, 'series_2' AS series_id, 100.0 AS value FROM generate_series(1, 30) t(i);

query I
SELECT COUNT(DISTINCT series_id) = 1
FROM ts_drop_short(short_int, series_id, 10);
----
true

# Test ts_drop_short with DATE
statement ok
CREATE TABLE short_date AS
SELECT ('2024-01-01'::DATE + INTERVAL (i) DAY)::DATE AS date_col, 'series_1' AS series_id, 100.0 AS value FROM generate_series(1, 5) t(i)
UNION ALL
SELECT ('2024-01-01'::DATE + INTERVAL (i) DAY)::DATE AS date_col, 'series_2' AS series_id, 100.0 AS value FROM generate_series(1, 30) t(i);

query I
SELECT COUNT(DISTINCT series_id) = 1
FROM ts_drop_short(short_date, series_id, 10);
----
true

# Test ts_drop_short with TIMESTAMP
statement ok
CREATE TABLE short_ts AS
SELECT ('2024-01-01'::TIMESTAMP + INTERVAL (i) DAY) AS date_col, 'series_1' AS series_id, 100.0 AS value FROM generate_series(1, 5) t(i)
UNION ALL
SELECT ('2024-01-01'::TIMESTAMP + INTERVAL (i) DAY) AS date_col, 'series_2' AS series_id, 100.0 AS value FROM generate_series(1, 30) t(i);

query I
SELECT COUNT(DISTINCT series_id) = 1
FROM ts_drop_short(short_ts, series_id, 10);
----
true

#############################################
# Cleanup
#############################################

statement ok
DROP TABLE test_int_single;

statement ok
DROP TABLE test_date_single;

statement ok
DROP TABLE test_ts_single;

statement ok
DROP TABLE agg_int_result;

statement ok
DROP TABLE agg_date_result;

statement ok
DROP TABLE agg_ts_result;

statement ok
DROP TABLE multi_int;

statement ok
DROP TABLE multi_date;

statement ok
DROP TABLE multi_ts;

statement ok
DROP TABLE gaps_date;

statement ok
DROP TABLE gaps_ts;

statement ok
DROP TABLE nulls_date;

statement ok
DROP TABLE nulls_ts;

statement ok
DROP TABLE const_int;

statement ok
DROP TABLE const_date;

statement ok
DROP TABLE const_ts;

statement ok
DROP TABLE zeros_int;

statement ok
DROP TABLE zeros_date;

statement ok
DROP TABLE zeros_ts;

statement ok
DROP TABLE short_int;

statement ok
DROP TABLE short_date;

statement ok
DROP TABLE short_ts;
