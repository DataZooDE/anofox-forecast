# name: test/sql/core/test_error_resilience.test
# description: Test error resilience / safe mode functionality
# group: [core]

require anofox_forecast

statement ok
LOAD anofox_forecast;

# Test 1: Mixed success/failure in GROUP BY (99 good, 1 bad with NULLs)
statement ok
CREATE TABLE test_mixed_series AS
SELECT 
    CASE 
        WHEN i <= 99 THEN 'store_' || (i::VARCHAR)
        ELSE 'store_bad'
    END AS store_id,
    ('2024-01-01'::TIMESTAMP + INTERVAL (j) DAY) AS date_col,
    CASE 
        WHEN i <= 99 THEN (100.0 + j + i * 0.1)::DOUBLE
        WHEN j = 1 THEN NULL  -- One NULL in bad series
        ELSE 0.0::DOUBLE
    END AS value
FROM generate_series(1, 100) t1(i)
CROSS JOIN generate_series(1, 30) t2(j);

query I
SELECT 
    COUNT(*) = 100,  -- Should get 100 results (one per store)
    SUM(CASE WHEN result.model_name = 'ERROR' THEN 1 ELSE 0 END) = 1,  -- One error
    SUM(CASE WHEN result.model_name != 'ERROR' THEN 1 ELSE 0 END) = 99  -- 99 successful
FROM (
    SELECT store_id, TS_FORECAST_AGG(date_col, value, 'Naive', 5, NULL) AS result
    FROM test_mixed_series
    GROUP BY store_id
);
----
true

# Test 2: Constant zero series (should fail for some models)
statement ok
CREATE TABLE test_constant_zero AS
SELECT 
    'store_zero' AS store_id,
    ('2024-01-01'::TIMESTAMP + INTERVAL (i) DAY) AS date_col,
    0.0::DOUBLE AS value
FROM generate_series(1, 30) t(i);

query I
SELECT result.model_name = 'ERROR'
FROM (
    SELECT TS_FORECAST_AGG(date_col, value, 'AutoARIMA', 5, NULL) AS result
    FROM test_constant_zero
);
----
true

# Test 3: Verify error_message field is present and contains message
query I
SELECT 
    result.model_name = 'ERROR',
    result.error_message IS NOT NULL,
    LENGTH(result.error_message) > 0
FROM (
    SELECT TS_FORECAST_AGG(date_col, value, 'AutoARIMA', 5, NULL) AS result
    FROM test_constant_zero
);
----
true

# Test 4: Verify error rows have NULL point_forecast
query I
SELECT 
    result.model_name = 'ERROR',
    LEN(result.point_forecast) = 0  -- Empty list for errors
FROM (
    SELECT TS_FORECAST_AGG(date_col, value, 'AutoARIMA', 5, NULL) AS result
    FROM test_constant_zero
);
----
true

# Test 5: Test with safe_mode disabled (should throw error)
statement error
SELECT TS_FORECAST_AGG(date_col, value, 'AutoARIMA', 5, {'safe_mode': false}) AS result
FROM test_constant_zero;

# Test 6: Test with include_error_message disabled
query I
SELECT 
    result.model_name = 'ERROR',
    result.error_message IS NULL  -- Should be NULL when disabled
FROM (
    SELECT TS_FORECAST_AGG(date_col, value, 'AutoARIMA', 5, {'include_error_message': false}) AS result
    FROM test_constant_zero
);
----
true

# Test 7: Insufficient data (too short series for AutoARIMA)
statement ok
CREATE TABLE test_short_series AS
SELECT 
    'store_short' AS store_id,
    ('2024-01-01'::TIMESTAMP + INTERVAL (i) DAY) AS date_col,
    (10.0 + i)::DOUBLE AS value
FROM generate_series(1, 5) t(i);  -- Only 5 points, AutoARIMA needs at least 10

query I
SELECT result.model_name = 'ERROR'
FROM (
    SELECT TS_FORECAST_AGG(date_col, value, 'AutoARIMA', 5, NULL) AS result
    FROM test_short_series
);
----
true

# Test 8: Verify successful series still work correctly
statement ok
CREATE TABLE test_good_series AS
SELECT 
    'store_good' AS store_id,
    ('2024-01-01'::TIMESTAMP + INTERVAL (i) DAY) AS date_col,
    (100.0 + i * 2.5)::DOUBLE AS value
FROM generate_series(1, 50) t(i);

query I
SELECT 
    result.model_name = 'Naive',
    LEN(result.point_forecast) = 5,
    result.error_message IS NULL
FROM (
    SELECT TS_FORECAST_AGG(date_col, value, 'Naive', 5, NULL) AS result
    FROM test_good_series
);
----
true

# Test 9: Mixed scenario - some succeed, some fail, verify all return results
statement ok
CREATE TABLE test_mixed_scenario AS
SELECT 
    CASE 
        WHEN i = 1 THEN 'store_bad_short'
        WHEN i = 2 THEN 'store_bad_null'
        ELSE 'store_good_' || (i::VARCHAR)
    END AS store_id,
    ('2024-01-01'::TIMESTAMP + INTERVAL (j) DAY) AS date_col,
    CASE 
        WHEN i = 1 AND j <= 5 THEN (10.0 + j)::DOUBLE  -- Too short for AutoARIMA
        WHEN i = 2 AND j = 10 THEN NULL  -- One NULL
        WHEN i = 2 THEN 0.0::DOUBLE
        ELSE (100.0 + j + i * 0.1)::DOUBLE
    END AS value
FROM generate_series(1, 10) t1(i)
CROSS JOIN generate_series(1, 30) t2(j);

query I
SELECT 
    COUNT(*) = 10,  -- All 10 stores should return results
    SUM(CASE WHEN result.model_name = 'ERROR' THEN 1 ELSE 0 END) = 2,  -- Two errors
    SUM(CASE WHEN result.model_name != 'ERROR' THEN 1 ELSE 0 END) = 8  -- Eight successful
FROM (
    SELECT store_id, TS_FORECAST_AGG(date_col, value, 'AutoARIMA', 5, NULL) AS result
    FROM test_mixed_scenario
    GROUP BY store_id
);
----
true

# Test 10: Verify successful forecasts have correct structure
query I
SELECT 
    result.model_name = 'AutoARIMA',
    LEN(result.point_forecast) = 5,
    LEN(result.lower_90) = 5,
    LEN(result.upper_90) = 5,
    result.error_message IS NULL
FROM (
    SELECT TS_FORECAST_AGG(date_col, value, 'AutoARIMA', 5, NULL) AS result
    FROM test_good_series
);
----
true

# Cleanup
statement ok
DROP TABLE test_mixed_series;

statement ok
DROP TABLE test_constant_zero;

statement ok
DROP TABLE test_short_series;

statement ok
DROP TABLE test_good_series;

statement ok
DROP TABLE test_mixed_scenario;

