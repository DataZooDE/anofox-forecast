# name: test/sql/core/test_multi_id_columns.test
# description: Test forecasting with 3 ID columns (region, store, product)
# group: [core]

require anofox_forecast

statement ok
LOAD anofox_forecast;

# Create hierarchical sales data with 3 ID columns
statement ok
CREATE TABLE sales_data AS
SELECT 
    ('2024-01-01'::TIMESTAMP + INTERVAL (i) DAY) AS date,
    region,
    store,
    product,
    1000.0 + region_id * 100 + store_id * 10 + product_id + i * 2.0 AS sales
FROM (
    SELECT 
        i,
        CASE WHEN i % 6 < 2 THEN 'North' ELSE 'South' END AS region,
        CASE WHEN i % 3 = 0 THEN 'Store_A' WHEN i % 3 = 1 THEN 'Store_B' ELSE 'Store_C' END AS store,
        CASE WHEN i % 2 = 0 THEN 'Product_X' ELSE 'Product_Y' END AS product,
        (i % 6 < 2)::INT AS region_id,
        (i % 3) AS store_id,
        (i % 2) AS product_id
    FROM generate_series(1, 60) t(i)
);

# ============================================================================
# APPROACH 1: Manual GROUP BY with anofox_fcst_ts_forecast_agg (Recommended)
# ============================================================================
# For 3+ ID columns, use manual GROUP BY

# Test 1: Forecast using anofox_fcst_ts_forecast_agg with manual GROUP BY on 3 columns
statement ok
CREATE TABLE forecasts_3id AS
SELECT 
    region,
    store,
    product,
    anofox_fcst_ts_forecast_agg(date, sales, 'Naive', 7, NULL) AS result
FROM sales_data
GROUP BY region, store, product;

# Verify forecasts for multiple combinations
query I
SELECT COUNT(*) > 1
FROM forecasts_3id;
----
true

# Verify each forecast has correct horizon
query I
SELECT COUNT(*) = (SELECT COUNT(*) FROM forecasts_3id)
FROM forecasts_3id
WHERE len(result.point_forecast) = 7;
----
true

# Test 2: Unnest the results manually for easier querying
statement ok
CREATE TABLE forecasts_unnested AS
SELECT 
    region,
    store,
    product,
    UNNEST(result.forecast_step) AS forecast_step,
    UNNEST(result.forecast_timestamp) AS forecast_date,
    UNNEST(result.point_forecast) AS point_forecast,
    UNNEST(result.lower_90) AS lower,
    UNNEST(result.upper_90) AS upper,
    result.model_name
FROM forecasts_3id;

# Verify unnested structure
query I
SELECT COUNT(*) > 0
FROM forecasts_unnested;
----
true

# Test 3: Hierarchical aggregation (roll up from product to store level)
statement ok
CREATE TABLE store_level_forecast AS
SELECT 
    region,
    store,
    forecast_step,
    SUM(point_forecast) AS total_forecast
FROM forecasts_unnested
GROUP BY region, store, forecast_step
ORDER BY region, store, forecast_step;

# Verify store-level aggregation
query I
SELECT COUNT(DISTINCT store) > 0
FROM store_level_forecast;
----
true

# ============================================================================
# APPROACH 2: Composite Key (Alternative)
# ============================================================================
# Create a single composite ID column from multiple ID columns

# Test 4: Create composite key
statement ok
CREATE TABLE sales_with_composite AS
SELECT 
    date,
    region || '|' || store || '|' || product AS composite_id,
    region,
    store,
    product,
    sales
FROM sales_data;

# Test 5: Use anofox_fcst_ts_forecast_by with composite ID
statement ok
CREATE TABLE forecasts_composite AS
SELECT *
FROM anofox_fcst_ts_forecast_by(
    sales_with_composite,
    composite_id,
    date,
    sales,
    'Naive',
    7,
    NULL
);

# Verify forecasts generated
query I
SELECT COUNT(*) > 0
FROM forecasts_composite;
----
true

# Test 6: Split composite ID back to original columns
statement ok
CREATE TABLE forecasts_split AS
SELECT 
    SPLIT_PART(composite_id, '|', 1) AS region,
    SPLIT_PART(composite_id, '|', 2) AS store,
    SPLIT_PART(composite_id, '|', 3) AS product,
    forecast_step,
    point_forecast,
    lower_90 AS lower,
    upper_90 AS upper,
    model_name
FROM forecasts_composite;

# Verify we can reconstruct the hierarchy
query I
SELECT COUNT(DISTINCT region) > 0 
   AND COUNT(DISTINCT store) > 0
   AND COUNT(DISTINCT product) > 0
FROM forecasts_split;
----
true

# Test 7: Compare both approaches produce same number of forecasts
query I
SELECT 
    (SELECT COUNT(*) FROM forecasts_unnested) = 
    (SELECT COUNT(*) FROM forecasts_composite)
FROM (SELECT 1);
----
true

# ============================================================================
# Data Prep with Multiple ID Columns
# ============================================================================

# Test 8: EDA with composite key
statement ok
CREATE TABLE eda_composite AS
SELECT * FROM anofox_fcst_ts_stats(sales_with_composite, composite_id, date, sales, '1d');

# Verify stats generated for multiple series
query I
SELECT COUNT(*) > 1
FROM eda_composite;
----
true

# Test 9: Data prep with composite key
statement ok
CREATE TABLE prepped_data AS
SELECT * FROM anofox_fcst_ts_fill_nulls_forward(sales_with_composite, composite_id, date, sales);

# Verify data prep works with composite ID
query I
SELECT COUNT(*) > 0
FROM prepped_data;
----
true

# Test 10: Regional aggregation after forecasting
statement ok
CREATE TABLE regional_totals AS
SELECT 
    region,
    forecast_step,
    SUM(point_forecast) AS region_total_forecast
FROM forecasts_split
GROUP BY region, forecast_step
ORDER BY region, forecast_step;

# Verify regional aggregation
query I
SELECT COUNT(DISTINCT region) >= 1
FROM regional_totals;
----
true

# Cleanup
statement ok
DROP TABLE sales_data;

statement ok
DROP TABLE forecasts_3id;

statement ok
DROP TABLE forecasts_unnested;

statement ok
DROP TABLE store_level_forecast;

statement ok
DROP TABLE sales_with_composite;

statement ok
DROP TABLE forecasts_composite;

statement ok
DROP TABLE forecasts_split;

statement ok
DROP TABLE eda_composite;

statement ok
DROP TABLE prepped_data;

statement ok
DROP TABLE regional_totals;
