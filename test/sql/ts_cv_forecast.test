# name: test/sql/ts_cv_forecast.test
# description: Tests for ts_cv_forecast_by - CV forecast using ts_cv_folds_by output
# group: [sql]

require anofox_forecast

#######################################
# Setup Test Data
#######################################

statement ok
CREATE TABLE cv_data_24 AS
SELECT 'A' AS series_id, CAST(i AS INTEGER) AS ds, CAST(10.0 + i AS DOUBLE) AS y
FROM generate_series(1, 24) AS t(i);

#######################################
# Basic Workflow Tests
#######################################

# Create folds using ts_cv_folds_by
statement ok
CREATE TABLE cv_folds AS
SELECT * FROM ts_cv_folds_by('cv_data_24', series_id, ds, y, 3, 4, MAP{});

# Verify folds have both train and test
query III
SELECT fold_id, split, COUNT(*) AS cnt FROM cv_folds GROUP BY fold_id, split ORDER BY fold_id, split;
----
1	test	4
1	train	12
2	test	4
2	train	16
3	test	4
3	train	20

# Test ts_cv_forecast_by with pre-generated folds
query III
SELECT fold_id, split, COUNT(*)
FROM ts_cv_forecast_by('cv_folds', series_id, ds, y, 'Naive', MAP{})
GROUP BY fold_id, split ORDER BY fold_id, split;
----
1	test	4
2	test	4
3	test	4

#######################################
# Output Structure Tests
#######################################

# Verify output has expected columns
query I
SELECT COUNT(*) FROM (
    DESCRIBE SELECT * FROM ts_cv_forecast_by('cv_folds', series_id, ds, y, 'Naive', MAP{})
);
----
9

# Verify output column names
query I
SELECT column_name FROM (
    DESCRIBE SELECT * FROM ts_cv_forecast_by('cv_folds', series_id, ds, y, 'Naive', MAP{})
) ORDER BY column_name;
----
ds
fold_id
model_name
series_id
split
y
yhat
yhat_lower
yhat_upper

# Verify forecast values are not NULL for test rows
query I
SELECT COUNT(*) AS null_forecasts
FROM ts_cv_forecast_by('cv_folds', series_id, ds, y, 'Naive', MAP{})
WHERE yhat IS NULL;
----
0

# Verify y (actual) values are preserved
query I
SELECT COUNT(*) AS null_actuals
FROM ts_cv_forecast_by('cv_folds', series_id, ds, y, 'Naive', MAP{})
WHERE y IS NULL;
----
0

#######################################
# Forecast-Test Date Matching Tests
#######################################

# Verify forecasts match existing test dates (not generated)
query I
WITH forecasts AS (
    SELECT * FROM ts_cv_forecast_by('cv_folds', series_id, ds, y, 'Naive', MAP{})
),
original_test AS (
    SELECT * FROM cv_folds WHERE split = 'test'
)
SELECT COUNT(*) AS matched_dates
FROM forecasts f
JOIN original_test t ON f.series_id = t.series_id AND f.fold_id = t.fold_id AND f.ds = t.ds;
----
12

# Verify all forecast dates exist in original test data
query I
WITH forecasts AS (
    SELECT DISTINCT ds FROM ts_cv_forecast_by('cv_folds', series_id, ds, y, 'Naive', MAP{})
),
test_dates AS (
    SELECT DISTINCT ds FROM cv_folds WHERE split = 'test'
)
SELECT COUNT(*) FROM forecasts f LEFT JOIN test_dates t ON f.ds = t.ds WHERE t.ds IS NULL;
----
0

#######################################
# Column Type Preservation Tests
#######################################

# Test INTEGER column preserved
query I
SELECT typeof(ds) FROM ts_cv_forecast_by('cv_folds', series_id, ds, y, 'Naive', MAP{}) LIMIT 1;
----
INTEGER

# Test DATE column preserved
statement ok
CREATE TABLE cv_dates AS
SELECT 'A' AS series_id, CAST('2023-01-01'::DATE + (i * INTERVAL '1 day') AS DATE) AS ds, CAST(i AS DOUBLE) AS y
FROM generate_series(1, 18) AS t(i);

statement ok
CREATE TABLE cv_date_folds AS
SELECT * FROM ts_cv_folds_by('cv_dates', series_id, ds, y, 2, 3, MAP{});

query I
SELECT typeof(ds) FROM ts_cv_forecast_by('cv_date_folds', series_id, ds, y, 'Naive', MAP{}) LIMIT 1;
----
DATE

statement ok
DROP TABLE cv_dates;

statement ok
DROP TABLE cv_date_folds;

#######################################
# Different Forecast Methods Tests
#######################################

# Test Naive method
query I
SELECT DISTINCT model_name FROM ts_cv_forecast_by('cv_folds', series_id, ds, y, 'Naive', MAP{});
----
Naive

# Test Drift method
query I
SELECT DISTINCT model_name FROM ts_cv_forecast_by('cv_folds', series_id, ds, y, 'Drift', MAP{});
----
Drift

# Test different methods produce different forecasts
query I
WITH naive AS (
    SELECT fold_id, ds, yhat AS naive_fcst
    FROM ts_cv_forecast_by('cv_folds', series_id, ds, y, 'Naive', MAP{})
),
drift AS (
    SELECT fold_id, ds, yhat AS drift_fcst
    FROM ts_cv_forecast_by('cv_folds', series_id, ds, y, 'Drift', MAP{})
)
SELECT COUNT(*) > 0 AS forecasts_differ
FROM naive n
JOIN drift d ON n.fold_id = d.fold_id AND n.ds = d.ds
WHERE ABS(n.naive_fcst - d.drift_fcst) > 0.0001;
----
true

#######################################
# Multiple Groups Tests
#######################################

statement ok
CREATE TABLE cv_multi_data AS
SELECT series_id, CAST(i AS INTEGER) AS ds, CAST(10.0 + i AS DOUBLE) AS y
FROM (
    SELECT 'A' AS series_id, i FROM generate_series(1, 20) AS t(i)
    UNION ALL
    SELECT 'B' AS series_id, i FROM generate_series(1, 25) AS t(i)
);

statement ok
CREATE TABLE cv_multi_folds AS
SELECT * FROM ts_cv_folds_by('cv_multi_data', series_id, ds, y, 2, 3, MAP{});

# Each group gets independent forecasts
query III
SELECT series_id, fold_id, COUNT(*)
FROM ts_cv_forecast_by('cv_multi_folds', series_id, ds, y, 'Naive', MAP{})
GROUP BY series_id, fold_id ORDER BY series_id, fold_id;
----
A	1	3
A	2	3
B	1	3
B	2	3

statement ok
DROP TABLE cv_multi_data;

statement ok
DROP TABLE cv_multi_folds;

#######################################
# Edge Cases Tests
#######################################

# Test single fold
statement ok
CREATE TABLE cv_single_fold AS
SELECT * FROM ts_cv_folds_by('cv_data_24', series_id, ds, y, 1, 6, MAP{});

query I
SELECT COUNT(DISTINCT fold_id) FROM ts_cv_forecast_by('cv_single_fold', series_id, ds, y, 'Naive', MAP{});
----
1

statement ok
DROP TABLE cv_single_fold;

# Test horizon=1
statement ok
CREATE TABLE cv_horizon_1 AS
SELECT * FROM ts_cv_folds_by('cv_data_24', series_id, ds, y, 3, 1, MAP{});

query II
SELECT fold_id, COUNT(*)
FROM ts_cv_forecast_by('cv_horizon_1', series_id, ds, y, 'Naive', MAP{})
GROUP BY fold_id ORDER BY fold_id;
----
1	1
2	1
3	1

statement ok
DROP TABLE cv_horizon_1;

#######################################
# Error Handling Tests
#######################################

# Test error when fold data missing required columns (fold_id, split)
statement error
SELECT * FROM ts_cv_forecast_by('cv_data_24', series_id, ds, y, 'Naive', MAP{});
----
fold_id

#######################################
# Params Tests
#######################################

# Test params with seasonal_period
query I
SELECT COUNT(*) FROM ts_cv_forecast_by('cv_folds', series_id, ds, y, 'SeasonalNaive', {'seasonal_period': 4});
----
12

#######################################
# Actual vs Forecast Comparison Tests
#######################################

# Verify y column matches original test data actuals
query I
WITH forecasts AS (
    SELECT fold_id, ds, y AS fcst_y
    FROM ts_cv_forecast_by('cv_folds', series_id, ds, y, 'Naive', MAP{})
),
original AS (
    SELECT fold_id, ds, y AS orig_y
    FROM cv_folds
    WHERE split = 'test'
)
SELECT COUNT(*)
FROM forecasts f
JOIN original o ON f.fold_id = o.fold_id AND f.ds = o.ds
WHERE ABS(f.fcst_y - o.orig_y) > 0.0001;
----
0

# Verify we can compute error metrics
query I
SELECT AVG(ABS(yhat - y)) > 0 AS has_errors
FROM ts_cv_forecast_by('cv_folds', series_id, ds, y, 'Naive', MAP{});
----
true

#######################################
# Cleanup
#######################################

statement ok
DROP TABLE cv_data_24;

statement ok
DROP TABLE cv_folds;
