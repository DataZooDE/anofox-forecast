# name: test/sql/ts_multi_key.test
# description: Tests for multi-key unique_id functions (Issue #78)
# group: [sql]

require anofox_forecast

#######################################
# ts_validate_separator Tests
#######################################

statement ok
CREATE TABLE test_ids AS SELECT * FROM (VALUES
    ('EU', 'STORE001', 'SKU42'),
    ('EU', 'STORE001', 'SKU43'),
    ('US', 'STORE002', 'SKU44')
) AS t(region_id, store_id, item_id);

# Test valid separator (no conflicts)
query I
SELECT is_valid FROM ts_validate_separator('test_ids', region_id, store_id, item_id);
----
true

# Test n_conflicts is 0 for valid data
query I
SELECT n_conflicts FROM ts_validate_separator('test_ids', region_id, store_id, item_id);
----
0

# Test with 2 columns
query I
SELECT is_valid FROM ts_validate_separator('test_ids', region_id, store_id);
----
true

# Test with custom separator
query I
SELECT is_valid FROM ts_validate_separator('test_ids', region_id, store_id, item_id, separator := '-');
----
true

# Test detecting conflict
statement ok
CREATE TABLE test_conflict AS SELECT * FROM (VALUES
    ('EU', 'STORE|001', 'SKU42')
) AS t(region_id, store_id, item_id);

query I
SELECT is_valid FROM ts_validate_separator('test_conflict', region_id, store_id, item_id);
----
false

query I
SELECT n_conflicts FROM ts_validate_separator('test_conflict', region_id, store_id, item_id);
----
1

# Test message contains alternative separators
query I
SELECT message LIKE '%Try%' FROM ts_validate_separator('test_conflict', region_id, store_id, item_id);
----
true

#######################################
# ts_combine_keys Tests
#######################################

statement ok
CREATE TABLE sales AS SELECT * FROM (VALUES
    ('EU', 'STORE001', 'SKU42', DATE '2024-01-01', 100),
    ('EU', 'STORE001', 'SKU42', DATE '2024-01-02', 110),
    ('US', 'STORE002', 'SKU44', DATE '2024-01-01', 200)
) AS t(region_id, store_id, item_id, sale_date, quantity);

# Test basic combination with 3 columns
query I
SELECT COUNT(DISTINCT unique_id) FROM ts_combine_keys('sales', sale_date, quantity, region_id, store_id, item_id);
----
2

# Test correct unique_id format
query I
SELECT unique_id FROM ts_combine_keys('sales', sale_date, quantity, region_id, store_id, item_id) WHERE unique_id LIKE 'EU%SKU42' LIMIT 1;
----
EU|STORE001|SKU42

# Test with 2 columns
query I
SELECT unique_id FROM ts_combine_keys('sales', sale_date, quantity, region_id, store_id) WHERE unique_id LIKE 'EU%' LIMIT 1;
----
EU|STORE001

# Test with custom separator
query I
SELECT unique_id FROM ts_combine_keys('sales', sale_date, quantity, region_id, store_id, item_id, params := MAP{'separator': '-'}) WHERE unique_id LIKE 'EU%' LIMIT 1;
----
EU-STORE001-SKU42

# Test row count preserved
query I
SELECT COUNT(*) FROM ts_combine_keys('sales', sale_date, quantity, region_id, store_id, item_id);
----
3

#######################################
# ts_aggregate_hierarchy Tests
#######################################

statement ok
CREATE TABLE hier_sales AS SELECT * FROM (VALUES
    ('EU', 'STORE001', 'SKU42', DATE '2024-01-01', 100),
    ('EU', 'STORE001', 'SKU43', DATE '2024-01-01', 50),
    ('EU', 'STORE002', 'SKU44', DATE '2024-01-01', 75),
    ('US', 'STORE003', 'SKU45', DATE '2024-01-01', 200)
) AS t(region_id, store_id, item_id, sale_date, quantity);

# Test generates all aggregation levels
query I
SELECT COUNT(DISTINCT unique_id) FROM ts_aggregate_hierarchy('hier_sales', sale_date, quantity, region_id, store_id, item_id);
----
10

# Test grand total exists (AGGREGATED|AGGREGATED|AGGREGATED)
query I
SELECT COUNT(*) FROM ts_aggregate_hierarchy('hier_sales', sale_date, quantity, region_id, store_id, item_id) WHERE unique_id = 'AGGREGATED|AGGREGATED|AGGREGATED';
----
1

# Test grand total value is correct (100+50+75+200 = 425)
query I
SELECT value_col FROM ts_aggregate_hierarchy('hier_sales', sale_date, quantity, region_id, store_id, item_id) WHERE unique_id = 'AGGREGATED|AGGREGATED|AGGREGATED';
----
425.0

# Test region level aggregation exists
query I
SELECT COUNT(*) FROM ts_aggregate_hierarchy('hier_sales', sale_date, quantity, region_id, store_id, item_id) WHERE unique_id = 'EU|AGGREGATED|AGGREGATED';
----
1

# Test region level value is correct (EU = 100+50+75 = 225)
query I
SELECT value_col FROM ts_aggregate_hierarchy('hier_sales', sale_date, quantity, region_id, store_id, item_id) WHERE unique_id = 'EU|AGGREGATED|AGGREGATED';
----
225.0

# Test store level aggregation exists
query I
SELECT COUNT(*) FROM ts_aggregate_hierarchy('hier_sales', sale_date, quantity, region_id, store_id, item_id) WHERE unique_id = 'EU|STORE001|AGGREGATED';
----
1

# Test store level value is correct (EU|STORE001 = 100+50 = 150)
query I
SELECT value_col FROM ts_aggregate_hierarchy('hier_sales', sale_date, quantity, region_id, store_id, item_id) WHERE unique_id = 'EU|STORE001|AGGREGATED';
----
150.0

# Test original data preserved
query I
SELECT value_col FROM ts_aggregate_hierarchy('hier_sales', sale_date, quantity, region_id, store_id, item_id) WHERE unique_id = 'EU|STORE001|SKU42';
----
100.0

# Test custom separator
query I
SELECT COUNT(*) FROM ts_aggregate_hierarchy('hier_sales', sale_date, quantity, region_id, store_id, item_id, params := MAP{'separator': '-'}) WHERE unique_id = 'AGGREGATED-AGGREGATED-AGGREGATED';
----
1

# Test custom aggregate keyword
query I
SELECT COUNT(*) FROM ts_aggregate_hierarchy('hier_sales', sale_date, quantity, region_id, store_id, item_id, params := MAP{'aggregate_keyword': 'TOTAL'}) WHERE unique_id = 'TOTAL|TOTAL|TOTAL';
----
1

#######################################
# ts_split_keys Tests
#######################################

statement ok
CREATE TABLE forecast_results AS SELECT * FROM (VALUES
    ('EU|STORE001|SKU42', DATE '2024-02-01', 120.0),
    ('EU|STORE001|AGGREGATED', DATE '2024-02-01', 200.0),
    ('EU|AGGREGATED|AGGREGATED', DATE '2024-02-01', 500.0),
    ('AGGREGATED|AGGREGATED|AGGREGATED', DATE '2024-02-01', 1000.0)
) AS t(unique_id, forecast_date, point_forecast);

# Test split returns 3 id parts
query III
SELECT id_part_1, id_part_2, id_part_3 FROM ts_split_keys('forecast_results', unique_id, forecast_date, point_forecast) WHERE id_part_1 = 'EU' AND id_part_3 = 'SKU42';
----
EU	STORE001	SKU42

# Test AGGREGATED keyword preserved
query III
SELECT id_part_1, id_part_2, id_part_3 FROM ts_split_keys('forecast_results', unique_id, forecast_date, point_forecast) WHERE id_part_1 = 'EU' AND id_part_3 = 'AGGREGATED' AND id_part_2 = 'STORE001';
----
EU	STORE001	AGGREGATED

# Test grand total split
query III
SELECT id_part_1, id_part_2, id_part_3 FROM ts_split_keys('forecast_results', unique_id, forecast_date, point_forecast) WHERE id_part_1 = 'AGGREGATED' AND id_part_2 = 'AGGREGATED' AND id_part_3 = 'AGGREGATED';
----
AGGREGATED	AGGREGATED	AGGREGATED

# Test custom separator
statement ok
CREATE TABLE dash_results AS SELECT * FROM (VALUES
    ('EU-STORE001-SKU42', DATE '2024-02-01', 100.0)
) AS t(unique_id, ds, forecast);

query III
SELECT id_part_1, id_part_2, id_part_3 FROM ts_split_keys('dash_results', unique_id, ds, forecast, separator := '-');
----
EU	STORE001	SKU42

# Test row count preserved
query I
SELECT COUNT(*) FROM ts_split_keys('forecast_results', unique_id, forecast_date, point_forecast);
----
4

#######################################
# End-to-End Workflow Test
#######################################

# Test complete round-trip: aggregate -> split
statement ok
CREATE TABLE workflow_sales AS SELECT * FROM (VALUES
    ('EU', 'S1', 'A', DATE '2024-01-01', 10),
    ('EU', 'S1', 'B', DATE '2024-01-01', 20),
    ('US', 'S2', 'C', DATE '2024-01-01', 30)
) AS t(region, store, item, dt, qty);

# Create aggregated data
statement ok
CREATE TABLE agg_data AS SELECT * FROM ts_aggregate_hierarchy('workflow_sales', dt, qty, region, store, item);

# Verify grand total
query I
SELECT value_col FROM agg_data WHERE unique_id = 'AGGREGATED|AGGREGATED|AGGREGATED';
----
60.0

# Split keys back
statement ok
CREATE TABLE split_data AS SELECT * FROM ts_split_keys('agg_data', unique_id, date_col, value_col);

# Verify split preserves data
query I
SELECT COUNT(*) FROM split_data WHERE id_part_1 = 'AGGREGATED' AND id_part_2 = 'AGGREGATED' AND id_part_3 = 'AGGREGATED';
----
1

# Verify original item preserved after split
query I
SELECT value_col FROM split_data WHERE id_part_1 = 'EU' AND id_part_2 = 'S1' AND id_part_3 = 'A';
----
10.0
