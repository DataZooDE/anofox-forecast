# name: test/sql/ts_data_quality.test
# description: Tests for ts_data_quality table function (C++ API compatible)
# group: [sql]

require anofox_forecast

#######################################
# Internal _ts_data_quality Scalar Function Tests
#######################################

# Test returns STRUCT with structural_score
query I
SELECT (_ts_data_quality([1.0, 2.0, 3.0, 4.0, 5.0])).structural_score IS NOT NULL;
----
true

# Test returns STRUCT with temporal_score
query I
SELECT (_ts_data_quality([1.0, 2.0, 3.0, 4.0, 5.0])).temporal_score IS NOT NULL;
----
true

# Test returns STRUCT with magnitude_score
query I
SELECT (_ts_data_quality([1.0, 2.0, 3.0, 4.0, 5.0])).magnitude_score IS NOT NULL;
----
true

# Test returns STRUCT with behavioral_score
query I
SELECT (_ts_data_quality([1.0, 2.0, 3.0, 4.0, 5.0])).behavioral_score IS NOT NULL;
----
true

# Test returns STRUCT with overall_score
query I
SELECT (_ts_data_quality([1.0, 2.0, 3.0, 4.0, 5.0])).overall_score IS NOT NULL;
----
true

# Test returns STRUCT with n_gaps
query I
SELECT (_ts_data_quality([1.0, 2.0, 3.0, 4.0, 5.0])).n_gaps IS NOT NULL;
----
true

# Test returns STRUCT with n_missing
query I
SELECT (_ts_data_quality([1.0, 2.0, 3.0, 4.0, 5.0])).n_missing IS NOT NULL;
----
true

# Test returns STRUCT with is_constant
query I
SELECT (_ts_data_quality([1.0, 2.0, 3.0, 4.0, 5.0])).is_constant IS NOT NULL;
----
true

#######################################
# Score Bounds Tests
#######################################

# Scores should be between 0 and 1 (or positive)
query I
SELECT (_ts_data_quality([1.0, 2.0, 3.0, 4.0, 5.0])).overall_score >= 0;
----
true

query I
SELECT (_ts_data_quality([1.0, 2.0, 3.0, 4.0, 5.0])).structural_score >= 0;
----
true

#######################################
# Good Quality Data Tests
#######################################

# Clean linear trend should have high quality
query I
SELECT (_ts_data_quality([1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0])).overall_score > 0.5;
----
true

# No gaps in clean data
query I
SELECT (_ts_data_quality([1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0])).n_gaps;
----
0

# No missing in clean data
query I
SELECT (_ts_data_quality([1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0])).n_missing;
----
0

#######################################
# Constant Series Tests
#######################################

# Constant series should be marked as constant
query I
SELECT (_ts_data_quality([5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0, 5.0])).is_constant;
----
true

# Non-constant series should not be marked as constant
query I
SELECT (_ts_data_quality([1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0])).is_constant;
----
false

#######################################
# Series with NULLs
#######################################

# Series with NULLs should report missing count
query I
SELECT (_ts_data_quality([1.0, NULL, 3.0, NULL, 5.0])).n_missing;
----
2

# Series with NULLs should still have a quality score
query I
SELECT (_ts_data_quality([1.0, NULL, 3.0, NULL, 5.0])).overall_score >= 0;
----
true

#######################################
# NULL Handling
#######################################

# NULL input should return NULL
query I
SELECT _ts_data_quality(NULL) IS NULL;
----
true

#######################################
# Table Function API Tests
#######################################

statement ok
CREATE TABLE quality_test AS
SELECT 'A' AS id, ('2023-01-01'::DATE + (i || ' day')::INTERVAL)::TIMESTAMP AS date, (i + 1)::DOUBLE AS val
FROM generate_series(0, 9) AS t(i);

# Test ts_data_quality table function returns results
query I
SELECT COUNT(*) FROM ts_data_quality('quality_test', id, date, val, 5, '1 day');
----
1

statement ok
DROP TABLE quality_test;

#######################################
# ts_data_quality_by - Alias Test
#######################################

statement ok
CREATE TABLE test_dq_by AS
SELECT
    CASE WHEN i <= 10 THEN 'A' ELSE 'B' END AS unique_id,
    '2023-01-01'::TIMESTAMP + INTERVAL (i % 10) DAY AS date,
    (i % 10 + 1)::DOUBLE AS value
FROM range(1, 21) t(i);

# Test ts_data_quality_by alias works
query I
SELECT count(*) FROM ts_data_quality_by('test_dq_by', unique_id, date, value, 3, '1d');
----
2

statement ok
DROP TABLE test_dq_by;

#######################################
# ts_data_quality_agg - Aggregate Function Tests
#######################################

# Create test data for aggregate tests
statement ok
CREATE TABLE test_dq_agg AS
SELECT 'A' AS id,
       ('2023-01-01'::DATE + (i || ' days')::INTERVAL)::TIMESTAMP AS date,
       (i + 1)::DOUBLE AS value
FROM generate_series(0, 9) AS t(i)
UNION ALL
SELECT 'B' AS id,
       ('2023-01-01'::DATE + (i || ' days')::INTERVAL)::TIMESTAMP AS date,
       5.0::DOUBLE AS value
FROM generate_series(0, 9) AS t(i);

# Test ts_data_quality_agg returns STRUCT with overall_score
query I
SELECT (ts_data_quality_agg(date, value)).overall_score IS NOT NULL
FROM test_dq_agg
WHERE id = 'A';
----
true

# Test ts_data_quality_agg returns STRUCT with structural_score
query I
SELECT (ts_data_quality_agg(date, value)).structural_score IS NOT NULL
FROM test_dq_agg
WHERE id = 'A';
----
true

# Test ts_data_quality_agg detects constant series
query I
SELECT (ts_data_quality_agg(date, value)).is_constant
FROM test_dq_agg
WHERE id = 'B';
----
true

# Test ts_data_quality_agg non-constant series
query I
SELECT (ts_data_quality_agg(date, value)).is_constant
FROM test_dq_agg
WHERE id = 'A';
----
false

# Test ts_data_quality_agg with GROUP BY
query II
SELECT id, (ts_data_quality_agg(date, value)).is_constant
FROM test_dq_agg
GROUP BY id
ORDER BY id;
----
A	false
B	true

# Test ts_data_quality_agg quality scores are between 0 and 1
query I
SELECT (ts_data_quality_agg(date, value)).overall_score >= 0
   AND (ts_data_quality_agg(date, value)).overall_score <= 1
FROM test_dq_agg
WHERE id = 'A';
----
true

# Test ts_data_quality_agg with aliased name
query I
SELECT (anofox_fcst_ts_data_quality_agg(date, value)).overall_score IS NOT NULL
FROM test_dq_agg
WHERE id = 'A';
----
true

statement ok
DROP TABLE test_dq_agg;
