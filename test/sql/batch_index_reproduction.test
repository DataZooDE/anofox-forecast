# name: test/sql/batch_index_reproduction.test
# description: Demonstrate batch index collision in DuckDB Table-In-Out operators with heavy Final phase
# group: [sql]

require anofox_forecast

# This test demonstrates a race condition in DuckDB's PhysicalBatchInsert::AddCollection
# that occurs when:
#   1. Using a Table-In-Out operator with in_out_function + in_out_function_final
#   2. The Final phase is CPU-intensive (variable completion times across threads)
#   3. High volume data (many groups) triggers parallel execution
#
# Error: "batch index 9999999999999 is present in multiple collections"
# The value 9999999999999 appears to be a sentinel/uninitialized batch index.

# ============================================================================
# TEST 1: Small dataset - should work
# ============================================================================
statement ok
CREATE TABLE small_test AS
SELECT
    'group_' || (i % 10) AS group_id,
    i AS value
FROM range(100) t(i);

# Small dataset with 100ms delay per group - should work
statement ok
CREATE TABLE small_result AS
SELECT * FROM test_batch_index_reproduction(
    TABLE small_test,
    'group_id',
    'value',
    100  -- 100ms delay per group
);

query I
SELECT COUNT(*) FROM small_result;
----
100

statement ok
DROP TABLE small_test;

statement ok
DROP TABLE small_result;

# ============================================================================
# TEST 2: Medium dataset - may fail with sufficient parallelism
# ============================================================================
statement ok
CREATE TABLE medium_test AS
SELECT
    'group_' || (i % 1000) AS group_id,
    i AS value
FROM range(10000) t(i);

# Medium dataset with 10ms delay - this should complete but may be slow
statement ok
CREATE TABLE medium_result AS
SELECT * FROM test_batch_index_reproduction(
    TABLE medium_test,
    'group_id',
    'value',
    10  -- 10ms delay per group
);

query I
SELECT COUNT(*) FROM medium_result;
----
10000

statement ok
DROP TABLE medium_test;

statement ok
DROP TABLE medium_result;

# ============================================================================
# TEST 3: Large dataset - demonstrates the issue
# This test is expected to fail with the batch index collision error
# when run with multiple threads (default DuckDB behavior)
# ============================================================================

# NOTE: This test may fail with:
#   "batch index 9999999999999 is present in multiple collections"
# This is the bug being demonstrated.

# Create large test dataset with 10,000 groups
statement ok
CREATE TABLE large_test AS
SELECT
    'group_' || (i % 10000) AS group_id,
    i AS value
FROM range(100000) t(i);

# Large dataset with 1ms delay - triggers the race condition
# UNCOMMENT THE FOLLOWING TO REPRODUCE THE BUG:
# statement error
# CREATE TABLE large_result AS
# SELECT * FROM test_batch_index_reproduction(
#     TABLE large_test,
#     'group_id',
#     'value',
#     1  -- 1ms delay per group
# );

statement ok
DROP TABLE large_test;

# ============================================================================
# TEST 4: Workaround - Single thread execution
# ============================================================================
statement ok
CREATE TABLE single_thread_test AS
SELECT
    'group_' || (i % 100) AS group_id,
    i AS value
FROM range(1000) t(i);

# Force single-threaded execution - should work
statement ok
PRAGMA threads=1;

statement ok
CREATE TABLE single_thread_result AS
SELECT * FROM test_batch_index_reproduction(
    TABLE single_thread_test,
    'group_id',
    'value',
    50  -- 50ms delay per group
);

query I
SELECT COUNT(*) FROM single_thread_result;
----
1000

# Reset to default threads
statement ok
PRAGMA threads=8;

statement ok
DROP TABLE single_thread_test;

statement ok
DROP TABLE single_thread_result;

# ============================================================================
# TEST 5: SELECT vs CREATE TABLE
# The issue occurs specifically with CREATE TABLE AS (batch insert)
# SELECT should work even with parallel execution
# ============================================================================
statement ok
CREATE TABLE select_test AS
SELECT
    'group_' || (i % 500) AS group_id,
    i AS value
FROM range(5000) t(i);

# SELECT should work - no batch insert involved
query I
SELECT COUNT(*) FROM (
    SELECT * FROM test_batch_index_reproduction(
        TABLE select_test,
        'group_id',
        'value',
        5  -- 5ms delay per group
    )
);
----
5000

statement ok
DROP TABLE select_test;
