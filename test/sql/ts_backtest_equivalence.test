# name: test/sql/ts_backtest_equivalence.test
# description: Tests verifying ts_cv_folds_by + ts_cv_forecast_by produces identical results to ts_cv_split_by detailed approach
# group: [sql]

require anofox_forecast

#######################################
# Setup Test Data
#######################################

statement ok
CREATE TABLE equiv_data AS
SELECT
    series_id,
    '2024-01-01'::DATE + (i || ' day')::INTERVAL AS date,
    100.0 + i * 2.0 + (CASE WHEN series_id = 'A' THEN 50 ELSE 0 END) + (i % 7) * 3.0 AS value
FROM generate_series(0, 59) AS t(i)
CROSS JOIN (SELECT UNNEST(['A', 'B']) AS series_id) s;

#######################################
# Test 1: Basic Equivalence - Naive Method
# Compare ts_cv_folds_by vs ts_cv_split_by with explicit fold dates
#######################################

# Create folds using simplified approach (ts_cv_folds_by)
# For 60 days of data, 2 folds, horizon 7
statement ok
CREATE TABLE folds_simple AS
SELECT * FROM ts_cv_folds_by('equiv_data', series_id, date, value, 2, 7, MAP{});

# Generate forecasts using simplified workflow
statement ok
CREATE TABLE forecast_simple_naive AS
SELECT
    fold_id,
    series_id,
    date,
    ROUND(forecast, 6) AS forecast,
    ROUND(y, 6) AS actual,
    ROUND(forecast - y, 6) AS error,
    ROUND(ABS(forecast - y), 6) AS abs_error,
    model_name
FROM ts_cv_forecast_by('folds_simple', series_id, date, value, 'Naive', MAP{})
ORDER BY fold_id, series_id, date;

# Create detailed approach: Use ts_cv_split_by with explicit fold dates
# ts_cv_folds_by with n_folds=2, horizon=7 on 60-day data creates:
# Fold 1: train ends at day 45 (2024-02-15), test is days 46-52
# Fold 2: train ends at day 52 (2024-02-22), test is days 53-59
statement ok
CREATE TABLE cv_splits_detailed AS
SELECT * FROM ts_cv_split_by(
    'equiv_data', series_id, date, value,
    ['2024-02-15'::DATE, '2024-02-22'::DATE],
    7, MAP{}
);

# Generate forecasts using detailed workflow
statement ok
CREATE TABLE forecast_detailed_naive AS
SELECT
    fold_id,
    series_id,
    date,
    ROUND(forecast, 6) AS forecast,
    ROUND(y, 6) AS actual,
    ROUND(forecast - y, 6) AS error,
    ROUND(ABS(forecast - y), 6) AS abs_error,
    model_name
FROM ts_cv_forecast_by('cv_splits_detailed', series_id, date, value, 'Naive', MAP{})
ORDER BY fold_id, series_id, date;

# Verify same number of rows
query I
SELECT (SELECT COUNT(*) FROM forecast_simple_naive) = (SELECT COUNT(*) FROM forecast_detailed_naive);
----
true

# Verify forecasts match
query I
SELECT COUNT(*) FROM forecast_simple_naive s
JOIN forecast_detailed_naive d
    ON s.fold_id = d.fold_id
    AND s.series_id = d.series_id
    AND s.date = d.date
WHERE s.forecast = d.forecast;
----
28

# Verify actuals match
query I
SELECT COUNT(*) FROM forecast_simple_naive s
JOIN forecast_detailed_naive d
    ON s.fold_id = d.fold_id
    AND s.series_id = d.series_id
    AND s.date = d.date
WHERE s.actual = d.actual;
----
28

# Verify errors match
query I
SELECT COUNT(*) FROM forecast_simple_naive s
JOIN forecast_detailed_naive d
    ON s.fold_id = d.fold_id
    AND s.series_id = d.series_id
    AND s.date = d.date
WHERE s.error = d.error AND s.abs_error = d.abs_error;
----
28

# Verify model names match
query I
SELECT COUNT(*) FROM forecast_simple_naive s
JOIN forecast_detailed_naive d
    ON s.fold_id = d.fold_id
    AND s.series_id = d.series_id
    AND s.date = d.date
WHERE s.model_name = d.model_name;
----
28

#######################################
# Test 2: SeasonalNaive Method
#######################################

statement ok
CREATE TABLE forecast_simple_snaive AS
SELECT
    fold_id,
    series_id,
    date,
    ROUND(forecast, 6) AS forecast,
    ROUND(y, 6) AS actual,
    model_name
FROM ts_cv_forecast_by('folds_simple', series_id, date, value, 'SeasonalNaive', MAP{})
ORDER BY fold_id, series_id, date;

statement ok
CREATE TABLE forecast_detailed_snaive AS
SELECT
    fold_id,
    series_id,
    date,
    ROUND(forecast, 6) AS forecast,
    ROUND(y, 6) AS actual,
    model_name
FROM ts_cv_forecast_by('cv_splits_detailed', series_id, date, value, 'SeasonalNaive', MAP{})
ORDER BY fold_id, series_id, date;

# Verify forecasts match for SeasonalNaive
query I
SELECT COUNT(*) FROM forecast_simple_snaive s
JOIN forecast_detailed_snaive d
    ON s.fold_id = d.fold_id
    AND s.series_id = d.series_id
    AND s.date = d.date
WHERE s.forecast = d.forecast AND s.actual = d.actual;
----
28

#######################################
# Test 3: Theta Method
#######################################

statement ok
CREATE TABLE forecast_simple_theta AS
SELECT
    fold_id,
    series_id,
    date,
    ROUND(forecast, 4) AS forecast,
    ROUND(y, 4) AS actual,
    model_name
FROM ts_cv_forecast_by('folds_simple', series_id, date, value, 'Theta', MAP{})
ORDER BY fold_id, series_id, date;

statement ok
CREATE TABLE forecast_detailed_theta AS
SELECT
    fold_id,
    series_id,
    date,
    ROUND(forecast, 4) AS forecast,
    ROUND(y, 4) AS actual,
    model_name
FROM ts_cv_forecast_by('cv_splits_detailed', series_id, date, value, 'Theta', MAP{})
ORDER BY fold_id, series_id, date;

# Verify Theta forecasts match (with tolerance for floating point)
query I
SELECT COUNT(*) FROM forecast_simple_theta s
JOIN forecast_detailed_theta d
    ON s.fold_id = d.fold_id
    AND s.series_id = d.series_id
    AND s.date = d.date
WHERE ABS(s.forecast - d.forecast) < 0.01 AND s.actual = d.actual;
----
28

#######################################
# Test 4: SES Method
#######################################

statement ok
CREATE TABLE forecast_simple_ses AS
SELECT
    fold_id,
    series_id,
    date,
    ROUND(forecast, 4) AS forecast,
    ROUND(y, 4) AS actual,
    model_name
FROM ts_cv_forecast_by('folds_simple', series_id, date, value, 'SES', MAP{})
ORDER BY fold_id, series_id, date;

statement ok
CREATE TABLE forecast_detailed_ses AS
SELECT
    fold_id,
    series_id,
    date,
    ROUND(forecast, 4) AS forecast,
    ROUND(y, 4) AS actual,
    model_name
FROM ts_cv_forecast_by('cv_splits_detailed', series_id, date, value, 'SES', MAP{})
ORDER BY fold_id, series_id, date;

# Verify SES forecasts match
query I
SELECT COUNT(*) FROM forecast_simple_ses s
JOIN forecast_detailed_ses d
    ON s.fold_id = d.fold_id
    AND s.series_id = d.series_id
    AND s.date = d.date
WHERE ABS(s.forecast - d.forecast) < 0.01 AND s.actual = d.actual;
----
28

#######################################
# Test 5: Aggregate Metrics Match
#######################################

# Compare aggregate MAE between approaches
query I
SELECT
    ABS(
        (SELECT ROUND(AVG(abs_error), 4) FROM forecast_simple_naive) -
        (SELECT ROUND(AVG(abs_error), 4) FROM forecast_detailed_naive)
    ) < 0.001;
----
true

# Compare aggregate RMSE between approaches
query I
SELECT
    ABS(
        (SELECT ROUND(SQRT(AVG(error * error)), 4) FROM forecast_simple_naive) -
        (SELECT ROUND(SQRT(AVG(error * error)), 4) FROM forecast_detailed_naive)
    ) < 0.001;
----
true

# Compare per-fold metrics
query I
SELECT COUNT(*) FROM (
    SELECT fold_id, ROUND(AVG(abs_error), 4) AS mae FROM forecast_simple_naive GROUP BY fold_id
) s
JOIN (
    SELECT fold_id, ROUND(AVG(abs_error), 4) AS mae FROM forecast_detailed_naive GROUP BY fold_id
) d ON s.fold_id = d.fold_id
WHERE s.mae = d.mae;
----
2

#######################################
# Test 6: Single Series Equivalence
#######################################

statement ok
CREATE TABLE single_series AS
SELECT * FROM equiv_data WHERE series_id = 'A';

statement ok
CREATE TABLE folds_single AS
SELECT * FROM ts_cv_folds_by('single_series', series_id, date, value, 2, 7, MAP{});

statement ok
CREATE TABLE forecast_simple_single AS
SELECT fold_id, series_id, date, ROUND(forecast, 4) AS forecast, ROUND(y, 4) AS actual
FROM ts_cv_forecast_by('folds_single', series_id, date, value, 'Naive', MAP{})
ORDER BY fold_id, date;

statement ok
CREATE TABLE cv_splits_single AS
SELECT * FROM ts_cv_split_by(
    'single_series', series_id, date, value,
    ['2024-02-15'::DATE, '2024-02-22'::DATE],
    7, MAP{}
);

statement ok
CREATE TABLE forecast_detailed_single AS
SELECT
    fold_id,
    series_id,
    date,
    ROUND(forecast, 4) AS forecast,
    ROUND(y, 4) AS actual
FROM ts_cv_forecast_by('cv_splits_single', series_id, date, value, 'Naive', MAP{})
ORDER BY fold_id, date;

# Verify single series results match
query I
SELECT COUNT(*) FROM forecast_simple_single s
JOIN forecast_detailed_single d ON s.fold_id = d.fold_id AND s.date = d.date
WHERE s.forecast = d.forecast AND s.actual = d.actual;
----
14

#######################################
# Cleanup
#######################################

statement ok
DROP TABLE equiv_data;

statement ok
DROP TABLE folds_simple;

statement ok
DROP TABLE forecast_simple_naive;

statement ok
DROP TABLE cv_splits_detailed;

statement ok
DROP TABLE forecast_detailed_naive;

statement ok
DROP TABLE forecast_simple_snaive;

statement ok
DROP TABLE forecast_detailed_snaive;

statement ok
DROP TABLE forecast_simple_theta;

statement ok
DROP TABLE forecast_detailed_theta;

statement ok
DROP TABLE forecast_simple_ses;

statement ok
DROP TABLE forecast_detailed_ses;

statement ok
DROP TABLE single_series;

statement ok
DROP TABLE folds_single;

statement ok
DROP TABLE forecast_simple_single;

statement ok
DROP TABLE cv_splits_single;

statement ok
DROP TABLE forecast_detailed_single;
